<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="核心知识遍历方式 前序遍历（递归，迭代） 中序遍历（递归，迭代） 后序遍历（递归，迭代） 层序遍历（借助queue迭代）  递归遍历1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&#x2F;&#x2F;前序遍历func preorderTraversal(root *TreeNode) (res">
<meta property="og:type" content="article">
<meta property="og:title" content="二叉树">
<meta property="og:url" content="http://localhost:4000/2024/03/28/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="核心知识遍历方式 前序遍历（递归，迭代） 中序遍历（递归，迭代） 后序遍历（递归，迭代） 层序遍历（借助queue迭代）  递归遍历1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&#x2F;&#x2F;前序遍历func preorderTraversal(root *TreeNode) (res">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://code-thinking.cdn.bcebos.com/gifs/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89.gif">
<meta property="og:image" content="https://code-thinking.cdn.bcebos.com/gifs/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89.gif">
<meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/202102041512582.png">
<meta property="article:published_time" content="2024-03-28T07:25:36.036Z">
<meta property="article:modified_time" content="2024-04-02T06:28:00.571Z">
<meta property="article:author" content="jonas">
<meta property="article:tag" content="leetcode">
<meta property="article:tag" content="二叉树">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://code-thinking.cdn.bcebos.com/gifs/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89.gif">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>二叉树</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 7.1.1"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a href="/search">Search</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/jonasrepo.github.io">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2024/04/03/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2024/03/26/leetcode/%E5%9B%9E%E6%BA%AF/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://localhost:4000/2024/03/28/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://localhost:4000/2024/03/28/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/&text=二叉树"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://localhost:4000/2024/03/28/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/&title=二叉树"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://localhost:4000/2024/03/28/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/&is_video=false&description=二叉树"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=二叉树&body=Check out this article: http://localhost:4000/2024/03/28/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://localhost:4000/2024/03/28/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/&title=二叉树"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://localhost:4000/2024/03/28/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/&title=二叉树"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://localhost:4000/2024/03/28/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/&title=二叉树"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://localhost:4000/2024/03/28/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/&title=二叉树"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://localhost:4000/2024/03/28/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/&name=二叉树&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://localhost:4000/2024/03/28/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/&t=二叉树"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">核心知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">遍历方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86"><span class="toc-number">1.1.1.</span> <span class="toc-text">递归遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86"><span class="toc-number">1.1.2.</span> <span class="toc-text">迭代遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">前序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">中序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">后序遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.1.3.</span> <span class="toc-text">层序遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.2.</span> <span class="toc-text">二叉搜索树</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE"><span class="toc-number">2.</span> <span class="toc-text">相关题目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-number">2.1.</span> <span class="toc-text">104 二叉树的最大深度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91"><span class="toc-number">2.1.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91"><span class="toc-number">2.1.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91"><span class="toc-number">2.1.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6"><span class="toc-number">2.2.</span> <span class="toc-text">111 二叉树的最小深度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-1"><span class="toc-number">2.2.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-1"><span class="toc-number">2.2.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-1"><span class="toc-number">2.2.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.3.</span> <span class="toc-text">226 翻转二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-2"><span class="toc-number">2.3.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-2"><span class="toc-number">2.3.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-2"><span class="toc-number">2.3.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.4.</span> <span class="toc-text">101 对称二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-3"><span class="toc-number">2.4.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-3"><span class="toc-number">2.4.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-3"><span class="toc-number">2.4.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.5.</span> <span class="toc-text">110 平衡二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-4"><span class="toc-number">2.5.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-4"><span class="toc-number">2.5.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-4"><span class="toc-number">2.5.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84"><span class="toc-number">2.6.</span> <span class="toc-text">257 二叉树的所有路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-5"><span class="toc-number">2.6.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-5"><span class="toc-number">2.6.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-5"><span class="toc-number">2.6.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#404-%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C"><span class="toc-number">2.7.</span> <span class="toc-text">404 左叶子之和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-6"><span class="toc-number">2.7.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-6"><span class="toc-number">2.7.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-6"><span class="toc-number">2.7.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#513-%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC"><span class="toc-number">2.8.</span> <span class="toc-text">513 找树左下角的值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-7"><span class="toc-number">2.8.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-7"><span class="toc-number">2.8.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-7"><span class="toc-number">2.8.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C"><span class="toc-number">2.9.</span> <span class="toc-text">112 路径总和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-8"><span class="toc-number">2.9.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-8"><span class="toc-number">2.9.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-8"><span class="toc-number">2.9.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-II"><span class="toc-number">2.10.</span> <span class="toc-text">113 路径总和 II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-9"><span class="toc-number">2.10.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-9"><span class="toc-number">2.10.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-9"><span class="toc-number">2.10.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.11.</span> <span class="toc-text">106 从中序与后序遍历序列构造二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-10"><span class="toc-number">2.11.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-10"><span class="toc-number">2.11.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-10"><span class="toc-number">2.11.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.12.</span> <span class="toc-text">654 最大二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-11"><span class="toc-number">2.12.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-11"><span class="toc-number">2.12.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-11"><span class="toc-number">2.12.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.13.</span> <span class="toc-text">617 合并二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-12"><span class="toc-number">2.13.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-12"><span class="toc-number">2.13.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-12"><span class="toc-number">2.13.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">2.14.</span> <span class="toc-text">700 二叉搜索树的查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">2.15.</span> <span class="toc-text">98 验证二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-13"><span class="toc-number">2.15.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-13"><span class="toc-number">2.15.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-13"><span class="toc-number">2.15.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#530-%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE%E5%80%BC"><span class="toc-number">2.16.</span> <span class="toc-text">530 最小绝对差值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-14"><span class="toc-number">2.16.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-14"><span class="toc-number">2.16.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-14"><span class="toc-number">2.16.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#501-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0"><span class="toc-number">2.17.</span> <span class="toc-text">501 二叉搜索树中的众数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-15"><span class="toc-number">2.17.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-15"><span class="toc-number">2.17.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-15"><span class="toc-number">2.17.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">2.18.</span> <span class="toc-text">236 二叉树的最近公共祖先</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-16"><span class="toc-number">2.18.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-16"><span class="toc-number">2.18.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-16"><span class="toc-number">2.18.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#235-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">2.19.</span> <span class="toc-text">235. 二叉搜索树的最近公共祖先</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-17"><span class="toc-number">2.19.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-17"><span class="toc-number">2.19.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-17"><span class="toc-number">2.19.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#701-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">2.20.</span> <span class="toc-text">701. 二叉搜索树中的插入操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-18"><span class="toc-number">2.20.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-18"><span class="toc-number">2.20.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-18"><span class="toc-number">2.20.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">2.21.</span> <span class="toc-text">450 删除二叉搜索树中的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-19"><span class="toc-number">2.21.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-19"><span class="toc-number">2.21.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-19"><span class="toc-number">2.21.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#669-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">2.22.</span> <span class="toc-text">669 修剪二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-20"><span class="toc-number">2.22.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-20"><span class="toc-number">2.22.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-20"><span class="toc-number">2.22.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">2.23.</span> <span class="toc-text">108 将有序数组转换为二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-21"><span class="toc-number">2.23.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-21"><span class="toc-number">2.23.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-21"><span class="toc-number">2.23.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#538-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91"><span class="toc-number">2.24.</span> <span class="toc-text">538 把二叉搜索树转换为累加树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-22"><span class="toc-number">2.24.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-22"><span class="toc-number">2.24.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-22"><span class="toc-number">2.24.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        二叉树
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">jonas</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-03-28T07:25:36.036Z" class="dt-published" itemprop="datePublished">2024-03-28</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/leetcode/" rel="tag">leetcode</a>, <a class="p-category" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1 id="核心知识"><a href="#核心知识" class="headerlink" title="核心知识"></a>核心知识</h1><h2 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h2><ul>
<li>前序遍历（递归，迭代）</li>
<li>中序遍历（递归，迭代）</li>
<li>后序遍历（递归，迭代）</li>
<li>层序遍历（借助queue迭代）</li>
</ul>
<h3 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span></span> (res []<span class="type">int</span>) &#123;</span><br><span class="line">	res := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> traverse <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span></span><br><span class="line">	traverse = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> root == <span class="literal">nil</span>&#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		res = <span class="built_in">append</span>(res, root.Val)</span><br><span class="line">		traverse(root.Left)</span><br><span class="line">		traverse(root.Right)</span><br><span class="line">	&#125;</span><br><span class="line">	traverse(root)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span></span> (res []<span class="type">int</span>) &#123;</span><br><span class="line">	res := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> traverse <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span></span><br><span class="line">	traverse = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> root == <span class="literal">nil</span>&#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		traverse(root.Left)</span><br><span class="line">		res = <span class="built_in">append</span>(res, root.Val)</span><br><span class="line">		traverse(root.Right)</span><br><span class="line">	&#125;</span><br><span class="line">	traverse(root)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postorderTraversal</span><span class="params">(root *TreeNode)</span></span> (res []<span class="type">int</span>) &#123;</span><br><span class="line">	res := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> traverse <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span></span><br><span class="line">	traverse = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> root == <span class="literal">nil</span>&#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		traverse(root.Left)</span><br><span class="line">		traverse(root.Right)</span><br><span class="line">		res = <span class="built_in">append</span>(res, root.Val)</span><br><span class="line">	&#125;</span><br><span class="line">	traverse(root)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迭代遍历"><a href="#迭代遍历" class="headerlink" title="迭代遍历"></a>迭代遍历</h3><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p><img src="https://code-thinking.cdn.bcebos.com/gifs/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89.gif"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	stack := []*TreeNode&#123;root&#125;</span><br><span class="line">	res := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		node := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">		stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">		res = <span class="built_in">append</span>(res, node.Val)</span><br><span class="line">		<span class="comment">//入栈顺序是先如右节点，再入左节点</span></span><br><span class="line">		<span class="comment">//因为栈是先进后出，右节点是后被返回，所以要先入栈</span></span><br><span class="line">		<span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">			stack = <span class="built_in">append</span>(stack, node.Right)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">			stack = <span class="built_in">append</span>(stack, node.Left)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p><img src="https://code-thinking.cdn.bcebos.com/gifs/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89.gif"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	res := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	stack := [] *TreeNode&#123;&#125;</span><br><span class="line">	cur := root</span><br><span class="line">	<span class="keyword">for</span> cur != <span class="literal">nil</span> || <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">//一直遍历左节点知道左节点为空</span></span><br><span class="line">		<span class="keyword">if</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">			stack = <span class="built_in">append</span>(stack, cur)</span><br><span class="line">			cur = cur.Left</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//此时左节点为空，弹出栈顶元素，将改zhi加入res中，并继续遍历他的右节点</span></span><br><span class="line">			cur = stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">			stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">			res = <span class="built_in">append</span>(res, cur.Val)</span><br><span class="line">			cur = cur.Right</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>后续遍历的顺序是左右中，前序遍历的顺序是中左右，将前序的入栈顺序反过来，前序就成了中右左，再将res的结果翻转就行</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postorderTraversal</span><span class="params">(root *TreeNode)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	res := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	stack := []*TreeNode&#123;root&#125;</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		cur := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">		stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">		res = <span class="built_in">append</span>(res ,cur.Val)</span><br><span class="line">		<span class="keyword">if</span> cur.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">			stack = <span class="built_in">append</span>(stack, cur.Left)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> cur.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">			stack = <span class="built_in">append</span>(stack, cur.Right)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	i,j:=<span class="number">0</span>,<span class="built_in">len</span>(res)<span class="number">-1</span></span><br><span class="line">	<span class="keyword">for</span> i&lt;=j &#123;</span><br><span class="line">		res[i],res[j] = res[j],res[i]</span><br><span class="line">		i++</span><br><span class="line">		j--</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> results [][]<span class="type">int</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> results</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    queue := []*TreeNode&#123;root&#125;  <span class="comment">// 初始化队列，首先加入根节点</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        levelSize := <span class="built_in">len</span>(queue) <span class="comment">// 当前层的节点数量</span></span><br><span class="line">        <span class="keyword">var</span> currentLevel []<span class="type">int</span>  <span class="comment">// 当前层的结果</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; levelSize; i++ &#123; <span class="comment">// 遍历当前层的所有节点</span></span><br><span class="line">            node := queue[<span class="number">0</span>] <span class="comment">// 取出队列的第一个元素</span></span><br><span class="line">            queue = queue[<span class="number">1</span>:] <span class="comment">// 更新队列</span></span><br><span class="line">            currentLevel = <span class="built_in">append</span>(currentLevel, node.Val) <span class="comment">// 将当前节点的值加入到当前层结果中</span></span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123; <span class="comment">// 如果左子节点存在，加入队列</span></span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123; <span class="comment">// 如果右子节点存在，加入队列</span></span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        results = <span class="built_in">append</span>(results, currentLevel) <span class="comment">// 将当前层的结果加入到最终结果中</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>二叉搜索树是有序的，使用中序遍历，通常需要使用prev变量辅助，在在处理根节点后将prev&#x3D;root</p>
<h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104 二叉树的最大深度"></a>104 二叉树的最大深度</h2><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个二叉树，找出其最大深度。最大深度是从根节点到最远叶子节点的最长路径上的节点数量。说明: 叶子节点是指没有子节点的节点。</p>
<h3 id="【解题思路】"><a href="#【解题思路】" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>解决这个问题，我们可以使用深度优先搜索（DFS）的方法。通过递归地检查每个节点，我们可以找到从根节点到叶子节点的最长路径。具体步骤如下：</p>
<ol>
<li>若当前节点为<code>nil</code>（空节点），则深度为0，返回0。</li>
<li>递归地计算左子树的最大深度<code>leftDepth</code>和右子树的最大深度<code>rightDepth</code>。</li>
<li>当前节点的最大深度为左、右子树的最大深度的最大值加1（加1表示加上当前节点本身）。</li>
</ol>
<p>这种方法的核心思想在于，它从底向上地计算每个节点的深度，直到达到最大深度。</p>
<h3 id="【实现代码】"><a href="#【实现代码】" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// TreeNode 定义二叉树的节点</span></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// maxDepth 计算二叉树的最大深度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="comment">// 空树的深度为0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归地计算左右子树的深度</span></span><br><span class="line">    leftDepth := maxDepth(root.Left)</span><br><span class="line">    rightDepth := maxDepth(root.Right)</span><br><span class="line">    <span class="comment">// 返回较大的深度并加1（当前节点的深度）</span></span><br><span class="line">    <span class="keyword">if</span> leftDepth &gt; rightDepth &#123;</span><br><span class="line">        <span class="keyword">return</span> leftDepth + <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rightDepth + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//bfs</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue := []*TreeNode&#123;root&#125;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span>&#123;</span><br><span class="line">        n:=<span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;n;i++ &#123;</span><br><span class="line">            cur := queue[<span class="number">0</span>]</span><br><span class="line">            queue= queue[<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> cur.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, cur.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> cur.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, cur.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res++</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111 二叉树的最小深度"></a>111 二叉树的最小深度</h2><h3 id="【题目描述】-1"><a href="#【题目描述】-1" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。说明：叶子节点是指没有子节点的节点。</p>
<h3 id="【解题思路】-1"><a href="#【解题思路】-1" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>解决这个问题，我们可以使用深度优先搜索（DFS）或广度优先搜索（BFS）。</p>
<p><strong>深度优先搜索（DFS）方法</strong>： 递归地计算左子树和右子树的最小深度。对于每一个非叶子节点，我们只需要关心其子树的最小深度。有几点需要注意：</p>
<ul>
<li>如果一个节点的左子树为空，则返回右子树的最小深度 + 1。</li>
<li>如果一个节点的右子树为空，则返回左子树的最小深度 + 1。</li>
<li>如果左右子树都不为空，则返回左、右子树的最小深度的最小值 + 1。</li>
</ul>
<p>这个方法的核心思想是递归地求解子问题，并从底向上返回最小深度。</p>
<p><strong>广度优先搜索（BFS）方法</strong>： 我们按层次遍历树，当我们遇到第一个叶子节点时，停止遍历并返回该叶子节点所在层数，这个层数就是树的最小深度。这种方法的好处是一旦找到一个叶子节点就可以停止遍历，而不需要遍历整棵树。</p>
<p>这里，我们选择深度优先搜索（DFS）方法来实现，因为它相对直观，容易理解。</p>
<h3 id="【实现代码】-1"><a href="#【实现代码】-1" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// TreeNode 代表二叉树的节点</span></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// minDepth 用于计算二叉树的最小深度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minDepth</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果左子树为空，递归计算右子树的最小深度并加一</span></span><br><span class="line">    <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minDepth(root.Right) + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果右子树为空，递归计算左子树的最小深度并加一</span></span><br><span class="line">    <span class="keyword">if</span> root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minDepth(root.Left) + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果左右子树都不为空，分别递归计算左右子树的最小深度，取最小值并加一</span></span><br><span class="line">    <span class="keyword">return</span> min(minDepth(root.Left), minDepth(root.Right)) + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// min 用于计算两个整数的最小值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//bfs</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minDepth</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	queue := []*TreeNode&#123;root&#125;</span><br><span class="line">	res := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		n := <span class="built_in">len</span>(queue)</span><br><span class="line">		<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;n;i++ &#123;</span><br><span class="line">			cur := queue[<span class="number">0</span>]</span><br><span class="line">			queue =queue[<span class="number">1</span>:]</span><br><span class="line">			<span class="comment">//说明到了叶子节点， 直接返回</span></span><br><span class="line">			<span class="keyword">if</span> cur.Left == <span class="literal">nil</span> &amp;&amp; cur.Right == <span class="literal">nil</span>&#123;</span><br><span class="line">				<span class="keyword">return</span> res</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> cur.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">				queue = <span class="built_in">append</span>(queue, cur.Left)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> cur.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">				queue = <span class="built_in">append</span>(queue, cur.Right)</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">		res++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226 翻转二叉树"></a>226 翻转二叉树</h2><h3 id="【题目描述】-2"><a href="#【题目描述】-2" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>翻转一棵二叉树。</p>
<p>示例：</p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  2     7</span><br><span class="line"> / \   / \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  7     2</span><br><span class="line"> / \   / \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>

<h3 id="【解题思路】-2"><a href="#【解题思路】-2" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>翻转一棵二叉树的基本思想是遍历树中的每个节点，并交换每个节点的左右子节点。这个过程可以通过递归或迭代（使用队列）来实现。这里我们使用递归的方法，因为它更简洁易懂。</p>
<ol>
<li><strong>递归函数的定义</strong>：定义一个递归函数，它接受一个节点作为参数，将该节点的左右子树翻转，并返回翻转后的节点。</li>
<li><strong>递归的终止条件</strong>：如果当前节点为空，说明已经到达叶子节点的下一层，直接返回null。</li>
<li><strong>递归的过程</strong>：对当前节点的左子节点和右子节点分别调用递归函数，然后将两个返回的节点交换位置，最后返回当前节点。</li>
</ol>
<p>通过这个递归过程，我们可以实现从上到下，从根节点到叶子节点的完全翻转。</p>
<h3 id="【实现代码】-2"><a href="#【实现代码】-2" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// TreeNode 定义二叉树的节点</span></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dfs</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">invertTree</span><span class="params">(root *TreeNode)</span></span> *TreeNode &#123;</span><br><span class="line">	<span class="keyword">var</span> traverse <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span>*TreeNode </span><br><span class="line">	traverse = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span>*TreeNode &#123;</span><br><span class="line">		<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> root</span><br><span class="line">		&#125;</span><br><span class="line">		left := traverse(root.Left)</span><br><span class="line">		right := traverse(root.Right)</span><br><span class="line">		root.Left = right</span><br><span class="line">		root.Right = left</span><br><span class="line">		<span class="keyword">return</span> root</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> traverse(root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//bfs</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">invertTree</span><span class="params">(root *TreeNode)</span></span> *TreeNode &#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> root</span><br><span class="line">	&#125;</span><br><span class="line">	queue := []*TreeNode&#123;root&#125;</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		n := <span class="built_in">len</span>(queue)</span><br><span class="line">		<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;n;i++ &#123;</span><br><span class="line">			cur := queue[<span class="number">0</span>]</span><br><span class="line">			queue = queue[<span class="number">1</span>:]</span><br><span class="line">			cur.Left , cur.Right = cur.Right, cur.Left</span><br><span class="line">			<span class="keyword">if</span> cur.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">				queue = <span class="built_in">append</span>(queue, cur.Left)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> cur.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">				queue = <span class="built_in">append</span>(queue, cur.Right)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101 对称二叉树"></a>101 对称二叉树</h2><h3 id="【题目描述】-3"><a href="#【题目描述】-3" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个二叉树，检查它是否是镜像对称的。即，二叉树与它的镜像（左右反转）相同。</p>
<p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>
<p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure>

<h3 id="【解题思路】-3"><a href="#【解题思路】-3" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>要判断一个二叉树是否是对称的，我们可以采用递归的方法。对于树中任意两个对称节点，它们的值相等，且一个节点的左子节点与另一个节点的右子节点对称，一个节点的右子节点与另一个节点的左子节点对称。</p>
<ol>
<li><strong>递归函数的定义</strong>：定义一个递归函数<code>isMirror</code>，它接受两个节点作为参数，如果这两个节点对称，则返回<code>true</code>，否则返回<code>false</code>。</li>
<li><strong>递归的终止条件</strong>：如果两个节点都为空，则它们对称；如果只有一个节点为空，或者两个节点的值不相等，则它们不对称。</li>
<li><strong>递归的过程</strong>：对于两个节点<code>left</code>和<code>right</code>，判断<code>left</code>的左子节点与<code>right</code>的右子节点是否对称，以及<code>left</code>的右子节点与<code>right</code>的左子节点是否对称。</li>
</ol>
<p>最后，调用这个递归函数，以根节点的左右子节点为参数开始判断。</p>
<h3 id="【实现代码】-3"><a href="#【实现代码】-3" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// TreeNode 定义二叉树的节点</span></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dfs</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSymmetric</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> traverse <span class="function"><span class="keyword">func</span><span class="params">(left, right *TreeNode)</span></span> <span class="type">bool</span></span><br><span class="line">	traverse = <span class="function"><span class="keyword">func</span><span class="params">(left, right *TreeNode)</span></span> <span class="type">bool</span>&#123;</span><br><span class="line">		<span class="comment">//左右为空</span></span><br><span class="line">		<span class="keyword">if</span> left == <span class="literal">nil</span> &amp;&amp; right == <span class="literal">nil</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//左右都不为空</span></span><br><span class="line">		<span class="keyword">if</span> left != <span class="literal">nil</span> &amp;&amp; right != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> left.Val == right.Val &amp;&amp; traverse(left.Left, right.Right) &amp;&amp; traverse(left.Right, right.Left)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//左右有一个为空</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> traverse(root.Left, root.Right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//bfs</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSymmetric</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	queue := []*TreeNode&#123;root.Left, root.Right&#125;</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		left, right := queue[<span class="number">0</span>],queue[<span class="number">1</span>]</span><br><span class="line">		queue = queue[<span class="number">2</span>:]</span><br><span class="line">		<span class="comment">//左右都为空</span></span><br><span class="line">		<span class="keyword">if</span> left == <span class="literal">nil</span> &amp;&amp; right == <span class="literal">nil</span>&#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//left为空或right为空</span></span><br><span class="line">		<span class="keyword">if</span> left == <span class="literal">nil</span> || right == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//左右都不为空</span></span><br><span class="line">		<span class="keyword">if</span> left.Val != right.Val &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如队列</span></span><br><span class="line">		queue = <span class="built_in">append</span>(queue, left.Left,right.Right, left.Right, right.Left)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110 平衡二叉树"></a>110 平衡二叉树</h2><h3 id="【题目描述】-4"><a href="#【题目描述】-4" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一棵二叉树，判断其是否是一个高度平衡的二叉树。一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1，则称这棵树为高度平衡的二叉树。</p>
<h3 id="【解题思路】-4"><a href="#【解题思路】-4" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>要判断一棵树是否是平衡二叉树，我们需要从底向上遍历这棵树的每一个节点，对于每一个节点，计算其左右子树的高度，如果左右子树的高度差的绝对值大于1，则整棵树不是平衡二叉树；如果每一个节点的左右子树的高度差的绝对值都不超过1，则这棵树是平衡二叉树。</p>
<p>我们可以定义一个递归函数来计算二叉树的高度，递归过程中一旦发现有子树不满足高度平衡的条件，立即返回一个特殊值（例如，-1）以避免进一步的递归，这样可以提高算法的效率。</p>
<h3 id="【实现代码】-4"><a href="#【实现代码】-4" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// TreeNode 定义二叉树的节点</span></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isBalanced</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="comment">//-1表示不平衡，其他的代表高度</span></span><br><span class="line">	<span class="keyword">var</span> traverse <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span></span><br><span class="line">	traverse = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		left := traverse(root.Left)</span><br><span class="line">		right := traverse(root.Right)</span><br><span class="line">		<span class="keyword">if</span> left == <span class="number">-1</span> || right == <span class="number">-1</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> abs(left-right) &gt; <span class="number">1</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> max(left, right) + <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> traverse(root) != <span class="number">-1</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// abs 计算绝对值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">abs</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// max 返回两个数中的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257 二叉树的所有路径"></a>257 二叉树的所有路径</h2><h3 id="【题目描述】-5"><a href="#【题目描述】-5" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p>
<p><strong>说明</strong>: 叶子节点是指没有子节点的节点。</p>
<p><strong>示例</strong>:</p>
<p>输入:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   1</span><br><span class="line"> /   \</span><br><span class="line">2     3</span><br><span class="line"> \</span><br><span class="line">  5</span><br></pre></td></tr></table></figure>

<p>输出: [“1-&gt;2-&gt;5”, “1-&gt;3”]</p>
<p>解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3。</p>
<h3 id="【解题思路】-5"><a href="#【解题思路】-5" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>解决这个问题的关键是使用深度优先搜索（DFS）遍历整棵树，并在遍历的过程中记录路径。当到达叶子节点时，将当前路径添加到结果列表中。</p>
<p>具体步骤如下：</p>
<ol>
<li><strong>递归函数的定义</strong>：定义一个辅助递归函数<code>dfs</code>，它接受当前节点<code>node</code>和当前路径<code>path</code>作为参数。每次递归调用时，将当前节点加入到路径中。</li>
<li><strong>递归的终止条件</strong>：当当前节点是叶子节点时，将当前路径加入到结果列表中，然后返回。</li>
<li><strong>递归的过程</strong>：如果当前节点不是叶子节点，对其左右子节点进行递归调用，继续向下搜索。</li>
</ol>
<h3 id="【实现代码】-5"><a href="#【实现代码】-5" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// TreeNode 定义二叉树的节点</span></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binaryTreePaths</span><span class="params">(root *TreeNode)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">	res := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">	path := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> backtrack <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span></span><br><span class="line">	backtrack = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//终止条件 叶结点</span></span><br><span class="line">		<span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span>&#123;</span><br><span class="line">			path = <span class="built_in">append</span>(path, strconv.Itoa(root.Val))</span><br><span class="line">			res = <span class="built_in">append</span>(res, strings.Join(path, <span class="string">&quot;-&gt;&quot;</span>))</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		path = <span class="built_in">append</span>(path, strconv.Itoa(root.Val))</span><br><span class="line">		<span class="keyword">if</span> root.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">//递归和回溯是在一起的</span></span><br><span class="line">			backtrack(root.Left)</span><br><span class="line">			path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> root.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">			backtrack(root.Right)</span><br><span class="line">			path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	backtrack(root)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404 左叶子之和"></a>404 左叶子之和</h2><h3 id="【题目描述】-6"><a href="#【题目描述】-6" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>计算给定二叉树的所有左叶子之和。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>在这个例子中，有两个左叶子，分别是9和15，所以返回的和是24。</p>
<h3 id="【解题思路】-6"><a href="#【解题思路】-6" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>为了找到所有的左叶子节点并计算它们的和，我们可以采用递归的方式遍历整棵树。关键是要区分什么是左叶子节点：如果一个节点具有左子节点，且该左子节点不再有任何子节点，那么这个左子节点就是一个左叶子节点。</p>
<p>具体步骤如下：</p>
<ol>
<li><strong>递归函数的定义</strong>：定义一个辅助递归函数<code>dfs</code>，它接受当前节点<code>node</code>作为参数。每次递归调用时，检查当前节点的左子节点是否是左叶子，如果是，则将其值加到总和中。</li>
<li><strong>递归的终止条件</strong>：如果当前节点为空，则直接返回。</li>
<li><strong>递归的过程</strong>：对当前节点的左右子节点进行递归调用，累加左叶子的和。</li>
</ol>
<h3 id="【实现代码】-6"><a href="#【实现代码】-6" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// TreeNode 定义二叉树的节点</span></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sumOfLeftLeaves 计算所有左叶子之和</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumOfLeftLeaves</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> traverse <span class="function"><span class="keyword">func</span> <span class="params">(root *TreeNode)</span></span> </span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line">	traverse = <span class="function"><span class="keyword">func</span> <span class="params">(root *TreeNode)</span></span>  &#123;</span><br><span class="line">		<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//左叶子节点的判断依据是当前节点的左子树不为空，且左子树的左右孩子是空</span></span><br><span class="line">		<span class="keyword">if</span> root.Left != <span class="literal">nil</span> &amp;&amp; root.Left.Left == <span class="literal">nil</span> &amp;&amp; root.Left.Right == <span class="literal">nil</span>&#123;</span><br><span class="line">			res += root.Left.Val</span><br><span class="line">		&#125;</span><br><span class="line">		traverse(root.Left)</span><br><span class="line">		traverse(root.Right)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	traverse(root)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513 找树左下角的值"></a>513 找树左下角的值</h2><h3 id="【题目描述】-7"><a href="#【题目描述】-7" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个二叉树，在树的最后一行找到最左边的值。</p>
<p><strong>示例 1:</strong></p>
<p>输入:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  2</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure>
<p>输出:<br>1</p>
<p><strong>示例 2:</strong></p>
<p>输入:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> /   / \</span><br><span class="line">4   5   6</span><br><span class="line">   /</span><br><span class="line">  7</span><br></pre></td></tr></table></figure>
<p>输出:<br>7</p>
<p><strong>注意:</strong> 您可以假设树（即给定的根节点）不为 NULL。</p>
<h3 id="【解题思路】-7"><a href="#【解题思路】-7" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>找到树最后一行最左边的值，可以使用广度优先搜索（BFS）遍历二叉树。我们按层遍历树，每次遍历一层节点，并记录这一层的第一个节点的值。当我们遍历到最后一层时，记录的就是最后一层最左边的值。</p>
<p>具体步骤如下：</p>
<ol>
<li>使用一个队列来支持BFS遍历，初始时将根节点入队。</li>
<li>当队列不为空时，进行以下操作：<ul>
<li>获取当前队列的长度，这个长度就是当前层的节点数量。</li>
<li>遍历这一层的节点，对于每个节点，先将其左子节点入队，再将其右子节点入队。</li>
<li>在遍历每层的第一个节点时，记录其值。因为按照左子节点先入队的顺序，该值就是当前层最左边的值。</li>
</ul>
</li>
<li>当遍历完成后，记录的值就是最后一行最左边的值。</li>
</ol>
<h3 id="【实现代码】-7"><a href="#【实现代码】-7" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;container/list&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TreeNode 定义二叉树节点</span></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//bfs 比较简单</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findBottomLeftValue</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	queue := []*TreeNode&#123;root&#125;</span><br><span class="line">	res := root.Val</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		n := <span class="built_in">len</span>(queue)</span><br><span class="line">		<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;n;i++ &#123;</span><br><span class="line">			cur := queue[<span class="number">0</span>]</span><br><span class="line">			queue = queue[<span class="number">1</span>:]</span><br><span class="line">			res = cur.Val</span><br><span class="line">			<span class="keyword">if</span> cur.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">				queue = <span class="built_in">append</span>(queue, cur.Right)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> cur.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">				queue = <span class="built_in">append</span>(queue, cur.Left)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//dfs</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findBottomLeftValue</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	res := root.Val</span><br><span class="line">	maxDepth := <span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> traverse <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode, curDepth <span class="type">int</span>)</span></span></span><br><span class="line">	traverse = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode, curDepth <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> curDepth &gt; maxDepth &#123;</span><br><span class="line">				maxDepth = curDepth</span><br><span class="line">				res = root.Val</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		traverse(root.Left, curDepth+<span class="number">1</span>)</span><br><span class="line">		traverse(root.Right, curDepth+<span class="number">1</span>)	</span><br><span class="line">	&#125;</span><br><span class="line">	traverse(root, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112 路径总和"></a>112 路径总和</h2><h3 id="【题目描述】-8"><a href="#【题目描述】-8" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>叶子节点是指没有子节点的节点。</p>
<p><strong>示例 1:</strong></p>
<p>输入：<code>root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22</code><br>输出：<code>true</code><br>解释：等于目标和的根节点到叶节点路径如上图所示。</p>
<p><strong>示例 2:</strong></p>
<p>输入：<code>root = [1,2,3], targetSum = 5</code><br>输出：<code>false</code><br>解释：树中存在两条根节点到叶子节点的路径：<br>(1 –&gt; 2) 总和为 3<br>(1 –&gt; 3) 总和为 4<br>不存在总和为 5 的根节点到叶子节点的路径。</p>
<p><strong>示例 3:</strong></p>
<p>输入：<code>root = [], targetSum = 0</code><br>输出：<code>false</code><br>解释：由于树是空的，所以不存在根节点到叶子节点的路径。</p>
<h3 id="【解题思路】-8"><a href="#【解题思路】-8" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>要判断是否存在一条从根节点到叶子节点的路径，其路径上所有节点的值相加等于目标和，我们可以使用递归的方法遍历这棵树。对于每一个节点，我们做以下判断：</p>
<ol>
<li>如果当前节点是叶子节点（即没有左右子节点），检查当前路径的总和（包括当前节点）是否等于目标和。</li>
<li>如果当前节点不是叶子节点，递归检查其左子节点和右子节点，其中路径总和需要加上当前节点的值。</li>
</ol>
<p>通过递归地进行这样的判断，我们可以找到是否存在符合条件的路径。</p>
<h3 id="【实现代码】-8"><a href="#【实现代码】-8" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// TreeNode 定义二叉树节点</span></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hasPathSum 检查是否存在从根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasPathSum</span><span class="params">(root *TreeNode, targetSum <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 如果节点为空直接返回false</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是叶子节点，检查是否满足路径总和等于目标和</span></span><br><span class="line">    <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root.Val == targetSum</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归检查左子节点和右子节点，路径总和需要减去当前节点的值</span></span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root.Left, targetSum-root.Val) || hasPathSum(root.Right, targetSum-root.Val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113 路径总和 II"></a>113 路径总和 II</h2><h3 id="【题目描述】-9"><a href="#【题目描述】-9" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code>，找出所有从根节点到叶子节点路径总和等于给定目标和的路径。</p>
<p>叶子节点是指没有子节点的节点。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22</span><br><span class="line">输出：[[5,4,11,2],[5,8,4,5]]</span><br><span class="line">解释：有两条路径的和等于目标数 22:</span><br><span class="line">5 + 4 + 11 + 2 = 22</span><br><span class="line">5 + 8 + 4 + 5 = 22</span><br></pre></td></tr></table></figure>

<h3 id="【解题思路】-9"><a href="#【解题思路】-9" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题可以通过深度优先搜索（DFS）来解决。基本思路是遍历每一条从根节点到叶子节点的路径，并记录下来。如果路径上节点的值之和等于目标和，就将这条路径添加到结果列表中。</p>
<p>具体步骤如下：</p>
<ol>
<li>创建一个全局变量 <code>res</code> 用于存储所有符合条件的路径。</li>
<li>进行深度优先搜索，搜索过程中，维护一个当前路径的列表 <code>path</code> 和当前路径的和 <code>sum</code>。</li>
<li>遍历到一个节点时，将该节点的值加到 <code>sum</code> 上，并将该节点加入到 <code>path</code> 中。</li>
<li>如果当前节点是叶子节点且 <code>sum</code> 等于目标和，就将 <code>path</code> 复制一份加入到 <code>res</code> 中。</li>
<li>递归遍历左子节点和右子节点，每次递归前后，需要更新 <code>path</code> 和 <code>sum</code>。</li>
<li>遍历结束后，<code>res</code> 中就是所有满足条件的路径。</li>
</ol>
<h3 id="【实现代码】-9"><a href="#【实现代码】-9" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// TreeNode 定义二叉树节点</span></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pathSum</span><span class="params">(root *TreeNode, targetSum <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">	res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	path := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> backtrack <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode, targetSum <span class="type">int</span>)</span></span></span><br><span class="line">	backtrack = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode, targetSum <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &amp;&amp; root.Val == targetSum &#123;</span><br><span class="line">			path = <span class="built_in">append</span>(path, root.Val)</span><br><span class="line">			res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="type">int</span>(<span class="literal">nil</span>), path...))</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		path = <span class="built_in">append</span>(path, root.Val)</span><br><span class="line">		<span class="keyword">if</span> root.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">			backtrack(root.Left, targetSum-root.Val)</span><br><span class="line">			path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> root.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">			backtrack(root.Right, targetSum-root.Val)</span><br><span class="line">			path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	backtrack(root, targetSum)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106 从中序与后序遍历序列构造二叉树"></a>106 从中序与后序遍历序列构造二叉树</h2><h3 id="【题目描述】-10"><a href="#【题目描述】-10" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p>注意:<br>你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<p>中序遍历 inorder &#x3D; [9,3,15,20,7]<br>后序遍历 postorder &#x3D; [9,15,7,20,3]<br>返回如下的二叉树：</p>
<pre><code>3
</code></pre>
<p>   &#x2F; <br>  9  20<br>    &#x2F;  <br>   15   7</p>
<h3 id="【解题思路】-10"><a href="#【解题思路】-10" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这道题可以通过递归的方式来解决。我们知道，后序遍历的最后一个元素是根节点，而在中序遍历中，根节点的左侧是左子树，右侧是右子树。</p>
<p>我们可以先找到后序遍历的最后一个元素作为根节点，然后在中序遍历中找到根节点的位置，这样就可以确定左子树和右子树的节点数量。接下来，我们可以递归地构建左子树和右子树，直到所有节点都被处理完毕。</p>
<p>具体步骤如下：</p>
<ol>
<li>如果中序遍历或后序遍历为空，则返回 nil。</li>
<li>从后序遍历的最后一个元素取出根节点的值。</li>
<li>在中序遍历中找到根节点的位置，记为 rootIndex。</li>
<li>计算左子树的节点数量：leftSize &#x3D; rootIndex - inStart。</li>
<li>递归构建左子树：root.Left &#x3D; buildTree(inorder[inStart:rootIndex], postorder[postStart:postStart+leftSize])。</li>
<li>递归构建右子树：root.Right &#x3D; buildTree(inorder[rootIndex+1:inEnd], postorder[postStart+leftSize:postEnd-1])。</li>
<li>返回根节点 root。</li>
</ol>
<p>通过不断递归地构建左右子树，最终就可以还原出整棵二叉树。</p>
<h3 id="【实现代码】-10"><a href="#【实现代码】-10" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(inorder []<span class="type">int</span>, postorder []<span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">	<span class="comment">// inorder left,root,right</span></span><br><span class="line">	<span class="comment">// postorder left,right,root</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> traverse <span class="function"><span class="keyword">func</span><span class="params">(inorder []<span class="type">int</span>, postorder []<span class="type">int</span>)</span></span> *TreeNode</span><br><span class="line">	traverse = <span class="function"><span class="keyword">func</span><span class="params">(inorder []<span class="type">int</span>, postorder []<span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(inorder)&lt;=<span class="number">0</span> || <span class="built_in">len</span>(postorder) &lt;=<span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		root := &amp;TreeNode&#123;Val: postorder[<span class="built_in">len</span>(postorder)<span class="number">-1</span>]&#125;</span><br><span class="line">		rootIndex := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(inorder); i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> inorder[i] == root.Val &#123;</span><br><span class="line">				rootIndex = i</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		inorderleft := inorder[:rootIndex]</span><br><span class="line">		inorderright := inorder[rootIndex+<span class="number">1</span>:]</span><br><span class="line">		postorderleft := postorder[:<span class="built_in">len</span>(inorderleft)]</span><br><span class="line">		postorderright := postorder[<span class="built_in">len</span>(inorderleft):<span class="built_in">len</span>(postorder)<span class="number">-1</span>]</span><br><span class="line">		root.Left = traverse(inorderleft, postorderleft)</span><br><span class="line">		root.Right = traverse(inorderright, postorderright)</span><br><span class="line">		<span class="keyword">return</span> root</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> traverse(inorder, postorder)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654 最大二叉树"></a>654 最大二叉树</h2><h3 id="【题目描述】-11"><a href="#【题目描述】-11" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个不含重复元素的整数数组<code>nums</code>。一个以此数组直接递归构建的<strong>最大二叉树</strong>定义如下：</p>
<ul>
<li>二叉树的根是数组<code>nums</code>中的最大元素。</li>
<li>左子树是通过数组中最大值左边部分递归构造出的最大二叉树。</li>
<li>右子树是通过数组中最大值右边部分递归构造出的最大二叉树。</li>
</ul>
<p>返回由给定数组<code>nums</code>构建的最大二叉树。</p>
<h3 id="【解题思路】-11"><a href="#【解题思路】-11" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这道题的关键在于理解最大二叉树的构建过程。我们可以通过以下步骤来构建最大二叉树：</p>
<ol>
<li><strong>找到数组中的最大值</strong>，这个最大值将会成为当前二叉树的根节点。</li>
<li><strong>分割数组</strong>：将原数组分为两部分，最大值左边的数组用来构建左子树，最大值右边的数组用来构建右子树。</li>
<li><strong>递归构建</strong>：对左右两个子数组分别递归执行上述两个步骤，直到数组为空为止。</li>
</ol>
<p>使用递归的方式可以简洁地实现这个过程。</p>
<h3 id="【实现代码】-11"><a href="#【实现代码】-11" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val <span class="type">int</span></span><br><span class="line">    Left *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constructMaximumBinaryTree</span><span class="params">(nums []<span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">	<span class="keyword">var</span> traverser <span class="function"><span class="keyword">func</span><span class="params">(l, r <span class="type">int</span>)</span></span> *TreeNode</span><br><span class="line">	traverser = <span class="function"><span class="keyword">func</span><span class="params">(l, r <span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">		<span class="keyword">if</span> l &gt; r &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		maxPos := <span class="number">-1</span></span><br><span class="line">		maxValue := <span class="number">-1</span></span><br><span class="line">		<span class="keyword">for</span> i := l; i &lt;= r; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> nums[i] &gt; maxValue &#123;</span><br><span class="line">				maxValue = nums[i]</span><br><span class="line">				maxPos = i</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		root := &amp;TreeNode&#123;</span><br><span class="line">			Val: maxValue,</span><br><span class="line">		&#125;</span><br><span class="line">		root.Left = traverser(l, maxPos<span class="number">-1</span>)</span><br><span class="line">		root.Right = traverser(maxPos+<span class="number">1</span>, r)</span><br><span class="line">		<span class="keyword">return</span> root</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> traverser(<span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617 合并二叉树"></a>617 合并二叉树</h2><h3 id="【题目描述】-12"><a href="#【题目描述】-12" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。你需要将它们合并成一个新的二叉树。合并的规则是如果两个节点重叠，那么将这两个节点的值相加作为节点合并后的新值，否则不为<code>NULL</code>的节点将直接作为新二叉树的节点。</p>
<h3 id="【解题思路】-12"><a href="#【解题思路】-12" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>合并两棵二叉树的过程可以通过递归实现。对于任意一个节点，合并后的值为两个二叉树中对应节点的值之和。如果一个节点在一个树中存在而在另一个树中不存在，那么这个节点的值将直接成为新树的对应节点的值。</p>
<p>具体步骤如下：</p>
<ol>
<li>如果两个二叉树的当前节点都为空，则返回<code>nil</code>。</li>
<li>如果其中一个节点为空，另一个不为空，则返回非空节点。</li>
<li>如果两个节点都不为空，则将两个节点的值相加，并递归地合并两个节点的左子树和右子树。</li>
</ol>
<h3 id="【实现代码】-12"><a href="#【实现代码】-12" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dfs</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTrees</span><span class="params">(root1 *TreeNode, root2 *TreeNode)</span></span> *TreeNode &#123;</span><br><span class="line">	<span class="keyword">if</span> root1 == <span class="literal">nil</span> &amp;&amp; root2 == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> root1== <span class="literal">nil</span> &amp;&amp; root2!= <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> root2</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> root1!= <span class="literal">nil</span> &amp;&amp; root2== <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> root1</span><br><span class="line">	&#125;</span><br><span class="line">	root := &amp;TreeNode&#123;Val:root1.Val + root2.Val&#125;</span><br><span class="line">	root.Left = mergeTrees(root1.Left, root2.Left)</span><br><span class="line">	root.Right = mergeTrees(root1.Right, root2.Right)</span><br><span class="line">	<span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//bfs</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTrees</span><span class="params">(root1 *TreeNode, root2 *TreeNode)</span></span> *TreeNode &#123;</span><br><span class="line">	<span class="keyword">if</span> root1 == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> root2</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> root2 == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> root1</span><br><span class="line">	&#125;</span><br><span class="line">	queue := []*TreeNode&#123;root1, root2&#125;</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		left, right := queue[<span class="number">0</span>], queue[<span class="number">1</span>]</span><br><span class="line">		queue = queue[<span class="number">2</span>:]</span><br><span class="line">		left.Val = left.Val + right.Val</span><br><span class="line">		<span class="comment">//左子树都不为空 入队列</span></span><br><span class="line">		<span class="keyword">if</span> left.Left != <span class="literal">nil</span> &amp;&amp; right.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">			queue = <span class="built_in">append</span>(queue, left.Left, right.Left)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//右子树都不为空 入队列</span></span><br><span class="line">		<span class="keyword">if</span> left.Right != <span class="literal">nil</span> &amp;&amp; right.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">			queue = <span class="built_in">append</span>(queue, left.Right, right.Right)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//左右子树有一个为空，不需要入队列</span></span><br><span class="line">		<span class="keyword">if</span> left.Left == <span class="literal">nil</span> &amp;&amp; right.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">			left.Left = right.Left</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> left.Right == <span class="literal">nil</span> &amp;&amp; right.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">			left.Right = right.Right</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="700-二叉搜索树的查找"><a href="#700-二叉搜索树的查找" class="headerlink" title="700 二叉搜索树的查找"></a>700 二叉搜索树的查找</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchBST</span><span class="params">(root *TreeNode, val <span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> root.Val == val &#123;</span><br><span class="line">		<span class="keyword">return</span> root</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> root.Val &gt; val &#123;</span><br><span class="line">		<span class="keyword">return</span> searchBST(root.Left, val)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> searchBST(root.Right, val)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchBST</span><span class="params">(root *TreeNode, val <span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> root.Val == val &#123;</span><br><span class="line">			<span class="keyword">return</span> root</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> root.Val &gt; val &#123;</span><br><span class="line">			root = root.Left</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			root = root.Right</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98 验证二叉搜索树"></a>98 验证二叉搜索树</h2><h3 id="【题目描述】-13"><a href="#【题目描述】-13" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树（BST）。一个二叉搜索树具有如下特征：</p>
<ul>
<li>节点的左子树只包含小于当前节点的数。</li>
<li>节点的右子树只包含大于当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<h3 id="【解题思路】-13"><a href="#【解题思路】-13" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>验证二叉搜索树的有效性可以通过递归来完成。基本思路是，利用二叉搜索树的性质：对于任意节点，它的值必须大于其左子树中所有节点的最大值，同时小于其右子树中所有节点的最小值。这意味着，我们可以通过递归来检查每个节点，同时更新当前节点值所允许的最小值和最大值。</p>
<p>我们可以定义一个辅助函数来实现递归，该函数除了传递当前节点外，还需要传递当前值的允许最小值和最大值。在递归过程中，我们根据当前节点是左节点还是右节点，更新这个范围，并检查当前节点的值是否在这个范围内。</p>
<h3 id="【实现代码】-13"><a href="#【实现代码】-13" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidBST</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> validate(root, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// validate 函数接收当前节点以及这个节点值允许的最小值和最大值</span></span><br><span class="line"><span class="comment">//dfs</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validate</span><span class="params">(node *TreeNode, min *<span class="type">int</span>, max *<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 如果节点为空，说明满足BST的条件</span></span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果节点值不在允许的范围内，返回false</span></span><br><span class="line">    <span class="keyword">if</span> (min != <span class="literal">nil</span> &amp;&amp; node.Val &lt;= *min) || (max != <span class="literal">nil</span> &amp;&amp; node.Val &gt;= *max) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归检查左子树，更新最大值为当前节点值，因为左子树的所有值都应该小于当前节点值</span></span><br><span class="line">    <span class="comment">// 递归检查右子树，更新最小值为当前节点值，因为右子树的所有值都应该大于当前节点值</span></span><br><span class="line">    <span class="keyword">return</span> validate(node.Left, min, &amp;node.Val) &amp;&amp; validate(node.Right, &amp;node.Val, max)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidBST</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="comment">// 中序遍历 左根右</span></span><br><span class="line">	stack := []*TreeNode&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> cur, prev *TreeNode = root, <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt;<span class="number">0</span>  || cur != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">			stack = <span class="built_in">append</span>(stack, cur)</span><br><span class="line">			cur = cur.Left</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			cur = stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] </span><br><span class="line">			stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">			<span class="keyword">if</span> prev != <span class="literal">nil</span> &amp;&amp;  prev.Val &gt;= cur.Val &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">			prev  =cur</span><br><span class="line">			cur = cur.Right</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="530-最小绝对差值"><a href="#530-最小绝对差值" class="headerlink" title="530 最小绝对差值"></a>530 最小绝对差值</h2><h3 id="【题目描述】-14"><a href="#【题目描述】-14" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个二叉搜索树的根节点 <code>root</code>，返回树中任意两不同节点值之间的最小差值。差值是一个正数，其计算方式为 <code>|a-b|</code> 其中 <code>a</code> 和 <code>b</code> 是两个数。</p>
<h3 id="【解题思路】-14"><a href="#【解题思路】-14" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>二叉搜索树（BST）的一个性质是：对于树上的任意节点 <code>N</code>，其左子树中的所有节点的值都小于 <code>N</code>，右子树的所有节点的值都大于 <code>N</code>。利用这个性质，我们可以中序遍历整个树。在中序遍历过程中，树中的节点值会按照升序的方式被访问。因此，我们只需要比较相邻两节点的值，就能找到树中任意两不同节点值之间的最小差值。</p>
<p>具体步骤如下：</p>
<ol>
<li>进行中序遍历，过程中记录前一个节点的值。</li>
<li>对于当前节点，计算它与前一个节点的差值，更新最小差值。</li>
<li>继续遍历，直到遍历完整棵树。</li>
</ol>
<h3 id="【实现代码】-14"><a href="#【实现代码】-14" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMinimumDifference</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    minDiff := math.MaxInt <span class="comment">// 初始化最小差值为最大值</span></span><br><span class="line">    <span class="keyword">var</span> prev *TreeNode            <span class="comment">// 用于记录前一个节点</span></span><br><span class="line">    <span class="keyword">var</span> traverse <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode)</span></span>  <span class="comment">// 声明中序遍历函数</span></span><br><span class="line"></span><br><span class="line">    traverse = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        traverse(node.Left) <span class="comment">// 递归遍历左子树</span></span><br><span class="line">        <span class="keyword">if</span> prev != <span class="literal">nil</span> &amp;&amp; node.Val-prev.Val &lt; minDiff &#123;</span><br><span class="line">            minDiff = node.Val - prev.Val <span class="comment">// 更新最小差值</span></span><br><span class="line">        &#125;</span><br><span class="line">        prev = node <span class="comment">// 更新前一个节点</span></span><br><span class="line">        traverse(node.Right) <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    traverse(root) <span class="comment">// 开始中序遍历</span></span><br><span class="line">    <span class="keyword">return</span> minDiff <span class="comment">// 返回最小差值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMinimumDifference</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	queue := []*TreeNode&#123;&#125;</span><br><span class="line">	cur := root </span><br><span class="line">	<span class="keyword">var</span> prev  *TreeNode</span><br><span class="line">	minDiff := math.MaxInt</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt;<span class="number">0</span> || cur != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">			queue = <span class="built_in">append</span>(queue, cur)</span><br><span class="line">			cur = cur.Left</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			cur = queue[<span class="built_in">len</span>(queue)<span class="number">-1</span>]</span><br><span class="line">			queue =queue[:<span class="built_in">len</span>(queue)<span class="number">-1</span>]</span><br><span class="line">			<span class="keyword">if</span> prev != <span class="literal">nil</span> &#123;</span><br><span class="line">				minDiff = min(minDiff, cur.Val-prev.Val)</span><br><span class="line">			&#125;</span><br><span class="line">			prev = cur</span><br><span class="line">			cur = cur.Right</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> minDiff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501 二叉搜索树中的众数"></a>501 二叉搜索树中的众数</h2><h3 id="【题目描述】-15"><a href="#【题目描述】-15" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</p>
<p><strong>假定 BST 有如下定义：</strong></p>
<ul>
<li>结构上，左子树的所有元素都小于根节点，右子树的所有元素都大于根节点。</li>
<li>左子树和右子树也都是二叉搜索树。</li>
</ul>
<h3 id="【解题思路】-15"><a href="#【解题思路】-15" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>由于是二叉搜索树，我们可以利用它的性质——中序遍历二叉搜索树会得到一个升序的序列。在这个过程中，我们可以记录当前元素的出现次数，并与之前记录的最大出现次数进行比较，从而找到众数。</p>
<p>具体步骤如下：</p>
<ol>
<li>初始化三个变量，<code>currentCount</code>（当前元素计数）、<code>maxCount</code>（最大出现次数）和<code>prevElement</code>（前一个元素）用于在遍历过程中进行比较。</li>
<li>进行中序遍历，在遍历过程中更新这些变量，并记录当前出现次数最多的元素。</li>
<li>如果当前元素计数大于最大计数，则清空结果列表，并将当前元素添加进去；如果当前元素计数等于最大计数，则将当前元素也添加到结果列表中。</li>
<li>遍历完成后，返回结果列表。</li>
</ol>
<h3 id="【实现代码】-15"><a href="#【实现代码】-15" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMode</span><span class="params">(root *TreeNode)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	res := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> prev *TreeNode</span><br><span class="line">	<span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span></span><br><span class="line">	<span class="keyword">var</span> count, maxCount <span class="type">int</span></span><br><span class="line">	dfs = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		dfs(root.Left)</span><br><span class="line">		<span class="keyword">if</span> prev != <span class="literal">nil</span> &amp;&amp; prev.Val == root.Val &#123;</span><br><span class="line">			count++</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			count = <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果当前元素比最大的还大，则直接清空</span></span><br><span class="line">		<span class="keyword">if</span> count &gt; maxCount &#123;</span><br><span class="line">			res = []<span class="type">int</span>&#123;root.Val&#125;</span><br><span class="line">			maxCount = count</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> count == maxCount &#123;</span><br><span class="line">			res = <span class="built_in">append</span>(res, root.Val)</span><br><span class="line">		&#125;</span><br><span class="line">		prev = root</span><br><span class="line"></span><br><span class="line">		dfs(root.Right)</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(root)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236 二叉树的最近公共祖先"></a>236 二叉树的最近公共祖先</h2><h3 id="【题目描述】-16"><a href="#【题目描述】-16" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先（LCA，Lowest Common Ancestor）。最近公共祖先的定义为：对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。</p>
<h3 id="【解题思路】-16"><a href="#【解题思路】-16" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题可以通过递归来解决。对于每个节点来说，如果当前节点就是 p、q 中的一个，或者在它的左右子树中分别找到了 p 和 q，那么这个节点就是 p 和 q 的最近公共祖先。</p>
<ol>
<li><strong>递归终止条件</strong>：如果当前节点为空或者等于 p 或 q，则返回当前节点。</li>
<li><strong>递归左子树和右子树</strong>：分别在左右子树中递归查找 p 和 q，如果在一个子树中找到了 p 或 q，则返回那个节点。</li>
<li><strong>分情况讨论</strong>：<ul>
<li>如果 p 和 q 分别位于当前节点的两侧，即一个在左子树，一个在右子树，那么当前节点就是它们的最近公共祖先。</li>
<li>如果 p 和 q 都在左子树，那么返回左子树的递归结果。</li>
<li>如果 p 和 q 都在右子树，那么返回右子树的递归结果。</li>
<li>如果 p 和 q 中只有一个存在于当前子树中，则只返回那个节点。</li>
</ul>
</li>
</ol>
<p>通过这样的递归逻辑，最终能够找到 p 和 q 的最近公共祖先。<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/202102041512582.png"></p>
<h3 id="【实现代码】-16"><a href="#【实现代码】-16" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> || root == p || root == q &#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    left := lowestCommonAncestor(root.Left, p, q)</span><br><span class="line">    right := lowestCommonAncestor(root.Right, p, q)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//left, right != nil说明找到了</span></span><br><span class="line">    <span class="comment">// 如果左子树找到了p或q，右子树找到了q或p，则说明当前root就是LCA</span></span><br><span class="line">    <span class="keyword">if</span> left != <span class="literal">nil</span> &amp;&amp; right != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果左子树为空，说明p和q都不在左子树中，返回右子树的查找结果</span></span><br><span class="line">    <span class="keyword">if</span> left == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同理，如果右子树为空，返回左子树的查找结果</span></span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a>235. 二叉搜索树的最近公共祖先</h2><h3 id="【题目描述】-17"><a href="#【题目描述】-17" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>
<p>例如，给定如下二叉搜索树: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5]</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    6</span><br><span class="line">   / \</span><br><span class="line">  2   8</span><br><span class="line"> / \ / \</span><br><span class="line">0  4 7  9</span><br><span class="line">   / \</span><br><span class="line">  3   5</span><br></pre></td></tr></table></figure>
<p><strong>示例 1:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</span><br><span class="line">输出: 2</span><br><span class="line">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li>
</ul>
<h3 id="【解题思路】-17"><a href="#【解题思路】-17" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>由于题目给的是二叉搜索树，我们可以利用二叉搜索树的特性：左子树的所有节点的值都小于根节点的值，右子树的所有节点的值都大于根节点的值。根据这个特性，我们可以从根节点开始遍历，如果p和q的值都大于根节点的值，那么它们的最近公共祖先一定在右子树中，我们可以递归地在右子树中寻找。如果p和q的值都小于根节点的值，那么它们的最近公共祖先一定在左子树中，我们同样可以递归地在左子树中寻找。如果p和q的值一个大于根节点的值，一个小于根节点的值，那么根节点就是它们的最近公共祖先。</p>
<h3 id="【实现代码】-17"><a href="#【实现代码】-17" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// TreeNode 定义二叉树节点</span></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line"> Val   <span class="type">int</span></span><br><span class="line"> Left  *TreeNode</span><br><span class="line"> Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> || root == p || root == q &#123;</span><br><span class="line">		<span class="keyword">return</span> root</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> root.Val &gt; p.Val &amp;&amp; root.Val &gt; q.Val &#123;</span><br><span class="line">		<span class="keyword">return</span> lowestCommonAncestor(root.Left ,p, q)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> root.Val &lt; p.Val &amp;&amp; root.Val &lt; q.Val &#123;</span><br><span class="line">		<span class="keyword">return</span> lowestCommonAncestor(root.Right ,p, q)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a>701. 二叉搜索树中的插入操作</h2><h3 id="【题目描述】-18"><a href="#【题目描述】-18" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。</p>
<p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。</p>
<p>例如,</p>
<p>给定的树:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    4</span><br><span class="line">   / \</span><br><span class="line">  2   7</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure>
<p>和 插入的值: 5</p>
<p>你可以返回这个二叉搜索树:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    4</span><br><span class="line">   / \</span><br><span class="line">  2   7</span><br><span class="line"> / \   \</span><br><span class="line">1   3   5</span><br></pre></td></tr></table></figure>
<p>或者这个树也是有效的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  2   7</span><br><span class="line"> / \   </span><br><span class="line">1   3</span><br><span class="line">     \</span><br><span class="line">      4</span><br></pre></td></tr></table></figure>
<h3 id="【解题思路】-18"><a href="#【解题思路】-18" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>插入操作在二叉搜索树中相对简单，因为二叉搜索树的特性就是左子树的所有节点的值都小于根节点的值，右子树的所有节点的值都大于根节点的值。</p>
<p>所以，我们可以从根节点开始，比较要插入的值和当前节点的值。如果要插入的值小于当前节点的值，我们就将其插入到当前节点的左子树中；如果要插入的值大于当前节点的值，我们就将其插入到当前节点的右子树中。如果当前节点为空，那么要插入的值就应该成为新的节点。</p>
<p>这个过程可以通过递归来实现。</p>
<h3 id="【实现代码】-18"><a href="#【实现代码】-18" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line"> Val   <span class="type">int</span></span><br><span class="line"> Left  *TreeNode</span><br><span class="line"> Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertIntoBST</span><span class="params">(root *TreeNode, val <span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;TreeNode&#123;</span><br><span class="line">			Val: val,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> root.Val &gt; val &#123;</span><br><span class="line">		root.Left = insertIntoBST(root.Left, val)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		root.Right = insertIntoBST(root.Right, val)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450 删除二叉搜索树中的节点"></a>450 删除二叉搜索树中的节点</h2><h3 id="【题目描述】-19"><a href="#【题目描述】-19" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>
<p>一般来说，删除节点可分为两个步骤:</p>
<ol>
<li>找到要删除的节点</li>
<li>删除该节点</li>
</ol>
<h3 id="【解题思路】-19"><a href="#【解题思路】-19" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>首先我们需要在树中找到要删除的节点。如果该节点没有子节点，那么我们只需要直接将它删除。如果该节点只有一个子节点，那么我们只需要用该子节点来替换被删除的节点。如果该节点有两个子节点，那么我们需要找到该节点的后继节点（该节点右子树中最小的节点），用该后继节点的值替换被删除节点的值，然后再递归删除该后继节点。</p>
<h3 id="【实现代码】-19"><a href="#【实现代码】-19" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteNode</span><span class="params">(root *TreeNode, key <span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> root</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> root.Val == key &#123;</span><br><span class="line">		<span class="keyword">if</span> root.Left == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> root.Right</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> root.Left</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//左右都不为空，则将左子树挂载右字数的最左节点</span></span><br><span class="line">		rightLeft:= root.Right</span><br><span class="line">		<span class="keyword">for</span> rightLeft.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">			rightLeft = rightLeft.Left</span><br><span class="line">		&#125;</span><br><span class="line">		rightLeft.Left = root.Left</span><br><span class="line">		<span class="keyword">return</span> root.Right</span><br><span class="line">	&#125; </span><br><span class="line">	root.Left = deleteNode(root.Left, key)</span><br><span class="line">	root.Right = deleteNode(root.Right, key)</span><br><span class="line">	<span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669 修剪二叉搜索树"></a>669 修剪二叉搜索树</h2><h3 id="【题目描述】-20"><a href="#【题目描述】-20" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在 [low, high] 中。修剪树不应该改变保留在树中的元素的相对结构（即，如果没有被移除，原有的父代子代关系都应当保留）。可以证明，存在唯一的答案。</p>
<p>返回修剪后的二叉搜索树的新的根节点。注意，根节点可能会被更改。</p>
<h3 id="【解题思路】-20"><a href="#【解题思路】-20" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>我们可以使用递归的方式遍历二叉搜索树，对每个节点进行判断。如果当前节点的值小于最小边界low，那么我们需要修剪掉该节点的左子树，递归处理右子树。如果当前节点的值大于最大边界high，那么我们需要修剪掉该节点的右子树，递归处理左子树。如果当前节点的值在 [low, high] 范围内，我们就保留该节点，并递归处理它的左右子树。</p>
<h3 id="【实现代码】-20"><a href="#【实现代码】-20" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trimBST</span><span class="params">(root *TreeNode, low <span class="type">int</span>, high <span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> root.Val &lt; low &#123;</span><br><span class="line">        <span class="comment">// 当前节点值小于最小边界，修剪掉左子树</span></span><br><span class="line">        <span class="keyword">return</span> trimBST(root.Right, low, high)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> root.Val &gt; high &#123;</span><br><span class="line">        <span class="comment">// 当前节点值大于最大边界，修剪掉右子树</span></span><br><span class="line">        <span class="keyword">return</span> trimBST(root.Left, low, high)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前节点值在范围内，保留该节点</span></span><br><span class="line">        root.Left = trimBST(root.Left, low, high)</span><br><span class="line">        root.Right = trimBST(root.Right, low, high)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108 将有序数组转换为二叉搜索树"></a>108 将有序数组转换为二叉搜索树</h2><h3 id="【题目描述】-21"><a href="#【题目描述】-21" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>将一个按照升序排列的有序数组转换为一棵高度平衡的二叉搜索树。高度平衡二叉树是指一个二叉树每个节点的左右两个子树的高度差的绝对值不超过 1。</p>
<h3 id="【解题思路】-21"><a href="#【解题思路】-21" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题的关键在于如何构建一个高度平衡的二叉搜索树。由于数组是有序的，我们可以利用这一点，每次选择中间的元素作为根节点，这样可以保证树的平衡。具体步骤如下：</p>
<ol>
<li><strong>找到中间元素</strong>：首先找到数组的中间元素，将其作为树的根节点。如果数组长度是偶数，可以选择中间两个元素中的任意一个。</li>
<li><strong>递归构建子树</strong>：然后将中间元素左边的数组作为左子树，右边的数组作为右子树，递归这一过程。</li>
<li><strong>递归终止条件</strong>：当数组为空时，递归结束。</li>
</ol>
<p>通过这种方式，我们可以确保每次都是从数组的中间分割，这样构建出的二叉搜索树自然是高度平衡的。</p>
<h3 id="【实现代码】-21"><a href="#【实现代码】-21" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortedArrayToBST</span><span class="params">(nums []<span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> constructBST(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constructBST</span><span class="params">(nums []<span class="type">int</span>, left, right <span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">    <span class="keyword">if</span> left &gt; right &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    mid := left + (right-left)/<span class="number">2</span> <span class="comment">// 避免溢出</span></span><br><span class="line">    root := &amp;TreeNode&#123;Val: nums[mid]&#125;</span><br><span class="line">    root.Left = constructBST(nums, left, mid<span class="number">-1</span>)</span><br><span class="line">    root.Right = constructBST(nums, mid+<span class="number">1</span>, right)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538 把二叉搜索树转换为累加树"></a>538 把二叉搜索树转换为累加树</h2><h3 id="【题目描述】-22"><a href="#【题目描述】-22" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给出二叉搜索树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p>
<h3 id="【解题思路】-22"><a href="#【解题思路】-22" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题的关键在于理解如何递归遍历二叉搜索树（BST），以及如何累加节点值。由于BST的性质是左子树的值小于根节点的值，右子树的值大于根节点的值，我们可以利用这一点进行逆中序遍历（即先右后左的中序遍历）。通过这种遍历方式，我们可以从最大的节点值开始，逐步累加，然后更新每个节点的值。</p>
<p>具体步骤如下：</p>
<ol>
<li><strong>递归遍历右子树</strong>：首先递归地遍历右子树，这样可以从最大的节点值开始。</li>
<li><strong>更新节点值</strong>：遍历到一个节点时，用一个累加变量（sum）来记录当前已经遍历过的节点值的总和。将当前节点的值加到这个累加变量上，然后将累加变量的值赋给当前节点。</li>
<li><strong>递归遍历左子树</strong>：完成右子树和当前节点的处理后，递归地遍历左子树。</li>
<li><strong>递归结束条件</strong>：如果节点为空，则返回。</li>
</ol>
<p>通过这种方式，我们可以确保每个节点被更新为原树中大于或等于该节点值的值之和。</p>
<h3 id="【实现代码】-22"><a href="#【实现代码】-22" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convertBST</span><span class="params">(root *TreeNode)</span></span> *TreeNode &#123;</span><br><span class="line">	<span class="comment">//右根左</span></span><br><span class="line">	<span class="keyword">var</span> prev *TreeNode</span><br><span class="line">	<span class="keyword">var</span> traverse <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span></span><br><span class="line">	traverse = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		traverse(root.Right)</span><br><span class="line">		<span class="keyword">if</span> prev != <span class="literal">nil</span> &#123;</span><br><span class="line">			root.Val += prev.Val</span><br><span class="line">		&#125;</span><br><span class="line">		prev = root</span><br><span class="line">		traverse(root.Left)</span><br><span class="line">	&#125;</span><br><span class="line">	traverse(root)</span><br><span class="line">	<span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/tags/">Tag</a></li>
        
          <li><a href="/search">Search</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/jonasrepo.github.io">Projects</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">核心知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">遍历方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86"><span class="toc-number">1.1.1.</span> <span class="toc-text">递归遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86"><span class="toc-number">1.1.2.</span> <span class="toc-text">迭代遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">前序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">中序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">后序遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.1.3.</span> <span class="toc-text">层序遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.2.</span> <span class="toc-text">二叉搜索树</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE"><span class="toc-number">2.</span> <span class="toc-text">相关题目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-number">2.1.</span> <span class="toc-text">104 二叉树的最大深度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91"><span class="toc-number">2.1.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91"><span class="toc-number">2.1.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91"><span class="toc-number">2.1.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6"><span class="toc-number">2.2.</span> <span class="toc-text">111 二叉树的最小深度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-1"><span class="toc-number">2.2.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-1"><span class="toc-number">2.2.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-1"><span class="toc-number">2.2.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.3.</span> <span class="toc-text">226 翻转二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-2"><span class="toc-number">2.3.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-2"><span class="toc-number">2.3.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-2"><span class="toc-number">2.3.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.4.</span> <span class="toc-text">101 对称二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-3"><span class="toc-number">2.4.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-3"><span class="toc-number">2.4.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-3"><span class="toc-number">2.4.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.5.</span> <span class="toc-text">110 平衡二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-4"><span class="toc-number">2.5.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-4"><span class="toc-number">2.5.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-4"><span class="toc-number">2.5.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84"><span class="toc-number">2.6.</span> <span class="toc-text">257 二叉树的所有路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-5"><span class="toc-number">2.6.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-5"><span class="toc-number">2.6.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-5"><span class="toc-number">2.6.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#404-%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C"><span class="toc-number">2.7.</span> <span class="toc-text">404 左叶子之和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-6"><span class="toc-number">2.7.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-6"><span class="toc-number">2.7.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-6"><span class="toc-number">2.7.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#513-%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC"><span class="toc-number">2.8.</span> <span class="toc-text">513 找树左下角的值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-7"><span class="toc-number">2.8.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-7"><span class="toc-number">2.8.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-7"><span class="toc-number">2.8.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C"><span class="toc-number">2.9.</span> <span class="toc-text">112 路径总和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-8"><span class="toc-number">2.9.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-8"><span class="toc-number">2.9.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-8"><span class="toc-number">2.9.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-II"><span class="toc-number">2.10.</span> <span class="toc-text">113 路径总和 II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-9"><span class="toc-number">2.10.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-9"><span class="toc-number">2.10.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-9"><span class="toc-number">2.10.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.11.</span> <span class="toc-text">106 从中序与后序遍历序列构造二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-10"><span class="toc-number">2.11.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-10"><span class="toc-number">2.11.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-10"><span class="toc-number">2.11.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.12.</span> <span class="toc-text">654 最大二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-11"><span class="toc-number">2.12.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-11"><span class="toc-number">2.12.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-11"><span class="toc-number">2.12.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.13.</span> <span class="toc-text">617 合并二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-12"><span class="toc-number">2.13.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-12"><span class="toc-number">2.13.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-12"><span class="toc-number">2.13.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">2.14.</span> <span class="toc-text">700 二叉搜索树的查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">2.15.</span> <span class="toc-text">98 验证二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-13"><span class="toc-number">2.15.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-13"><span class="toc-number">2.15.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-13"><span class="toc-number">2.15.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#530-%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE%E5%80%BC"><span class="toc-number">2.16.</span> <span class="toc-text">530 最小绝对差值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-14"><span class="toc-number">2.16.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-14"><span class="toc-number">2.16.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-14"><span class="toc-number">2.16.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#501-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0"><span class="toc-number">2.17.</span> <span class="toc-text">501 二叉搜索树中的众数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-15"><span class="toc-number">2.17.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-15"><span class="toc-number">2.17.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-15"><span class="toc-number">2.17.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">2.18.</span> <span class="toc-text">236 二叉树的最近公共祖先</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-16"><span class="toc-number">2.18.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-16"><span class="toc-number">2.18.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-16"><span class="toc-number">2.18.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#235-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">2.19.</span> <span class="toc-text">235. 二叉搜索树的最近公共祖先</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-17"><span class="toc-number">2.19.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-17"><span class="toc-number">2.19.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-17"><span class="toc-number">2.19.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#701-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">2.20.</span> <span class="toc-text">701. 二叉搜索树中的插入操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-18"><span class="toc-number">2.20.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-18"><span class="toc-number">2.20.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-18"><span class="toc-number">2.20.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">2.21.</span> <span class="toc-text">450 删除二叉搜索树中的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-19"><span class="toc-number">2.21.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-19"><span class="toc-number">2.21.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-19"><span class="toc-number">2.21.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#669-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">2.22.</span> <span class="toc-text">669 修剪二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-20"><span class="toc-number">2.22.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-20"><span class="toc-number">2.22.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-20"><span class="toc-number">2.22.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">2.23.</span> <span class="toc-text">108 将有序数组转换为二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-21"><span class="toc-number">2.23.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-21"><span class="toc-number">2.23.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-21"><span class="toc-number">2.23.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#538-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91"><span class="toc-number">2.24.</span> <span class="toc-text">538 把二叉搜索树转换为累加树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-22"><span class="toc-number">2.24.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-22"><span class="toc-number">2.24.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-22"><span class="toc-number">2.24.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://localhost:4000/2024/03/28/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://localhost:4000/2024/03/28/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/&text=二叉树"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://localhost:4000/2024/03/28/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/&title=二叉树"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://localhost:4000/2024/03/28/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/&is_video=false&description=二叉树"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=二叉树&body=Check out this article: http://localhost:4000/2024/03/28/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://localhost:4000/2024/03/28/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/&title=二叉树"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://localhost:4000/2024/03/28/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/&title=二叉树"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://localhost:4000/2024/03/28/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/&title=二叉树"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://localhost:4000/2024/03/28/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/&title=二叉树"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://localhost:4000/2024/03/28/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/&name=二叉树&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://localhost:4000/2024/03/28/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/&t=二叉树"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2024
    jonas
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a href="/search">Search</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/jonasrepo.github.io">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
