<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="核心 从局部最优推全局最优，通常需要回溯配合对已做的选择做撤销 能解决的问题 135. Candy 【题目描述】 N个小孩排成一排，每个小孩有一个评级值ratings[i]。每个小孩至少要得到一颗糖果。  评分更高的孩子比邻近的评分较低的孩子获得更多的糖果。 评分相同的孩子获得相同数量的糖果。  示例： 123456输入：ratings &#x3D; [1,0,2]输出：5解释：- 孩子 1 的评分比左右的">
<meta property="og:type" content="article">
<meta property="og:title" content="贪心">
<meta property="og:url" content="http://localhost:4000/2024/03/08/leetcode/%E8%B4%AA%E5%BF%83/index.html">
<meta property="og:site_name" content="Jonas">
<meta property="og:description" content="核心 从局部最优推全局最优，通常需要回溯配合对已做的选择做撤销 能解决的问题 135. Candy 【题目描述】 N个小孩排成一排，每个小孩有一个评级值ratings[i]。每个小孩至少要得到一颗糖果。  评分更高的孩子比邻近的评分较低的孩子获得更多的糖果。 评分相同的孩子获得相同数量的糖果。  示例： 123456输入：ratings &#x3D; [1,0,2]输出：5解释：- 孩子 1 的评分比左右的">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-03-08T06:46:41.192Z">
<meta property="article:modified_time" content="2024-04-10T01:34:31.512Z">
<meta property="article:author" content="jonas">
<meta property="article:tag" content="leetcode">
<meta property="article:tag" content="贪心">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>贪心</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<meta name="generator" content="Hexo 7.1.1"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/categories/">Category</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a href="/search">Search</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/jonasrepo.github.io">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2024/03/11/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2024/03/08/leetcode/0%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84%E6%8A%80%E5%B7%A7/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://localhost:4000/2024/03/08/leetcode/%E8%B4%AA%E5%BF%83/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://localhost:4000/2024/03/08/leetcode/%E8%B4%AA%E5%BF%83/&text=贪心"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://localhost:4000/2024/03/08/leetcode/%E8%B4%AA%E5%BF%83/&title=贪心"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://localhost:4000/2024/03/08/leetcode/%E8%B4%AA%E5%BF%83/&is_video=false&description=贪心"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=贪心&body=Check out this article: http://localhost:4000/2024/03/08/leetcode/%E8%B4%AA%E5%BF%83/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://localhost:4000/2024/03/08/leetcode/%E8%B4%AA%E5%BF%83/&title=贪心"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://localhost:4000/2024/03/08/leetcode/%E8%B4%AA%E5%BF%83/&title=贪心"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://localhost:4000/2024/03/08/leetcode/%E8%B4%AA%E5%BF%83/&title=贪心"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://localhost:4000/2024/03/08/leetcode/%E8%B4%AA%E5%BF%83/&title=贪心"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://localhost:4000/2024/03/08/leetcode/%E8%B4%AA%E5%BF%83/&name=贪心&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://localhost:4000/2024/03/08/leetcode/%E8%B4%AA%E5%BF%83/&t=贪心"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">核心</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">能解决的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#135-Candy"><span class="toc-number">2.1.</span> <span class="toc-text">135. Candy</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91"><span class="toc-number">2.1.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91"><span class="toc-number">2.1.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91"><span class="toc-number">2.1.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#134-%E5%8A%A0%E6%B2%B9%E7%AB%99"><span class="toc-number">2.2.</span> <span class="toc-text">134. 加油站</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-2"><span class="toc-number">2.2.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-2"><span class="toc-number">2.2.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-2"><span class="toc-number">2.2.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1005-K-%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-number">2.3.</span> <span class="toc-text">1005. K 次取反后最大化的数组和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-3"><span class="toc-number">2.3.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-3"><span class="toc-number">2.3.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-3"><span class="toc-number">2.3.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45-Jump-Game-II"><span class="toc-number">2.4.</span> <span class="toc-text">45 Jump Game II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-4"><span class="toc-number">2.4.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-4"><span class="toc-number">2.4.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-4"><span class="toc-number">2.4.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55-Jump-Game"><span class="toc-number">2.5.</span> <span class="toc-text">55 Jump Game</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-5"><span class="toc-number">2.5.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-5"><span class="toc-number">2.5.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-5"><span class="toc-number">2.5.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#122-Best-Time-to-Buy-and-Sell-Stock-II"><span class="toc-number">2.6.</span> <span class="toc-text">122 Best Time to Buy and Sell Stock II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-6"><span class="toc-number">2.6.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-6"><span class="toc-number">2.6.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-6"><span class="toc-number">2.6.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-Maximum-Subarray"><span class="toc-number">2.7.</span> <span class="toc-text">53 Maximum Subarray</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-7"><span class="toc-number">2.7.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-7"><span class="toc-number">2.7.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-7"><span class="toc-number">2.7.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97"><span class="toc-number">2.8.</span> <span class="toc-text">376 摆动序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-8"><span class="toc-number">2.8.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-8"><span class="toc-number">2.8.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-8"><span class="toc-number">2.8.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2"><span class="toc-number">2.9.</span> <span class="toc-text">455 分发饼干</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-9"><span class="toc-number">2.9.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-9"><span class="toc-number">2.9.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-9"><span class="toc-number">2.9.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6"><span class="toc-number">2.10.</span> <span class="toc-text">860 柠檬水找零</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-10"><span class="toc-number">2.10.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-10"><span class="toc-number">2.10.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-10"><span class="toc-number">2.10.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#406-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97"><span class="toc-number">2.11.</span> <span class="toc-text">406 根据身高重建队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-11"><span class="toc-number">2.11.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-11"><span class="toc-number">2.11.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-11"><span class="toc-number">2.11.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#452-%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83"><span class="toc-number">2.12.</span> <span class="toc-text">452 用最少数量的箭引爆气球</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-12"><span class="toc-number">2.12.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-12"><span class="toc-number">2.12.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-12"><span class="toc-number">2.12.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4"><span class="toc-number">2.13.</span> <span class="toc-text">435 无重叠区间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-13"><span class="toc-number">2.13.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-13"><span class="toc-number">2.13.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-13"><span class="toc-number">2.13.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4"><span class="toc-number">2.14.</span> <span class="toc-text">763 划分字母区间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C"><span class="toc-number">2.15.</span> <span class="toc-text">53 最大子序和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-14"><span class="toc-number">2.15.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-14"><span class="toc-number">2.15.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-14"><span class="toc-number">2.15.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#738-%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">2.16.</span> <span class="toc-text">738. 单调递增的数字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-15"><span class="toc-number">2.16.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-15"><span class="toc-number">2.16.2.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#968-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.17.</span> <span class="toc-text">968 监控二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-16"><span class="toc-number">2.17.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-15"><span class="toc-number">2.17.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-16"><span class="toc-number">2.17.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        贪心
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">jonas</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-03-08T06:46:41.192Z" class="dt-published" itemprop="datePublished">2024-03-08</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/leetcode/">leetcode</a>
    </div>


      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/leetcode/" rel="tag">leetcode</a>, <a class="p-category" href="/tags/%E8%B4%AA%E5%BF%83/" rel="tag">贪心</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1>核心</h1>
<p>从局部最优推全局最优，通常需要回溯配合对已做的选择做撤销</p>
<h1>能解决的问题</h1>
<h2 id="135-Candy">135. Candy</h2>
<h3 id="【题目描述】">【题目描述】</h3>
<p>N个小孩排成一排，每个小孩有一个评级值ratings[i]。每个小孩至少要得到一颗糖果。</p>
<ul>
<li>评分更高的孩子比邻近的评分较低的孩子获得更多的糖果。</li>
<li>评分相同的孩子获得相同数量的糖果。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：ratings = [1,0,2]</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">- 孩子 1 的评分比左右的评分低，所以获得 1 颗糖果。</span><br><span class="line">- 孩子 0 的评分比左右的评分低，所以获得 1 颗糖果。</span><br><span class="line">- 孩子 2 的评分比左边的评分高，所以获得 2 颗糖果。</span><br></pre></td></tr></table></figure>
<h3 id="【解题思路】">【解题思路】</h3>
<p><strong>贪心算法</strong></p>
<ol>
<li>首先，每个孩子至少要得到一颗糖果，所以我们可以初始化一个数组 <code>candies</code>，每个元素都为 1。</li>
<li>然后，从左到右遍历数组 <code>ratings</code>：
<ul>
<li>如果当前孩子的评分比左边的孩子高，则当前孩子获得的糖果数为 <code>candies[i] = candies[i - 1] + 1</code>。</li>
<li>否则，当前孩子获得的糖果数为 <code>candies[i] = 1</code>。</li>
</ul>
</li>
<li>再从右到左遍历数组 <code>ratings</code>：
<ul>
<li>如果当前孩子的评分比右边的孩子高，并且当前孩子获得的糖果数比右边孩子少，则更新当前孩子获得的糖果数为 <code>candies[i] = max(candies[i], candies[i + 1] + 1)</code>。</li>
</ul>
</li>
<li>最后，所有孩子获得的糖果总数为 <code>sum(candies)</code>。</li>
</ol>
<p><strong>改进的贪心算法</strong></p>
<ul>
<li>我们可以将步骤 2 和步骤 3 合并为一个步骤，从左到右遍历数组 <code>ratings</code>：
<ul>
<li>如果当前孩子的评分比左边的孩子高，则当前孩子获得的糖果数为 <code>candies[i] = max(candies[i - 1] + 1, candies[i])</code>。</li>
<li>否则，当前孩子获得的糖果数为 <code>candies[i] = 1</code>。</li>
</ul>
</li>
</ul>
<p><strong>证明：</strong></p>
<p>假设当前孩子的评分比左边的孩子高，并且当前孩子获得的糖果数为 <code>candies[i] = candies[i - 1] + 1</code>。如果从右到左遍历时，当前孩子获得的糖果数会被更新为 <code>candies[i] = candies[i + 1] + 1</code>，那么说明 <code>candies[i + 1] + 1 &gt; candies[i - 1] + 1</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ratings[i - 1] &lt; ratings[i] &lt; ratings[i + 1]</span><br><span class="line">candies[i - 1] + 1 &lt; candies[i + 1] + 1</span><br></pre></td></tr></table></figure>
<p>因此，从左到右遍历时，直接将当前孩子获得的糖果数更新为 <code>candies[i] = max(candies[i - 1] + 1, candies[i])</code> 即可保证最终结果正确。</p>
<h3 id="【实现代码】">【实现代码】</h3>
<p>Go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">candy</span><span class="params">(ratings []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(ratings)</span><br><span class="line">    candies := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> candies &#123;</span><br><span class="line">        candies[i] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> ratings[i] &gt; ratings[i<span class="number">-1</span>] &#123;</span><br><span class="line">            candies[i] = max(candies[i<span class="number">-1</span>]+<span class="number">1</span>, candies[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum(candies)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(arr []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">        sum += v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码首先初始化了一个数组 <code>candies</code>，每个元素都为 1。然后，从左到右遍历数组 <code>ratings</code>，根据孩子们的评分比较，更新 <code>candies</code> 数组中的值。最后，计算所有孩子获得的糖果总数并返回。</p>
<h2 id="134-加油站">134. 加油站</h2>
<h3 id="【题目描述】-2">【题目描述】</h3>
<p>环形道路上有 n 个加油站，每个加油站都存有一定量汽油。你有一辆车，油箱容量无限，但初始时油箱为空。</p>
<p>你需要从某个加油站出发，沿环形道路行驶，并尽可能多地访问加油站。每当你到达一个加油站时，你可以选择加油或不加油。</p>
<p><strong>输入：</strong></p>
<ul>
<li><code>gas</code>：一个长度为 <code>n</code> 的数组，表示每个加油站的汽油量</li>
<li><code>cost</code>：一个长度为 <code>n</code> 的数组，表示从一个加油站到相邻加油站的汽油消耗</li>
</ul>
<p><strong>输出：</strong></p>
<ul>
<li>如果可以环绕一周回到出发点，则返回出发加油站的索引。否则，返回 <code>-1</code></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入：gas = [1,2,3,4,5], cost = [3,4,5,1,2]</span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">- 从加油站 3 出发，可以获得 4 单位汽油。</span><br><span class="line">- 行驶到加油站 4，消耗 1 单位汽油，剩余 3 单位汽油。</span><br><span class="line">- 行驶到加油站 0，消耗 5 单位汽油，剩余 -2 单位汽油。</span><br><span class="line">- 加油 5 单位汽油，剩余 3 单位汽油。</span><br><span class="line">- 行驶到加油站 1，消耗 4 单位汽油，剩余 -1 单位汽油。</span><br><span class="line">- 加油 4 单位汽油，剩余 3 单位汽油。</span><br><span class="line">- 行驶到加油站 2，消耗 5 单位汽油，剩余 -2 单位汽油。</span><br><span class="line">- 加油 5 单位汽油，剩余 3 单位汽油。</span><br><span class="line">- 行驶到加油站 3，消耗 1 单位汽油，剩余 2 单位汽油。</span><br><span class="line"></span><br><span class="line">最终，可以回到出发加油站 3。</span><br></pre></td></tr></table></figure>
<h3 id="【解题思路】-2">【解题思路】</h3>
<p><strong>贪心算法</strong></p>
<ol>
<li>首先，定义两个变量 <code>total_gas</code> 和 <code>total_cost</code>，分别表示所有加油站的汽油总量和所有路段的汽油消耗总量。</li>
<li>然后，从某个加油站出发，沿环形道路行驶，并不断更新 <code>total_gas</code> 和 <code>total_cost</code> 的值。</li>
<li>如果 <code>total_gas &lt; total_cost</code>，则说明无法环绕一周回到出发点，返回 <code>-1</code>。</li>
<li>如果 <code>total_gas &gt;= total_cost</code>，则说明可以环绕一周回到出发点，返回出发加油站的索引。</li>
</ol>
<p><strong>证明：</strong></p>
<p>如果 <code>total_gas &lt; total_cost</code>，则说明在某个路段，消耗的汽油比该路段提供的汽油更多。因此，不可能从任何加油站出发，环绕一周回到出发点。</p>
<p>如果 <code>total_gas &gt;= total_cost</code>，则说明总的汽油量足够支持环绕一周。根据贪心算法，我们应该尽可能选择汽油量更多的加油站加油，这样可以减少加油次数，提高效率。因此，从任何加油站出发，最终都可以环绕一周回到出发点。</p>
<h3 id="【实现代码】-2">【实现代码】</h3>
<p>Go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canCompleteCircuit</span><span class="params">(gas []<span class="type">int</span>, cost []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(gas)</span><br><span class="line">    total_gas := <span class="number">0</span></span><br><span class="line">    total_cost := <span class="number">0</span></span><br><span class="line">    start := <span class="number">0</span></span><br><span class="line">    current_gas := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        total_gas += gas[i]</span><br><span class="line">        total_cost += cost[i]</span><br><span class="line">        current_gas += gas[i] - cost[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> current_gas &lt; <span class="number">0</span> &#123;</span><br><span class="line">            current_gas = <span class="number">0</span></span><br><span class="line">            start = i + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> total_gas &lt; total_cost &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> start</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1005-K-次取反后最大化的数组和">1005. K 次取反后最大化的数组和</h2>
<h3 id="【题目描述】-3">【题目描述】</h3>
<p>给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：</p>
<ul>
<li>选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。</li>
<li>重复这个过程恰好 k 次。</li>
<li>可以多次选择同一个下标 i 。</li>
</ul>
<p>以这种方式修改数组后，返回数组可能的最大和。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,2,3], k = 1</span><br><span class="line">输出：5</span><br><span class="line">解释：选择下标 1 ，nums 变为[4,-2,3] 。</span><br><span class="line"></span><br><span class="line">输入：nums = [3,-1,0,2], k = 3</span><br><span class="line">输出：6</span><br><span class="line">解释：选择下标 0、1 和 2 ，nums 变为[6,1,0,2] 。</span><br></pre></td></tr></table></figure>
<h3 id="【解题思路】-3">【解题思路】</h3>
<p><strong>贪心算法</strong></p>
<ol>
<li>
<p>首先，将数组按照绝对值大小从大到小排序，这样可以保证每次取反后，数组和都会增加。</p>
</li>
<li>
<p>然后，从前向后遍历数组：</p>
<ul>
<li>如果遇到负数，则将其取反，并将 k 减 1。</li>
<li>如果 k 为 0，则停止遍历。</li>
</ul>
</li>
<li>
<p>最后，计算数组的和并返回。</p>
</li>
</ol>
<p><strong>证明：</strong></p>
<p>由于数组已经按照绝对值大小从大到小排序，因此每次取反后，数组和都会增加。如果 k 为 0，则说明已经取反了 k 次，无法再进行取反操作。因此，此时数组的和就是最大的。</p>
<h3 id="【实现代码】-3">【实现代码】</h3>
<p>Go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largestSumAfterKNegations</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">//由大到小排序</span></span><br><span class="line">	sort.Slice(nums, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> math.Abs(<span class="type">float64</span>(nums[i])) &gt; math.Abs(<span class="type">float64</span>(nums[j]))</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums) ; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> nums[i] &lt; <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span>&#123;</span><br><span class="line">			nums[i] = -nums[i]</span><br><span class="line">			k--</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// k还没有用完</span></span><br><span class="line">	<span class="keyword">if</span> k &gt; <span class="number">0</span> &amp;&amp; (k&amp;<span class="number">1</span>) == <span class="number">1</span> &#123;</span><br><span class="line">		nums[<span class="built_in">len</span>(nums)<span class="number">-1</span>] = -nums[<span class="built_in">len</span>(nums)<span class="number">-1</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(nums); j++ &#123;</span><br><span class="line">		res += nums[j]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码首先将数组按照绝对值大小从大到小排序。然后，从前向后遍历数组，根据 k 的值，决定是否对负数进行取反。最后，计算数组的和并返回。</p>
<h2 id="45-Jump-Game-II">45 Jump Game II</h2>
<h3 id="【题目描述】-4">【题目描述】</h3>
<p>给定一个非负整数数组 <code>nums</code>，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：2</span><br><span class="line">解释：从下标为 0 跳到下标为 1，然后从下标为 1 跳到下标为 4。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3,0,1,4]</span><br><span class="line">输出：2</span><br><span class="line">解释：从下标为 0 跳到下标为 1，然后从下标为 1 跳到下标为 4。</span><br></pre></td></tr></table></figure>
<h3 id="【解题思路】-4">【解题思路】</h3>
<p>我们可以使用贪心算法来解决这个问题。</p>
<p>具体步骤如下：</p>
<ol>
<li>初始化一个变量 <code>jumps</code> 为 0，表示当前的跳跃次数。</li>
<li>初始化一个变量 <code>current_end</code> 为 0，表示当前可以到达的最远位置。</li>
<li>初始化一个变量 <code>next_end</code> 为 0，表示下一跳可以到达的最远位置。</li>
<li>遍历数组 <code>nums</code>，对于每个位置 <code>i</code>：
<ul>
<li>更新 <code>next_end</code> 为 <code>max(next_end, i + nums[i])</code>，表示下一跳可以到达的最远位置。</li>
<li>如果 <code>i</code> 等于 <code>current_end</code>，表示需要进行一次跳跃：
<ul>
<li>将 <code>jumps</code> 加 1。</li>
<li>将 <code>current_end</code> 更新为 <code>next_end</code>。</li>
<li>将 <code>next_end</code> 更新为 0。</li>
</ul>
</li>
</ul>
</li>
<li>如果 <code>current_end</code> 大于或等于数组的最后一个位置，表示已经到达终点。</li>
</ol>
<h3 id="【实现代码】-4">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123; </span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line">	<span class="comment">//curDistance在当前节点不动，能覆盖的范围</span></span><br><span class="line">	<span class="comment">//nextDistance如果在当前节点移动，能覆盖的范围</span></span><br><span class="line">	curDistance, nextDistance := <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(nums);i++ &#123;</span><br><span class="line">		nextDistance = max(nextDistance, i+nums[i])</span><br><span class="line">		<span class="comment">//到了需要移动的节点了</span></span><br><span class="line">		<span class="keyword">if</span> curDistance == i &#123;</span><br><span class="line">			res++</span><br><span class="line">			curDistance = nextDistance</span><br><span class="line">			<span class="comment">//当前节点覆盖的最大距离大于数组长度了</span></span><br><span class="line">			<span class="keyword">if</span> curDistance &gt;= <span class="built_in">len</span>(nums) <span class="number">-1</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="55-Jump-Game">55 Jump Game</h2>
<h3 id="【题目描述】-5">【题目描述】</h3>
<p>给定一个非负整数数组 <code>nums</code>，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达数组的最后一个位置。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 1 步，然后跳 3 步，再跳 1 步，最后跳 1 步到达最后一个位置。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,1,0,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：无论怎样，总会卡在第三个位置。</span><br></pre></td></tr></table></figure>
<h3 id="【解题思路】-5">【解题思路】</h3>
<p>我们可以使用贪心算法来解决这个问题。</p>
<p>具体步骤如下：</p>
<ol>
<li>初始化一个变量 <code>max_reach</code> 为 0，表示当前可以到达的最远位置。</li>
<li>遍历数组 <code>nums</code>：
<ul>
<li>如果 <code>i</code> 大于 <code>max_reach</code>，表示无法到达当前位置，返回 <code>false</code>。</li>
<li>更新 <code>max_reach</code> 为 <code>max(max_reach, i + nums[i])</code>，表示当前可以到达的最远位置。</li>
</ul>
</li>
<li>如果 <code>max_reach</code> 大于或等于数组的最后一个位置，表示可以到达终点，返回 <code>true</code>。</li>
</ol>
<h3 id="【实现代码】-5">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canJump</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	canCover := <span class="number">0</span></span><br><span class="line">	maxCover := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++ &#123;</span><br><span class="line">		canCover = i + nums[i]</span><br><span class="line">		<span class="keyword">if</span> maxCover &lt; canCover &#123;</span><br><span class="line">			maxCover = canCover</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> maxCover == i &amp;&amp; i != <span class="built_in">len</span>(nums) <span class="number">-1</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="122-Best-Time-to-Buy-and-Sell-Stock-II">122 Best Time to Buy and Sell Stock II</h2>
<h3 id="【题目描述】-6">【题目描述】</h3>
<p>给定一个数组 <code>prices</code>，其中 <code>prices[i]</code> 是某一天的股票价格。</p>
<p>设计一个算法来计算你所能获得的最大利润。你可以尽可能地完成多次交易。</p>
<p>**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [7,1,5,3,6,4]</span><br><span class="line">输出：7</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出，这笔交易获得利润为 5-1 = 4 。</span><br><span class="line">随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，这笔交易获得利润为 6-3 = 3 。</span><br><span class="line">总利润为 4 + 3 = 7 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [1,2,3,4,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出，这笔交易获得利润为 5-1 = 4 。</span><br><span class="line">总利润为 4 。</span><br></pre></td></tr></table></figure>
<h3 id="【解题思路】-6">【解题思路】</h3>
<p>我们可以使用贪心算法来解决这个问题。</p>
<p>具体步骤如下：</p>
<ol>
<li>初始化一个变量 <code>profit</code> 为 0，表示当前的利润。</li>
<li>遍历数组 <code>prices</code>：
<ul>
<li>如果 <code>prices[i]</code> 大于 <code>prices[i-1]</code>，表示股票价格上涨，则将 <code>profit</code> 加上 <code>prices[i] - prices[i-1]</code>。</li>
</ul>
</li>
</ol>
<h3 id="【实现代码】-6">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    profit := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(prices); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> prices[i] &gt; prices[i<span class="number">-1</span>] &#123;</span><br><span class="line">            profit += prices[i] - prices[i<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> profit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="53-Maximum-Subarray">53 Maximum Subarray</h2>
<h3 id="【题目描述】-7">【题目描述】</h3>
<p>给定一个整数数组 <code>nums</code>，请你找出数组中连续的一个子数组，返回其中元素和最大。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 `[4,-1,2,1]` 的和最大，为 6。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,4,-1,7,8]</span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure>
<h3 id="【解题思路】-7">【解题思路】</h3>
<p>我们可以使用贪心算法来解决这个问题。</p>
<h3 id="【实现代码】-7">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">res := <span class="number">-10000</span></span><br><span class="line">	count := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++ &#123;</span><br><span class="line">		count += nums[i]</span><br><span class="line">		<span class="keyword">if</span> count &gt; res &#123;</span><br><span class="line">			res = count</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//重新计数</span></span><br><span class="line">		<span class="keyword">if</span> count&lt;<span class="number">0</span> &#123;</span><br><span class="line">			count = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="376-摆动序列">376 摆动序列</h2>
<h3 id="【题目描述】-8">【题目描述】</h3>
<p>如果一个序列的第一个元素比第二个元素大，第二个元素比第三个元素小，以此类推，则该序列称为摆动序列。</p>
<p>给定一个整数序列，返回其最长的摆动子序列的长度。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,7,4,9,2,5]</span><br><span class="line">输出：6</span><br><span class="line">解释：子序列 [1, 7, 4, 9, 2, 5] 是一个有效的摆动序列，其长度为 6。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,17,5,10,13,15,10,5,16,8]</span><br><span class="line">输出：7</span><br><span class="line">解释：这里有多个有效的摆动子序列，其长度为 7，例如：[1, 17, 10, 13, 10, 8]。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,4,5,6,7,8,9]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<h3 id="【解题思路】-8">【解题思路】</h3>
<p>我们可以使用贪心算法来解决这个问题。</p>
<p>具体步骤如下：</p>
<ol>
<li>初始化一个变量 <code>prevDiff</code> 为 0，表示前一个摆动的差值（正数表示上升，负数表示下降）。</li>
<li>初始化一个变量 <code>maxLength</code> 为 1，表示当前最长的摆动序列长度。</li>
<li>遍历数组 <code>nums</code>：
<ul>
<li>如果 <code>nums[i]</code> 与 <code>nums[i-1]</code> 相等，则跳过。</li>
<li>如果 <code>nums[i]</code> 大于 <code>nums[i-1]</code> 且 <code>prevDiff</code> 小于等于 0，或者 <code>nums[i]</code> 小于 <code>nums[i-1]</code> 且 <code>prevDiff</code> 大于等于 0，则更新 <code>prevDiff</code> 为 <code>nums[i] - nums[i-1]</code>，并将 <code>maxLength</code> 加 1。</li>
</ul>
</li>
</ol>
<h3 id="【实现代码】-8">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wiggleMaxLength</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	prevDiff := nums[<span class="number">1</span>]-nums[<span class="number">0</span>]</span><br><span class="line">	res := <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> prevDiff != <span class="number">0</span> &#123;</span><br><span class="line">		res = <span class="number">2</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">2</span>;i&lt;<span class="built_in">len</span>(nums);i++ &#123;</span><br><span class="line">		curDiff := nums[i]-nums[i<span class="number">-1</span>]</span><br><span class="line">		<span class="keyword">if</span> (prevDiff&lt;=<span class="number">0</span> &amp;&amp; curDiff&gt;<span class="number">0</span>) </span><br><span class="line">			|| (prevDiff&gt;=<span class="number">0</span> &amp;&amp; curDiff&lt;<span class="number">0</span>) &#123;</span><br><span class="line">			res++</span><br><span class="line">			<span class="comment">//这个不能放在外层</span></span><br><span class="line">			prevDiff = curDiff</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="455-分发饼干">455 分发饼干</h2>
<h3 id="【题目描述】-9">【题目描述】</h3>
<p>给定一个数组 <code>g</code>，其中 <code>g[i]</code> 表示第 <code>i</code> 个孩子吃的饼干数，以及一个数组 <code>s</code>，其中 <code>s[j]</code> 表示第 <code>j</code> 个饼干的大小。两个数组的长度都是 <code>n</code>。</p>
<p>你需要给每个孩子分配一个饼干，使得满足以下条件：</p>
<ul>
<li>每个孩子只能得到一个饼干。</li>
<li>每个饼干只能给一个孩子。</li>
<li>孩子们获得的饼干大小总和必须尽可能大。</li>
</ul>
<p>返回可以满足上述条件的最大饼干总和。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：g = [1,2,3], s = [1,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：孩子 1 和孩子 2 分别得到饼干 1 和饼干 2，总和为 3。孩子 3 没有得到饼干。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：g = [1,2], s = [1,2,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：孩子 1 和孩子 2 分别得到饼干 1 和饼干 2，总和为 2。</span><br></pre></td></tr></table></figure>
<h3 id="【解题思路】-9">【解题思路】</h3>
<p>我们可以使用贪心算法来解决这个问题。</p>
<p>具体步骤如下：</p>
<ol>
<li>将 <code>g</code> 和 <code>s</code> 数组分别排序。</li>
<li>从头开始遍历两个数组。</li>
<li>如果 <code>g[i]</code> 小于等于 <code>s[j]</code>，则将 <code>g[i]</code> 和 <code>s[j]</code> 匹配，并更新饼干总和。</li>
<li>否则，跳过 <code>g[i]</code>，继续遍历 <code>s</code> 数组。</li>
</ol>
<h3 id="【实现代码】-9">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findContentChildren</span><span class="params">(g []<span class="type">int</span>, s []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    sort.Ints(g)</span><br><span class="line">    sort.Ints(s)</span><br><span class="line"></span><br><span class="line">    i, j, count := <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="built_in">len</span>(g) &amp;&amp; j &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">        <span class="keyword">if</span> g[i] &lt;= s[j] &#123;</span><br><span class="line">            count++</span><br><span class="line">            i++</span><br><span class="line">            j++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="860-柠檬水找零">860 柠檬水找零</h2>
<h3 id="【题目描述】-10">【题目描述】</h3>
<p>在柠檬水摊上，顾客只用 5 元、10 元和 20 元的钞票来购买柠檬水，而你只有无限量的 5 元钞票。</p>
<p>给你一个整数数组 <code>bills</code>，其中 <code>bills[i]</code> 表示第 <code>i</code> 个顾客付的钞票面额。</p>
<p>请你计算可能的最大利润，即卖出柠檬水后你获得的净收入。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：bills = [5,5,5,10,20]</span><br><span class="line">输出：15</span><br><span class="line">解释：</span><br><span class="line">第 1 个顾客给了 5 元，我们找零 0 元。</span><br><span class="line">第 2 个顾客给了 5 元，我们找零 0 元。</span><br><span class="line">第 3 个顾客给了 5 元，我们找零 0 元。</span><br><span class="line">第 4 个顾客给了 10 元，我们找零 5 元。</span><br><span class="line">第 5 个顾客给了 20 元，我们找零 15 元。</span><br><span class="line">总利润为 15 + 5 + 0 + 0 + 0 = 15 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：bills = [5,5,10]</span><br><span class="line">输出：10</span><br><span class="line">解释：</span><br><span class="line">第 1 个顾客给了 5 元，我们找零 0 元。</span><br><span class="line">第 2 个顾客给了 5 元，我们找零 0 元。</span><br><span class="line">第 3 个顾客给了 10 元，我们找零 5 元。</span><br><span class="line">总利润为 5 + 5 + 0 = 10 。</span><br></pre></td></tr></table></figure>
<h3 id="【解题思路】-10">【解题思路】</h3>
<p>我们可以使用贪心算法来解决这个问题。</p>
<p>具体步骤如下：</p>
<ol>
<li>初始化一个变量 <code>change</code>，表示当前找零的金额。</li>
<li>初始化一个变量 <code>profit</code>，表示当前利润。</li>
<li>遍历 <code>bills</code> 数组中的每个面额：
<ul>
<li>如果面额是 5 元，则将 <code>change</code> 加 5。</li>
<li>如果面额是 10 元，则将 <code>change</code> 加 10，并检查是否可以找零 5 元。如果可以，则将 <code>change</code> 减 5，并将 <code>profit</code> 加 5。否则，返回 -1，表示无法找零。</li>
<li>如果面额是 20 元，则将 <code>change</code> 加 20，并检查是否可以找零 15 元。如果可以，则将 <code>change</code> 减 15，并将 <code>profit</code> 加 5。否则，检查是否可以找零 10 元和 5 元。如果可以，则将 <code>change</code> 减 10，并将 <code>profit</code> 加 5。否则，返回 -1，表示无法找零。</li>
</ul>
</li>
<li>遍历结束后，返回 <code>profit</code>。</li>
</ol>
<h3 id="【实现代码】-10">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lemonadeChange</span><span class="params">(bills []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	fiveCount := <span class="number">0</span></span><br><span class="line">	tenCount := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, bill := <span class="keyword">range</span> bills &#123;</span><br><span class="line">		<span class="keyword">if</span> bill == <span class="number">5</span> &#123;</span><br><span class="line">			fiveCount++</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> bill == <span class="number">10</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> fiveCount &gt;= <span class="number">1</span> &#123;</span><br><span class="line">				fiveCount--</span><br><span class="line">				tenCount++</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> bill == <span class="number">20</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> tenCount&gt;=<span class="number">1</span> &amp;&amp; fiveCount&gt;=<span class="number">1</span> &#123;</span><br><span class="line">				tenCount--</span><br><span class="line">				fiveCount--</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> fiveCount&gt;=<span class="number">3</span> &#123;</span><br><span class="line">				fiveCount-=<span class="number">3</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="406-根据身高重建队列">406 根据身高重建队列</h2>
<h3 id="【题目描述】-11">【题目描述】</h3>
<p>有 <code>n</code> 个人站成一排，按从后往前依次编号为 <code>0</code> 到 <code>n-1</code>。每个人有自己的身高，现在每个人想按照身高重新排列成一排，并且 <strong>不允许</strong> 其他人移动。</p>
<p>某人可以站在队列的 <strong>任意位置</strong>，并且 <strong>其他人为此可能需要向前或向后移动</strong>。</p>
<p>给你一个数组 <code>people</code>，其中 <code>people[i] = [hi, ki]</code> 表示第 <code>i</code> 个人的身高 <code>hi</code> 和该人前面必须排放的 <strong>至少</strong> 人数 <code>ki</code>。</p>
<p>请你重新排列队列，使得 <strong>满足上述条件</strong> 下，<strong>队列人员的站位数量最多</strong>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</span><br><span class="line">输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]</span><br><span class="line">输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]</span><br></pre></td></tr></table></figure>
<h3 id="【解题思路】-11">【解题思路】</h3>
<p>我们可以使用贪心算法来解决这个问题。</p>
<p>具体步骤如下：</p>
<ol>
<li>将 <code>people</code> 数组按身高降序排序。</li>
<li>初始化一个空队列 <code>queue</code>。</li>
<li>遍历排序后的 <code>people</code> 数组：
<ul>
<li>如果 <code>queue</code> 为空，则直接将当前人员添加到 <code>queue</code> 的末尾。</li>
<li>否则，从 <code>queue</code> 的头部开始遍历，直到找到一个满足 <code>ki</code> 条件的位置。</li>
<li>将当前人员插入到该位置后，将 <code>queue</code> 中该位置之后的所有人员向后移动一位。</li>
</ul>
</li>
<li>返回排列好的 <code>queue</code>。</li>
</ol>
<h3 id="【实现代码】-11">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reconstructQueue</span><span class="params">(people [][]<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 高个子先排好</span></span><br><span class="line">	sort.Slice(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> people[i][<span class="number">0</span>] == people[j][<span class="number">0</span>] &#123;</span><br><span class="line">			<span class="keyword">return</span> people[i][<span class="number">1</span>] &lt; people[j][<span class="number">1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> people[i][<span class="number">0</span>] &gt; people[j][<span class="number">0</span>]</span><br><span class="line">	&#125;)</span><br><span class="line">	res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, p := <span class="keyword">range</span> people &#123;</span><br><span class="line">		index := p[<span class="number">1</span>]</span><br><span class="line">		res = <span class="built_in">append</span>(res[:index], <span class="built_in">append</span>([][]<span class="type">int</span>&#123;p&#125;, res[index:]...)...)</span><br><span class="line">		<span class="comment">// copy(res[index+1:], res[index:])</span></span><br><span class="line">		<span class="comment">// res[index] = p</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="452-用最少数量的箭引爆气球">452 用最少数量的箭引爆气球</h2>
<h3 id="【题目描述】-12">【题目描述】</h3>
<p>有 <code>n</code> 个气球，每个气球都位于一条数轴上，位置为 <code>xi</code>。每个气球都有一定的半径 <code>ri</code>。</p>
<p>现在需要用弓箭爆破气球。弓箭的射程有限，只能射中 <code>x</code> 轴上某一点，并且只能引爆与该点距离不超过其射程的 <strong>所有</strong> 气球。</p>
<p>求引爆所有气球需要的最少弓箭数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[10,16],[2,8],[1,6],[7,12]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[1,2],[3,4],[5,6],[7,8]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<h3 id="【解题思路】-12">【解题思路】</h3>
<p>我们可以使用贪心算法来解决这个问题。</p>
<h3 id="【实现代码】-12">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMinArrowShots</span><span class="params">(points [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(points) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//按左边界排序</span></span><br><span class="line">	sort.Slice(points, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> points[i][<span class="number">0</span>] &lt; points[j][<span class="number">0</span>]</span><br><span class="line">	&#125;)</span><br><span class="line">	res := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(points); i++ &#123;</span><br><span class="line">		<span class="comment">//如果不想交，则需要一支箭</span></span><br><span class="line">		<span class="keyword">if</span> points[i][<span class="number">0</span>] &gt; points[i<span class="number">-1</span>][<span class="number">1</span>] &#123;</span><br><span class="line">			res++</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//相交，则维护当前的右边界</span></span><br><span class="line">			points[i][<span class="number">1</span>] = min(points[i][<span class="number">1</span>], points[i<span class="number">-1</span>][<span class="number">1</span>])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="435-无重叠区间">435 无重叠区间</h2>
<h3 id="【题目描述】-13">【题目描述】</h3>
<p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,2],[2,3],[3,4],[1,3]]</span><br><span class="line">输出：1</span><br><span class="line">解释：可以移除区间 [1,3]，得到无重叠区间集合 [[1,2],[2,3],[3,4]]。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,2],[1,2],[1,2]]</span><br><span class="line">输出：2</span><br><span class="line">解释：可以移除两个区间 [1,2]，得到无重叠区间集合 []。</span><br></pre></td></tr></table></figure>
<h3 id="【解题思路】-13">【解题思路】</h3>
<p>我们可以使用贪心算法来解决这个问题。<br>
解题思路同 452</p>
<h3 id="【实现代码】-13">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eraseOverlapIntervals</span><span class="params">(intervals [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	sort.Slice(intervals, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> intervals[i][<span class="number">0</span>] &lt; intervals[j][<span class="number">0</span>]</span><br><span class="line">	&#125;)</span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(intervals); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> intervals[i][<span class="number">0</span>] &lt; intervals[i<span class="number">-1</span>][<span class="number">1</span>] &#123;</span><br><span class="line">			res++</span><br><span class="line">			intervals[i][<span class="number">1</span>] = min(intervals[i][<span class="number">1</span>], intervals[i<span class="number">-1</span>][<span class="number">1</span>])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="763-划分字母区间">763 划分字母区间</h2>
<p>给你一个字符串 <code>s</code> 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。<br>
注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 <code>s</code> 。<br>
返回一个表示每个字符串片段的长度的列表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ababcbacadefegdehijhklij&quot;</span><br><span class="line">输出：[9,7,8]</span><br><span class="line">解释：</span><br><span class="line">划分结果为 &quot;ababcbaca&quot;、&quot;defegde&quot;、&quot;hijhklij&quot; 。</span><br><span class="line">每个字母最多出现在一个片段中。</span><br><span class="line">像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 这样的划分是错误的，因为划分的片段数较少。</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partitionLabels</span><span class="params">(s <span class="type">string</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	mp := <span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 维护当前字母的最右边界</span></span><br><span class="line">	<span class="keyword">for</span> index, element := <span class="keyword">range</span> s &#123;</span><br><span class="line">		mp[element] = index</span><br><span class="line">	&#125;</span><br><span class="line">	left,right := <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">	res := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> index, element := <span class="keyword">range</span> s &#123;</span><br><span class="line">		<span class="comment">// 当前区间的最右边界</span></span><br><span class="line">		right = max(right, mp[element])</span><br><span class="line">		<span class="comment">// 打到最右边界</span></span><br><span class="line">		<span class="keyword">if</span> right == index &#123;</span><br><span class="line">			res = <span class="built_in">append</span>(res, index-left+<span class="number">1</span>)</span><br><span class="line">			left = index+<span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="53-最大子序和">53 最大子序和</h2>
<h3 id="【题目描述】-14">【题目描述】</h3>
<p>给定一个整数数组 nums ，找到一个连续子数组，该子数组具有最大的和。</p>
<h3 id="【解题思路】-14">【解题思路】</h3>
<p>使用贪心算法，从左到右遍历数组，维护当前子数组的和和全局最大子数组和。</p>
<ol>
<li>如果当前子数组和为负数，则重置当前子数组和为 0。</li>
<li>如果当前子数组和大于全局最大子数组和，则更新全局最大子数组和。</li>
<li>继续遍历数组，重复上述步骤。</li>
</ol>
<h3 id="【实现代码】-14">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// curSum 为当前子数组的和</span></span><br><span class="line">    curSum := <span class="number">0</span></span><br><span class="line">    <span class="comment">// maxSum 为全局最大子数组和</span></span><br><span class="line">    maxSum := math.MinInt32</span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="comment">// 将当前元素加入子数组</span></span><br><span class="line">        curSum += num</span><br><span class="line">        <span class="comment">// 更新全局最大子数组和</span></span><br><span class="line">        <span class="keyword">if</span> curSum &gt; maxSum &#123;</span><br><span class="line">            maxSum = curSum</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">// 如果当前子数组和为负数，则重置为 0</span></span><br><span class="line">        <span class="keyword">if</span> curSum &lt; <span class="number">0</span> &#123;</span><br><span class="line">            curSum = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="738-单调递增的数字">738. 单调递增的数字</h2>
<h3 id="【题目描述】-15">【题目描述】</h3>
<p>给定一个非负整数 <code>N</code>，找出小于或等于 <code>N</code> 的最大的整数，同时该整数需要满足其各个位数上的数字是单调递增的。<br>
（当且仅当每个相邻位数上的数字 <code>x</code> 和 <code>y</code> 满足 <code>x &lt;= y</code> 时，我们称这个整数是单调递增的。）</p>
<h3 id="【实现代码】-15">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	s := strconv.Itoa(n)</span><br><span class="line">	ss := []<span class="type">byte</span>(s)</span><br><span class="line">	length := <span class="built_in">len</span>(ss)</span><br><span class="line">	<span class="keyword">if</span> length &lt;= <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">		<span class="keyword">if</span> ss[i] &lt; ss[i<span class="number">-1</span>] &#123;</span><br><span class="line">			<span class="keyword">for</span> j:=i;j&lt;length;j++ &#123;</span><br><span class="line">				ss[j] = <span class="string">&#x27;9&#x27;</span></span><br><span class="line">			&#125;</span><br><span class="line">			ss[i<span class="number">-1</span>]--</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	r, _ := strconv.Atoi(<span class="type">string</span>(ss))</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="968-监控二叉树">968 监控二叉树</h2>
<h3 id="【题目描述】-16">【题目描述】</h3>
<p>给定一个二叉树，我们在树的每个节点上放置一个监控摄像头。每个节点都可以看到它所有的子节点。树的根节点可以看到整个树。请你找出所需的最小摄像头数量，以便监视树上的所有节点。</p>
<h3 id="【解题思路】-15">【解题思路】</h3>
<p>使用贪心算法：</p>
<ol>
<li>从根节点开始遍历二叉树。</li>
<li>对于每个节点，有以下三种情况：
<ul>
<li>节点没有被监控，则放置一个摄像头。</li>
<li>节点的父节点没有被监控，则放置一个摄像头。</li>
<li>节点和节点的父节点都被监控，则不需要放置摄像头。</li>
</ul>
</li>
<li>返回放置摄像头的最小数量。</li>
</ol>
<h3 id="【实现代码】-16">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minCameraCover</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		NONE   = <span class="number">0</span></span><br><span class="line">		CAMERA = <span class="number">1</span></span><br><span class="line">		COVER  = <span class="number">2</span></span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span></span><br><span class="line">	dfs = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		<span class="comment">// 如果把摄像头放在叶子节点上，就浪费的一层的覆盖。</span></span><br><span class="line">		<span class="comment">// nil节点算覆盖的，则叶子结点才能不安装</span></span><br><span class="line">		<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> COVER</span><br><span class="line">		&#125;</span><br><span class="line">		left := dfs(root.Left)</span><br><span class="line">		right := dfs(root.Right)</span><br><span class="line">		<span class="comment">// 左右都被覆盖，不需要安装</span></span><br><span class="line">		<span class="keyword">if</span> left == COVER &amp;&amp; right == COVER &#123;</span><br><span class="line">			<span class="keyword">return</span> NONE</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 左右只要有一个没有覆盖，就需要安装摄像头</span></span><br><span class="line">		<span class="keyword">if</span> left == NONE || right == NONE &#123;</span><br><span class="line">			res++</span><br><span class="line">			<span class="keyword">return</span> CAMERA</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 左右有一个摄像头，当前为被覆盖状态</span></span><br><span class="line">		<span class="keyword">if</span> left == CAMERA || right == CAMERA &#123;</span><br><span class="line">			<span class="keyword">return</span> COVER</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//跟节点没有被覆盖</span></span><br><span class="line">	<span class="keyword">if</span> (dfs(root) == NONE) &#123;</span><br><span class="line">		res++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/categories/">Category</a></li>
        
          <li><a href="/tags/">Tag</a></li>
        
          <li><a href="/search">Search</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/jonasrepo.github.io">Projects</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">核心</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">能解决的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#135-Candy"><span class="toc-number">2.1.</span> <span class="toc-text">135. Candy</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91"><span class="toc-number">2.1.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91"><span class="toc-number">2.1.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91"><span class="toc-number">2.1.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#134-%E5%8A%A0%E6%B2%B9%E7%AB%99"><span class="toc-number">2.2.</span> <span class="toc-text">134. 加油站</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-2"><span class="toc-number">2.2.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-2"><span class="toc-number">2.2.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-2"><span class="toc-number">2.2.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1005-K-%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-number">2.3.</span> <span class="toc-text">1005. K 次取反后最大化的数组和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-3"><span class="toc-number">2.3.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-3"><span class="toc-number">2.3.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-3"><span class="toc-number">2.3.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45-Jump-Game-II"><span class="toc-number">2.4.</span> <span class="toc-text">45 Jump Game II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-4"><span class="toc-number">2.4.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-4"><span class="toc-number">2.4.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-4"><span class="toc-number">2.4.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55-Jump-Game"><span class="toc-number">2.5.</span> <span class="toc-text">55 Jump Game</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-5"><span class="toc-number">2.5.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-5"><span class="toc-number">2.5.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-5"><span class="toc-number">2.5.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#122-Best-Time-to-Buy-and-Sell-Stock-II"><span class="toc-number">2.6.</span> <span class="toc-text">122 Best Time to Buy and Sell Stock II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-6"><span class="toc-number">2.6.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-6"><span class="toc-number">2.6.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-6"><span class="toc-number">2.6.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-Maximum-Subarray"><span class="toc-number">2.7.</span> <span class="toc-text">53 Maximum Subarray</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-7"><span class="toc-number">2.7.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-7"><span class="toc-number">2.7.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-7"><span class="toc-number">2.7.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97"><span class="toc-number">2.8.</span> <span class="toc-text">376 摆动序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-8"><span class="toc-number">2.8.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-8"><span class="toc-number">2.8.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-8"><span class="toc-number">2.8.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2"><span class="toc-number">2.9.</span> <span class="toc-text">455 分发饼干</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-9"><span class="toc-number">2.9.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-9"><span class="toc-number">2.9.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-9"><span class="toc-number">2.9.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6"><span class="toc-number">2.10.</span> <span class="toc-text">860 柠檬水找零</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-10"><span class="toc-number">2.10.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-10"><span class="toc-number">2.10.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-10"><span class="toc-number">2.10.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#406-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97"><span class="toc-number">2.11.</span> <span class="toc-text">406 根据身高重建队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-11"><span class="toc-number">2.11.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-11"><span class="toc-number">2.11.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-11"><span class="toc-number">2.11.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#452-%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83"><span class="toc-number">2.12.</span> <span class="toc-text">452 用最少数量的箭引爆气球</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-12"><span class="toc-number">2.12.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-12"><span class="toc-number">2.12.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-12"><span class="toc-number">2.12.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4"><span class="toc-number">2.13.</span> <span class="toc-text">435 无重叠区间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-13"><span class="toc-number">2.13.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-13"><span class="toc-number">2.13.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-13"><span class="toc-number">2.13.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4"><span class="toc-number">2.14.</span> <span class="toc-text">763 划分字母区间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C"><span class="toc-number">2.15.</span> <span class="toc-text">53 最大子序和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-14"><span class="toc-number">2.15.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-14"><span class="toc-number">2.15.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-14"><span class="toc-number">2.15.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#738-%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">2.16.</span> <span class="toc-text">738. 单调递增的数字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-15"><span class="toc-number">2.16.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-15"><span class="toc-number">2.16.2.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#968-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.17.</span> <span class="toc-text">968 监控二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-16"><span class="toc-number">2.17.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-15"><span class="toc-number">2.17.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-16"><span class="toc-number">2.17.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://localhost:4000/2024/03/08/leetcode/%E8%B4%AA%E5%BF%83/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://localhost:4000/2024/03/08/leetcode/%E8%B4%AA%E5%BF%83/&text=贪心"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://localhost:4000/2024/03/08/leetcode/%E8%B4%AA%E5%BF%83/&title=贪心"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://localhost:4000/2024/03/08/leetcode/%E8%B4%AA%E5%BF%83/&is_video=false&description=贪心"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=贪心&body=Check out this article: http://localhost:4000/2024/03/08/leetcode/%E8%B4%AA%E5%BF%83/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://localhost:4000/2024/03/08/leetcode/%E8%B4%AA%E5%BF%83/&title=贪心"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://localhost:4000/2024/03/08/leetcode/%E8%B4%AA%E5%BF%83/&title=贪心"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://localhost:4000/2024/03/08/leetcode/%E8%B4%AA%E5%BF%83/&title=贪心"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://localhost:4000/2024/03/08/leetcode/%E8%B4%AA%E5%BF%83/&title=贪心"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://localhost:4000/2024/03/08/leetcode/%E8%B4%AA%E5%BF%83/&name=贪心&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://localhost:4000/2024/03/08/leetcode/%E8%B4%AA%E5%BF%83/&t=贪心"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2024
    jonas
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/categories/">Category</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a href="/search">Search</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/jonasrepo.github.io">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
