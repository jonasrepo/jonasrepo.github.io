<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="核心 动态规划中每一个状态一定是由上一个状态推导出来 五部曲  确定dp数组及下标含义 确定递推公式 dp数组初始化 确定遍历顺序 举例推导dp数组  能解决的问题  背包问题  01背包 完全背包 多重背包   打家劫舍 股票问题  只能买卖一次 可以买卖多次 最多买卖两次 最多买卖k次   子序列问题  子序列（不连续） 子序列（连续） 编辑距离 回文    509 斐波那契数 【题目描述】">
<meta property="og:type" content="article">
<meta property="og:title" content="动态规划">
<meta property="og:url" content="http://localhost:4000/2024/03/11/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/index.html">
<meta property="og:site_name" content="Jonas">
<meta property="og:description" content="核心 动态规划中每一个状态一定是由上一个状态推导出来 五部曲  确定dp数组及下标含义 确定递推公式 dp数组初始化 确定遍历顺序 举例推导dp数组  能解决的问题  背包问题  01背包 完全背包 多重背包   打家劫舍 股票问题  只能买卖一次 可以买卖多次 最多买卖两次 最多买卖k次   子序列问题  子序列（不连续） 子序列（连续） 编辑距离 回文    509 斐波那契数 【题目描述】">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-03-11T07:36:17.219Z">
<meta property="article:modified_time" content="2024-07-10T04:55:11.938Z">
<meta property="article:author" content="jonas">
<meta property="article:tag" content="动态规划">
<meta property="article:tag" content="leetcode">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>动态规划</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<meta name="generator" content="Hexo 7.1.1"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/categories/">Category</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a href="/search">Search</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/jonasrepo.github.io">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2024/03/26/leetcode/%E5%9B%9E%E6%BA%AF/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2024/03/08/leetcode/%E8%B4%AA%E5%BF%83/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://localhost:4000/2024/03/11/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://localhost:4000/2024/03/11/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&text=动态规划"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://localhost:4000/2024/03/11/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&title=动态规划"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://localhost:4000/2024/03/11/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&is_video=false&description=动态规划"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=动态规划&body=Check out this article: http://localhost:4000/2024/03/11/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://localhost:4000/2024/03/11/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&title=动态规划"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://localhost:4000/2024/03/11/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&title=动态规划"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://localhost:4000/2024/03/11/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&title=动态规划"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://localhost:4000/2024/03/11/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&title=动态规划"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://localhost:4000/2024/03/11/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&name=动态规划&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://localhost:4000/2024/03/11/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&t=动态规划"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">核心</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E9%83%A8%E6%9B%B2"><span class="toc-number">1.1.</span> <span class="toc-text">五部曲</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%BD%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.</span> <span class="toc-text">能解决的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0"><span class="toc-number">1.3.</span> <span class="toc-text">509 斐波那契数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91"><span class="toc-number">1.3.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91"><span class="toc-number">1.3.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91"><span class="toc-number">1.3.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#70-%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-number">1.4.</span> <span class="toc-text">70 爬楼梯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-2"><span class="toc-number">1.4.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-2"><span class="toc-number">1.4.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-2"><span class="toc-number">1.4.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-number">1.5.</span> <span class="toc-text">746 使用最小花费爬楼梯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-3"><span class="toc-number">1.5.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-3"><span class="toc-number">1.5.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-3"><span class="toc-number">1.5.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="toc-number">1.6.</span> <span class="toc-text">62 不同路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-4"><span class="toc-number">1.6.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-4"><span class="toc-number">1.6.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-4"><span class="toc-number">1.6.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-II"><span class="toc-number">1.7.</span> <span class="toc-text">63 不同路径 II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-5"><span class="toc-number">1.7.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-5"><span class="toc-number">1.7.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-5"><span class="toc-number">1.7.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#343-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86"><span class="toc-number">1.8.</span> <span class="toc-text">343 整数拆分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-6"><span class="toc-number">1.8.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-6"><span class="toc-number">1.8.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-6"><span class="toc-number">1.8.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.9.</span> <span class="toc-text">96 不同的二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-7"><span class="toc-number">1.9.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-7"><span class="toc-number">1.9.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-7"><span class="toc-number">1.9.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="toc-number">1.10.</span> <span class="toc-text">416 分割等和子集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-8"><span class="toc-number">1.10.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-8"><span class="toc-number">1.10.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-8"><span class="toc-number">1.10.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1049-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F-II"><span class="toc-number">1.11.</span> <span class="toc-text">1049 最后一块石头的重量 II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-9"><span class="toc-number">1.11.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-9"><span class="toc-number">1.11.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-9"><span class="toc-number">1.11.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#494-%E7%9B%AE%E6%A0%87%E5%92%8C"><span class="toc-number">1.12.</span> <span class="toc-text">494 目标和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-10"><span class="toc-number">1.12.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-10"><span class="toc-number">1.12.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-10"><span class="toc-number">1.12.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#474-%E4%B8%80%E5%92%8C%E9%9B%B6"><span class="toc-number">1.13.</span> <span class="toc-text">474 一和零</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-11"><span class="toc-number">1.13.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-11"><span class="toc-number">1.13.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-11"><span class="toc-number">1.13.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-II"><span class="toc-number">1.14.</span> <span class="toc-text">518 零钱兑换 II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-12"><span class="toc-number">1.14.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-12"><span class="toc-number">1.14.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-12"><span class="toc-number">1.14.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%E2%85%A3"><span class="toc-number">1.15.</span> <span class="toc-text">377 组合总和 Ⅳ</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-13"><span class="toc-number">1.15.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-13"><span class="toc-number">1.15.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-13"><span class="toc-number">1.15.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="toc-number">1.16.</span> <span class="toc-text">322 零钱兑换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-14"><span class="toc-number">1.16.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-14"><span class="toc-number">1.16.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-14"><span class="toc-number">1.16.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="toc-number">1.17.</span> <span class="toc-text">279 完全平方数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-15"><span class="toc-number">1.17.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-15"><span class="toc-number">1.17.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-15"><span class="toc-number">1.17.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="toc-number">1.18.</span> <span class="toc-text">139 单词拆分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-16"><span class="toc-number">1.18.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-16"><span class="toc-number">1.18.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-16"><span class="toc-number">1.18.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-number">1.19.</span> <span class="toc-text">198 打家劫舍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-17"><span class="toc-number">1.19.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-17"><span class="toc-number">1.19.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-17"><span class="toc-number">1.19.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#213-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-II"><span class="toc-number">1.20.</span> <span class="toc-text">213 打家劫舍 II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-18"><span class="toc-number">1.20.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-18"><span class="toc-number">1.20.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-18"><span class="toc-number">1.20.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#337-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-III"><span class="toc-number">1.21.</span> <span class="toc-text">337 打家劫舍 III</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-19"><span class="toc-number">1.21.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-19"><span class="toc-number">1.21.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-19"><span class="toc-number">1.21.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="toc-number">1.22.</span> <span class="toc-text">121 买卖股票的最佳时机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-20"><span class="toc-number">1.22.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-20"><span class="toc-number">1.22.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-20"><span class="toc-number">1.22.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II"><span class="toc-number">1.23.</span> <span class="toc-text">122 买卖股票的最佳时机 II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-21"><span class="toc-number">1.23.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-21"><span class="toc-number">1.23.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-21"><span class="toc-number">1.23.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-III"><span class="toc-number">1.24.</span> <span class="toc-text">123 买卖股票的最佳时机 III</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-22"><span class="toc-number">1.24.1.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-22"><span class="toc-number">1.24.2.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-IV"><span class="toc-number">1.25.</span> <span class="toc-text">188 买卖股票的最佳时机 IV</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-22"><span class="toc-number">1.25.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-23"><span class="toc-number">1.25.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-23"><span class="toc-number">1.25.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F"><span class="toc-number">1.26.</span> <span class="toc-text">309 最佳买卖股票时机含冷冻期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-23"><span class="toc-number">1.26.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-24"><span class="toc-number">1.26.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-24"><span class="toc-number">1.26.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9"><span class="toc-number">1.27.</span> <span class="toc-text">714 买卖股票的最佳时机含手续费</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-24"><span class="toc-number">1.27.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-25"><span class="toc-number">1.27.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-25"><span class="toc-number">1.27.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">1.28.</span> <span class="toc-text">300 最长递增子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-25"><span class="toc-number">1.28.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-26"><span class="toc-number">1.28.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-26"><span class="toc-number">1.28.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#674-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97"><span class="toc-number">1.29.</span> <span class="toc-text">674 最长连续递增序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-26"><span class="toc-number">1.29.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-27"><span class="toc-number">1.29.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-27"><span class="toc-number">1.29.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#718-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">1.30.</span> <span class="toc-text">718 最长重复子数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-27"><span class="toc-number">1.30.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-28"><span class="toc-number">1.30.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-28"><span class="toc-number">1.30.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">1.31.</span> <span class="toc-text">1143 最长公共子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-28"><span class="toc-number">1.31.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-29"><span class="toc-number">1.31.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-29"><span class="toc-number">1.31.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1035-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF%EF%BC%88%E7%AD%89%E5%90%8C%E4%BA%8E%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%89"><span class="toc-number">1.32.</span> <span class="toc-text">1035 不相交的线（等同于最长公共子序列）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-29"><span class="toc-number">1.32.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-30"><span class="toc-number">1.32.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-30"><span class="toc-number">1.32.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-number">1.33.</span> <span class="toc-text">53 最大子数组和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-30"><span class="toc-number">1.33.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-31"><span class="toc-number">1.33.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-31"><span class="toc-number">1.33.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#392-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">1.34.</span> <span class="toc-text">392 判断子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-31"><span class="toc-number">1.34.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-32"><span class="toc-number">1.34.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-32"><span class="toc-number">1.34.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#115-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">1.35.</span> <span class="toc-text">115 不同的子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-32"><span class="toc-number">1.35.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-33"><span class="toc-number">1.35.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-33"><span class="toc-number">1.35.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#583-%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">1.36.</span> <span class="toc-text">583 两个字符串的删除操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-33"><span class="toc-number">1.36.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-34"><span class="toc-number">1.36.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-34"><span class="toc-number">1.36.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="toc-number">1.37.</span> <span class="toc-text">72 编辑距离</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-34"><span class="toc-number">1.37.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-35"><span class="toc-number">1.37.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-35"><span class="toc-number">1.37.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-number">1.38.</span> <span class="toc-text">647 回文子串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-35"><span class="toc-number">1.38.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-36"><span class="toc-number">1.38.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-36"><span class="toc-number">1.38.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#516-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">1.39.</span> <span class="toc-text">516 最长回文子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-36"><span class="toc-number">1.39.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-37"><span class="toc-number">1.39.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-37"><span class="toc-number">1.39.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="toc-number">1.40.</span> <span class="toc-text">42 接雨水</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-37"><span class="toc-number">1.40.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-38"><span class="toc-number">1.40.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-38"><span class="toc-number">1.40.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2"><span class="toc-number">1.41.</span> <span class="toc-text">84 柱状图中最大的矩形</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-38"><span class="toc-number">1.41.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-39"><span class="toc-number">1.41.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-39"><span class="toc-number">1.41.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        动态规划
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">jonas</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-03-11T07:36:17.219Z" class="dt-published" itemprop="datePublished">2024-03-11</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/leetcode/">leetcode</a>
    </div>


      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/leetcode/" rel="tag">leetcode</a>, <a class="p-category" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1>核心</h1>
<p>动态规划中每一个状态一定是由上一个状态推导出来</p>
<h2 id="五部曲">五部曲</h2>
<ol>
<li>确定dp数组及下标含义</li>
<li>确定递推公式</li>
<li>dp数组初始化</li>
<li>确定遍历顺序</li>
<li>举例推导dp数组</li>
</ol>
<h2 id="能解决的问题">能解决的问题</h2>
<ul>
<li>背包问题
<ul>
<li>01背包</li>
<li>完全背包</li>
<li>多重背包</li>
</ul>
</li>
<li>打家劫舍</li>
<li>股票问题
<ul>
<li>只能买卖一次</li>
<li>可以买卖多次</li>
<li>最多买卖两次</li>
<li>最多买卖k次</li>
</ul>
</li>
<li>子序列问题
<ul>
<li>子序列（不连续）</li>
<li>子序列（连续）</li>
<li>编辑距离</li>
<li>回文</li>
</ul>
</li>
</ul>
<h2 id="509-斐波那契数">509 斐波那契数</h2>
<h3 id="【题目描述】">【题目描述】</h3>
<p>给你一个整数 n，请你返回第 n 个斐波那契数。斐波那契数列的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) = 0, F(1) = 1</span><br><span class="line">F(n) = F(n - 1) + F(n - 2), 对于 n &gt;= 2</span><br></pre></td></tr></table></figure>
<h3 id="【解题思路】">【解题思路】</h3>
<p>使用动态规划算法：</p>
<ol>
<li>定义一个数组 <code>dp</code>，其中 <code>dp[i]</code> 表示第 <code>i</code> 个斐波那契数。</li>
<li>初始化 <code>dp[0] = 0</code> 和 <code>dp[1] = 1</code>。</li>
<li>对于 <code>i</code> 从 2 到 <code>n</code>，计算 <code>dp[i] = dp[i - 1] + dp[i - 2]</code>。</li>
<li>返回 <code>dp[n]</code>。</li>
</ol>
<h3 id="【实现代码】">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">	dp[<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">	dp[<span class="number">1</span>]=<span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> n&lt;<span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> dp[n]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">2</span>;i&lt;=n;i++ &#123;</span><br><span class="line">		res:=dp[<span class="number">0</span>]+dp[<span class="number">1</span>]</span><br><span class="line">		dp[<span class="number">0</span>]=dp[<span class="number">1</span>]</span><br><span class="line">		dp[<span class="number">1</span>]=res</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="70-爬楼梯">70 爬楼梯</h2>
<h3 id="【题目描述】-2">【题目描述】</h3>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<h3 id="【解题思路】-2">【解题思路】</h3>
<p>使用动态规划算法：</p>
<ol>
<li>定义一个数组 <code>dp</code>，其中 <code>dp[i]</code> 表示爬到第 <code>i</code> 阶楼梯的方法数。</li>
<li>初始化 <code>dp[0] = 1</code> 和 <code>dp[1] = 1</code>。</li>
<li>对于 <code>i</code> 从 2 到 <code>n</code>，计算 <code>dp[i] = dp[i - 1] + dp[i - 2]</code>。</li>
<li>返回 <code>dp[n]</code>。</li>
</ol>
<h3 id="【实现代码】-2">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个数组来存储爬楼梯的方法数</span></span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数组</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算爬楼梯的方法数</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回爬到第 n 阶楼梯的方法数</span></span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="746-使用最小花费爬楼梯">746 使用最小花费爬楼梯</h2>
<h3 id="【题目描述】-3">【题目描述】</h3>
<p>给你一个整数数组 <code>cost</code>，其中 <code>cost[i]</code> 是第 <code>i</code> 阶台阶的成本。一旦你支付了第 <code>i</code> 阶台阶的成本，你就可以免费进入第 <code>i+1</code> 和第 <code>i+2</code> 阶台阶。也就是说，你可以以 <code>cost[i]</code> 的成本进入台阶 <code>i、i+1</code> 和 <code>i+2</code>。</p>
<p>你从第一阶台阶开始，并需要到达最后一步。请你返回到达最后一步的最小花费。</p>
<h3 id="【解题思路】-3">【解题思路】</h3>
<p>使用动态规划算法：</p>
<ol>
<li>定义一个数组 <code>dp</code>，其中 <code>dp[i]</code> 表示到达第 <code>i</code> 阶台阶的最小花费。</li>
<li>初始化 <code>dp[0] = 0</code> 和 <code>dp[1] = cost[0]</code>。</li>
<li>对于 <code>i</code> 从 2 到 <code>n</code>，计算 <code>dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])</code>。</li>
<li>返回 <code>dp[n]</code>。</li>
</ol>
<h3 id="【实现代码】-3">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minCostClimbingStairs</span><span class="params">(cost []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(cost)</span><br><span class="line">	<span class="comment">//代表到到达第i台阶需要的最小体力</span></span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">	dp[<span class="number">0</span>], dp[<span class="number">1</span>] = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">2</span>;i&lt;=n;i++ &#123;</span><br><span class="line">		dp[i] = min(cost[i<span class="number">-2</span>]+dp[i<span class="number">-2</span>], cost[i<span class="number">-1</span>]+dp[i<span class="number">-1</span>])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a,b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a&lt;b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="62-不同路径">62 不同路径</h2>
<h3 id="【题目描述】-4">【题目描述】</h3>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p>
<p>问：机器人有多少种不同的路径可以达到终点？</p>
<h3 id="【解题思路】-4">【解题思路】</h3>
<p>使用动态规划算法：</p>
<ol>
<li>定义一个二维数组 <code>dp</code>，其中 <code>dp[i][j]</code> 表示从左上角走到 <code>(i, j)</code> 的不同路径数。</li>
<li>初始化 <code>dp[0][0] = 1</code>，因为从左上角到左上角只有一条路径。</li>
<li>对于 <code>i</code> 从 1 到 <code>m</code>，计算 <code>dp[i][0] = dp[i-1][0]</code>，因为从左上角到 <code>(i, 0)</code> 的路径数等于从 <code>(i-1, 0)</code> 到 <code>(i, 0)</code> 的路径数。</li>
<li>对于 <code>j</code> 从 1 到 <code>n</code>，计算 <code>dp[0][j] = dp[0][j-1]</code>，因为从左上角到 <code>(0, j)</code> 的路径数等于从 <code>(0, j-1)</code> 到 <code>(0, j)</code> 的路径数。</li>
<li>对于 <code>i</code> 从 1 到 <code>m</code> 和 <code>j</code> 从 1 到 <code>n</code>，计算 <code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code>，因为从左上角到 <code>(i, j)</code> 的路径数等于从 <code>(i-1, j)</code> 到 <code>(i, j)</code> 的路径数加上从 <code>(i, j-1)</code> 到 <code>(i, j)</code> 的路径数。</li>
<li>返回 <code>dp[m-1][n-1]</code>。</li>
</ol>
<h3 id="【实现代码】-4">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uniquePaths</span><span class="params">(m <span class="type">int</span>, n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个二维数组来存储不同路径数</span></span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="type">int</span>, m)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数组</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算不同路径数</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; m; i++ &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回不同路径数</span></span><br><span class="line">    <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="63-不同路径-II">63 不同路径 II</h2>
<h3 id="【题目描述】-5">【题目描述】</h3>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p>
<p>现在，网格中某些格子被认为是障碍物，机器人无法进入。返回机器人到达右下角的不同路径数。</p>
<h3 id="【解题思路】-5">【解题思路】</h3>
<p>使用动态规划算法：</p>
<ol>
<li>定义一个二维数组 <code>dp</code>，其中 <code>dp[i][j]</code> 表示从左上角走到 <code>(i, j)</code> 的不同路径数。</li>
<li>初始化 <code>dp[0][0] = 1</code>，因为从左上角到左上角只有一条路径。</li>
<li>对于 <code>i</code> 从 1 到 <code>m</code>，如果 <code>grid[i-1][0] != 1</code>，则计算 <code>dp[i][0] = dp[i-1][0]</code>，否则 <code>dp[i][0] = 0</code>。</li>
<li>对于 <code>j</code> 从 1 到 <code>n</code>，如果 <code>grid[0][j-1] != 1</code>，则计算 <code>dp[0][j] = dp[0][j-1]</code>，否则 <code>dp[0][j] = 0</code>。</li>
<li>对于 <code>i</code> 从 1 到 <code>m</code> 和 <code>j</code> 从 1 到 <code>n</code>，如果 <code>grid[i][j] != 1</code>，则计算 <code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code>，否则 <code>dp[i][j] = 0</code>。</li>
<li>返回 <code>dp[m-1][n-1]</code>。</li>
</ol>
<h3 id="【实现代码】-5">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(obstacleGrid [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    m := <span class="built_in">len</span>(obstacleGrid)</span><br><span class="line">    n := <span class="built_in">len</span>(obstacleGrid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个二维数组来存储不同路径数</span></span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="type">int</span>, m)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数组</span></span><br><span class="line">    <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">0</span> &#123;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算不同路径数</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span> &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">        <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][j] == <span class="number">0</span> &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">0</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回不同路径数</span></span><br><span class="line">    <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="343-整数拆分">343 整数拆分</h2>
<h3 id="【题目描述】-6">【题目描述】</h3>
<p>给定一个正整数 <code>n</code>，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p>
<h3 id="【解题思路】-6">【解题思路】</h3>
<p>解决这个问题的关键是理解如何分割整数以获得最大的乘积。动态规划是解决这类问题的一种有效方法。</p>
<p>动态规划的基本思想是从底向上计算，先解决子问题，然后逐步解决更大的问题。对于整数拆分问题，我们可以定义一个数组 <code>dp</code>，其中 <code>dp[i]</code> 表示整数 <code>i</code> 拆分后得到的最大乘积。对于每一个整数 <code>i</code>，我们尝试将其拆分为 <code>j</code> 和 <code>i-j</code>（<code>1 &lt;= j &lt; i</code>），然后计算这两个数的乘积以及它们对应的 <code>dp</code> 值的乘积，取这些值中的最大值作为 <code>dp[i]</code> 的值。</p>
<p>初始化时，<code>dp[1]</code> 是1，因为按照题意，至少要拆分成两个正整数。</p>
<h3 id="【实现代码】-6">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">integerBreak</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">//拆分后得到的最大乘积</span></span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; i; j++ &#123;</span><br><span class="line">            <span class="comment">// dp[i]可以分为两种情况，一是j * (i-j),i-j 不拆分的最大乘积</span></span><br><span class="line">			<span class="comment">// j * dp[i-j] i-j 拆分下的最大乘积</span></span><br><span class="line">            dp[i] = max(dp[i], max(j*(i-j), j*dp[i-j]))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// max函数返回两个整数中的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(integerBreak(<span class="number">10</span>)) <span class="comment">// 输出示例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="96-不同的二叉搜索树">96 不同的二叉搜索树</h2>
<h3 id="【题目描述】-7">【题目描述】</h3>
<p>给定一个整数 <code>n</code>，求以 <code>1 ... n</code> 为节点组成的二叉搜索树有多少种？</p>
<h3 id="【解题思路】-7">【解题思路】</h3>
<p>这个问题可以通过动态规划的方式来解决。核心思想是，我们可以考虑以每个数 <code>i</code> 作为根节点，那么左子树的节点元素就是 <code>1 ... (i-1)</code>，右子树的节点元素就是 <code>(i+1) ... n</code>。因此，如果我们知道了左子树和右子树的组合数，我们就可以计算出总的树的数量。</p>
<p>定义一个数组 <code>dp</code>，其中 <code>dp[i]</code> 表示由 <code>i</code> 个连续的节点组成的二叉搜索树的数量。对于 <code>dp[i]</code>（假设根节点为 <code>k</code>），它等于左边的树的数量乘以右边的树的数量，即 <code>dp[k-1] * dp[i-k]</code>。所以，我们可以得到以下状态转移方程：<br>
$dp[i] = \sum_{k=1}^{i} dp[k-1] * dp[i-k]$<br>
初始化 <code>dp[0] = 1</code> 和 <code>dp[1] = 1</code>，因为当树为空或只有一个节点时，只有一种情况。</p>
<h3 id="【实现代码】-7">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numTrees</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>], dp[<span class="number">1</span>] = <span class="number">1</span>, <span class="number">1</span> <span class="comment">// 初始化dp[0]和dp[1]</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= i; j++ &#123;</span><br><span class="line">            dp[i] += dp[j<span class="number">-1</span>] * dp[i-j] <span class="comment">// 状态转移方程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="416-分割等和子集">416 分割等和子集</h2>
<h3 id="【题目描述】-8">【题目描述】</h3>
<p>给你一个只包含正整数的非空数组 <code>nums</code>。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<h3 id="【解题思路】-8">【解题思路】</h3>
<p>这个问题可以转化为一个经典的动态规划问题——0-1背包问题。具体来说，我们想知道数组中是否存在一些数字，它们的和等于数组总和的一半。这是因为只有当数组的总和为偶数，并且可以找到和为总和一半的子集时，才能将数组分割成和相等的两个子集。</p>
<p>动态规划的思想是，我们创建一个二维数组 <code>dp</code>，其中 <code>dp[i][j]</code> 表示从数组的 <code>[0, i]</code> 区间内选取若干个整数，是否存在一种选取方式使得被选取的整数和为 <code>j</code>。状态转移方程如下：</p>
<ul>
<li>如果不选取当前数字 <code>nums[i]</code>，那么是否存在一种选取方式使得当前的和为 <code>j</code>，取决于前一个状态 <code>dp[i-1][j]</code>；</li>
<li>如果选取当前数字 <code>nums[i]</code>，那么是否存在一种选取方式使得当前的和为 <code>j</code>，取决于 <code>dp[i-1][j-nums[i]]</code>。</li>
</ul>
<p>初始化 <code>dp[0][nums[0]] = true</code>，因为选取 <code>nums[0]</code> 就可以得到和为 <code>nums[0]</code> 的子集。最终答案为 <code>dp[n-1][sum/2]</code>，其中 <code>n</code> 是数组 <code>nums</code> 的长度，<code>sum</code> 是数组 <code>nums</code> 的总和。</p>
<h3 id="【实现代码】-8">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canPartition</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	total := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> index := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		total += nums[index]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> total%<span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	packSize := total / <span class="number">2</span></span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">int</span>, packSize+<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := packSize; j &gt;= nums[i]; j-- &#123;</span><br><span class="line">			dp[j] = max(dp[j], dp[j-nums[i]]+nums[i])</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 剪枝</span></span><br><span class="line">		<span class="keyword">if</span> dp[<span class="keyword">package</span>] == <span class="keyword">package</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[packSize] == packSize</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1049-最后一块石头的重量-II">1049 最后一块石头的重量 II</h2>
<h3 id="【题目描述】-9">【题目描述】</h3>
<p>有一堆石头，每块石头的重量都是正整数。每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p>
<ul>
<li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li>
<li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头的新重量为 <code>y-x</code>。</li>
</ul>
<p>最后，最多只会剩下一块石头。返回此石头的最小可能重量。如果没有石头剩下，就返回 0。</p>
<h3 id="【解题思路】-9">【解题思路】</h3>
<p>这个问题可以转化为一个类似背包问题的动态规划问题。我们可以将石头分成两堆，尽量让这两堆石头的总重量相接近。问题就变成了从石头中选取一些石头，使得它们的总重量尽可能接近石头总重量的一半。</p>
<p>我们定义一个动态规划数组 <code>dp</code>，其中 <code>dp[i]</code> 表示重量为 <code>i</code> 是否可以由数组中的石头组成。我们遍历石头数组，对于每块石头，更新 <code>dp</code> 数组的值。最终，我们检查 <code>dp</code> 数组，从总重量的一半开始向下查找，第一个为 <code>true</code> 的位置就表示最接近总重量一半的重量。</p>
<h3 id="【实现代码】-9">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把一堆石头分成两堆,求两堆石头重量差最小值 进一步分析：要让差值小,两堆石头的重量都要接近sum/2;</span></span><br><span class="line"><span class="comment">// 即容量为sum/2下的最大重量</span></span><br><span class="line"><span class="comment">// @doc https://leetcode.cn/problems/last-stone-weight-ii/solutions/805162/yi-pian-wen-zhang-chi-tou-bei-bao-wen-ti-5lfv/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lastStoneWeightII</span><span class="params">(stones []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// dp[i][j]从前i个物品中选放在容量为j的背包的最大值</span></span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, weight := <span class="keyword">range</span> stones &#123;</span><br><span class="line">		sum += weight</span><br><span class="line">	&#125;</span><br><span class="line">	avg := sum / <span class="number">2</span></span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">int</span>, avg+<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(stones); i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := avg; j &gt;= stones[i]; j-- &#123;</span><br><span class="line">			dp[j] = max(dp[j], dp[j-stones[i]]+stones[i])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum - dp[avg]*<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="494-目标和">494 目标和</h2>
<h3 id="【题目描述】-10">【题目描述】</h3>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>target</code>。</p>
<p>向数组中的每个整数前添加 <code>'+'</code> 或 <code>'-'</code>，然后串联起所有整数，可以构造一个表达式。</p>
<p>返回可以通过上述操作得到该目标数的不同表达式的数量。</p>
<h3 id="【解题思路】-10">【解题思路】</h3>
<p>这个问题实质上是一个组合问题，可以转化为一个动态规划问题，类似于背包问题。我们可以将所有数字分为两部分，一部分数字总和为 <code>P</code>，另一部分数字总和为 <code>N</code>，其中 <code>P</code> 使用 <code>'+'</code> 操作，<code>N</code> 使用 <code>'-'</code> 操作。因此，我们得到等式 <code>P - N = target</code>。同时，我们知道 <code>P + N = sum</code>，其中 <code>sum</code> 是数组 <code>nums</code> 的所有元素之和。联立这两个等式，可以解得 <code>P = (target + sum) / 2</code>。问题转化为了从数组 <code>nums</code> 中选取若干个元素，使得这些元素的和为 <code>(target + sum) / 2</code>，计算有多少种选取方式。</p>
<p>动态规划的状态定义为 <code>dp[i][j]</code>，表示从数组的 <code>[0, i]</code> 区间内选取若干个整数，是否存在一种选取方式使得被选取的整数的和为 <code>j</code>。状态转移方程为 <code>dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i]]</code>。</p>
<h3 id="【实现代码】-10">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findTargetSumWays</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        sum += num</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> abs(target) &gt; sum || (target+sum)%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    target = (target + sum) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, target+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// 初始化，没有选择任何元素时，和为0的方式有1种</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">for</span> j := target; j &gt;= num; j-- &#123;</span><br><span class="line">            dp[j] += dp[j-num]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">abs</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="474-一和零">474 一和零</h2>
<h3 id="【题目描述】-11">【题目描述】</h3>
<p>给你一个二进制字符串数组 <code>strs</code> 和两个整数 <code>m</code> 和 <code>n</code>。</p>
<p>请你找出并返回 <code>strs</code> 的最大子集的大小，该子集中最多有 <code>m</code> 个 0 和 <code>n</code> 个 1。</p>
<p>如果 <code>x</code> 的所有元素也是 <code>y</code> 的元素，集合 <code>x</code> 是集合 <code>y</code> 的子集。</p>
<h3 id="【解题思路】-11">【解题思路】</h3>
<p>这个问题可以看作是一个二维的0-1背包问题。这里有两个限制条件（0的数量不超过<code>m</code>，1的数量不超过<code>n</code>），我们的目标是在这两个限制条件下，选择尽可能多的字符串。</p>
<p>动态规划的状态可以定义为 <code>dp[i][j]</code>，表示使用 <code>i</code> 个 0 和 <code>j</code> 个 1 时能构成的最大子集大小。状态转移方程为：<code>dp[i][j] = max(dp[i][j], dp[i-zero][j-one] + 1)</code>。这里 <code>zero</code> 和 <code>one</code> 分别表示当前字符串中0和1的数量。</p>
<p>算法的基本思路是遍历每个字符串，对于每个字符串，更新动态规划表格。由于更新当前状态只依赖于之前的状态，为了避免覆盖之前的状态，我们需要从大到小更新 <code>dp[i][j]</code>。</p>
<h3 id="【实现代码】-11">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaxForm</span><span class="params">(strs []<span class="type">string</span>, m <span class="type">int</span>, n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="type">int</span>, m+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, str := <span class="keyword">range</span> strs &#123;</span><br><span class="line">        zero, one := countZeroAndOne(str)</span><br><span class="line">        <span class="keyword">for</span> i := m; i &gt;= zero; i-- &#123;</span><br><span class="line">            <span class="keyword">for</span> j := n; j &gt;= one; j-- &#123;</span><br><span class="line">                dp[i][j] = max(dp[i][j], dp[i-zero][j-one]+<span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// countZeroAndOne 计算一个字符串中0和1的数量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countZeroAndOne</span><span class="params">(str <span class="type">string</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">    zero, one := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, char := <span class="keyword">range</span> str &#123;</span><br><span class="line">        <span class="keyword">if</span> char == <span class="string">&#x27;0&#x27;</span> &#123;</span><br><span class="line">            zero++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            one++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> zero, one</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// max 返回两个整数中的较大值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="518-零钱兑换-II">518 零钱兑换 II</h2>
<h3 id="【题目描述】-12">【题目描述】</h3>
<p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p>
<p>请你计算并返回可以凑成总金额所需的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code>。</p>
<p>假设每一种面额的硬币有无限个。</p>
<p>题目数据保证结果符合 32 位带符号整数。</p>
<h3 id="【解题思路】-12">【解题思路】</h3>
<p>这个问题可以用动态规划（Dynamic Programming，DP）来解决。我们可以维护一个一维的DP数组 <code>dp</code>，其中 <code>dp[i]</code> 表示组成金额 <code>i</code> 的硬币组合数。初始时，<code>dp[0] = 1</code>，因为组成金额0的方式只有一种，即不选择任何硬币。</p>
<p>对于每一种硬币，我们遍历 <code>dp</code> 数组，更新组成各个金额的组合数。对于每个金额 <code>i</code> 和每个硬币 <code>coin</code>，如果 <code>i</code> 大于等于 <code>coin</code> 的面额，则 <code>dp[i] += dp[i - coin]</code>。这里 <code>dp[i - coin]</code> 表示在当前硬币面额基础上，组成金额 <code>i - coin</code> 的组合数目，所以将其加到 <code>dp[i]</code> 上，从而更新组成金额 <code>i</code> 的组合数。</p>
<h3 id="【实现代码】-12">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(amount <span class="type">int</span>, coins []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, amount+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// 初始化，金额为0的组合数为1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//是组合问题，所以是先物品再背包</span></span><br><span class="line">    <span class="keyword">for</span> _, coin := <span class="keyword">range</span> coins &#123;</span><br><span class="line">        <span class="keyword">for</span> i := coin; i &lt;= amount; i++ &#123;</span><br><span class="line">            dp[i] += dp[i-coin]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[amount]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="377-组合总和-Ⅳ">377 组合总和 Ⅳ</h2>
<h3 id="【题目描述】-13">【题目描述】</h3>
<p>给定一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> 和一个目标整数 <code>target</code>，请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的组合的个数。</p>
<p>题目数据保证答案符合 32 位整数范围。</p>
<h3 id="【解题思路】-13">【解题思路】</h3>
<p>这个问题可以通过动态规划来解决。我们可以定义一个数组 <code>dp</code>，其中 <code>dp[i]</code> 表示达到总和为 <code>i</code> 的组合个数。初始状态 <code>dp[0] = 1</code>，因为总和为0的方式只有一种，即不选择任何元素。</p>
<p>接下来，我们对于每一个目标和 <code>i</code>（从1到<code>target</code>），都尝试遍历数组 <code>nums</code> 中的每一个数 <code>num</code>，如果 <code>i - num &gt;= 0</code>，则说明我们可以使用 <code>num</code> 来组成总和 <code>i</code>。因此，我们可以把组成总和为 <code>i - num</code> 的方式数加到 <code>dp[i]</code> 上，即 <code>dp[i] += dp[i - num]</code>。</p>
<p>这样，我们从 <code>1</code> 遍历到 <code>target</code>，最终 <code>dp[target]</code> 就是我们想要的答案。</p>
<h3 id="【实现代码】-13">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum4</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, target+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// 初始化，只有一种方式组成总和为0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//排列问题只能先背包再物品</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= target; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">            <span class="keyword">if</span> i-num &gt;= <span class="number">0</span> &#123;</span><br><span class="line">                dp[i] += dp[i-num]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[target]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="322-零钱兑换">322 零钱兑换</h2>
<h3 id="【题目描述】-14">【题目描述】</h3>
<p>给你一个整数数组 <code>coins</code>，表示不同面额的硬币；以及一个整数 <code>amount</code>，表示总金额。计算并返回可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code>。你可以认为每种硬币的数量是无限的。</p>
<h3 id="【解题思路】-14">【解题思路】</h3>
<p>这个问题是一个典型的动态规划问题。我们可以创建一个数组 <code>dp</code> 来保存达到每个金额所需的最小硬币数。<code>dp[i]</code> 表示达到金额 <code>i</code> 所需的最小硬币数。</p>
<p>初始时，<code>dp[0] = 0</code> 因为金额为0时不需要任何硬币。对于所有其他金额，我们可以初始化为一个大数，例如 <code>amount + 1</code>，代表无法达到该金额。</p>
<p>然后，我们遍历每个金额，对于每个金额，我们又遍历每种硬币，如果当前硬币面额不超过当前金额，我们更新 <code>dp[i]</code> 为 <code>min(dp[i], dp[i - coin] + 1)</code>。这里 <code>dp[i - coin] + 1</code> 表示使用这种硬币之前的最小硬币数加上这一枚硬币。</p>
<p>最后，我们检查 <code>dp[amount]</code> 的值，如果它没有被更新过（即还是初始值 <code>amount + 1</code>），则表示无法达到该金额，返回 <code>-1</code>。否则，返回 <code>dp[amount]</code>。</p>
<h3 id="【实现代码】-14">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coinChange</span><span class="params">(coins []<span class="type">int</span>, amount <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, amount+<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 初始化dp数组，除了dp[0]为0外，其余设为一个大数</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= amount; i++ &#123;</span><br><span class="line">        dp[i] = amount + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= amount; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> _, coin := <span class="keyword">range</span> coins &#123;</span><br><span class="line">            <span class="keyword">if</span> coin &lt;= i &#123;</span><br><span class="line">                dp[i] = min(dp[i], dp[i-coin]+<span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> dp[amount] &gt; amount &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span> <span class="comment">// 表示无法凑成该金额</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// min 返回两个整数中的较小值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="279-完全平方数">279 完全平方数</h2>
<h3 id="【题目描述】-15">【题目描述】</h3>
<p>给定正整数 <code>n</code>，找到若干个完全平方数（例如，1, 4, 9, 16, …）使得它们的和等于 <code>n</code>。你需要让组成和的完全平方数的个数最少。</p>
<h3 id="【解题思路】-15">【解题思路】</h3>
<p>这个问题可以通过动态规划来解决。我们创建一个数组 <code>dp</code>，其中 <code>dp[i]</code> 表示数字 <code>i</code> 最少可以由几个完全平方数相加组成。初始时，<code>dp[0] = 0</code>，因为数字0不需要任何完全平方数就能组成。</p>
<p>对于每个数字 <code>i</code>（从1到 <code>n</code>），我们初始化 <code>dp[i]</code> 为一个较大的数，例如 <code>i</code> 自身（因为最坏的情况下，<code>i</code> 可以由 <code>i</code> 个1相加组成）。然后，我们遍历所有小于等于 <code>i</code> 的完全平方数 <code>j*j</code>，更新 <code>dp[i]</code> 为 <code>min(dp[i], dp[i - j*j] + 1)</code>。这里 <code>dp[i - j*j] + 1</code> 表示数字 <code>i</code> 可以由数字 <code>i - j*j</code> 加上一个完全平方数 <code>j*j</code> 组成，因此更新 <code>dp[i]</code> 为这两者之间的较小值。</p>
<p>最终，<code>dp[n]</code> 就是答案，即数字 <code>n</code> 最少可以由几个完全平方数组成。</p>
<h3 id="【实现代码】-15">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numSquares</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">		<span class="comment">// 10000是最大值</span></span><br><span class="line">		dp[i] = <span class="number">100001</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//完全背包</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">		<span class="comment">//排列问题 先遍历物品再遍历背包</span></span><br><span class="line">		<span class="keyword">for</span> j := i * i; j &lt;= n; j++ &#123;</span><br><span class="line">			dp[j] = min(dp[j], dp[j-i*i]+<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// min 返回两个整数中的较小值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="139-单词拆分">139 单词拆分</h2>
<h3 id="【题目描述】-16">【题目描述】</h3>
<p>给你一个非空字符串 <code>s</code> 和一个包含非空单词的列表 <code>wordDict</code>，判定 <code>s</code> 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p>说明：</p>
<ul>
<li>拆分时可以重复使用字典中的单词。</li>
<li>你可以假设字典中没有重复的单词。</li>
</ul>
<h3 id="【解题思路】-16">【解题思路】</h3>
<p>这个问题可以通过动态规划来解决。我们定义一个布尔数组 <code>dp</code>，其中 <code>dp[i]</code> 表示字符串 <code>s</code> 的前 <code>i</code> 个字符（<code>s[0...i-1]</code>）能否被分割成一个或多个字典中出现的单词。初始时，<code>dp[0]</code> 为 <code>true</code>，因为空字符串总是字典中单词的有效组合。</p>
<p>接下来，对于字符串 <code>s</code> 的每一个位置 <code>i</code>（从1到字符串长度），我们遍历 <code>i</code> 之前的所有位置 <code>j</code>（从0到 <code>i-1</code>），检查 <code>s[j...i-1]</code>（即从第 <code>j</code> 个字符到第 <code>i-1</code> 个字符的子串）是否是字典中的单词，并且 <code>dp[j]</code> 是否为 <code>true</code>。如果这两个条件都满足，那么说明 <code>s[0...i-1]</code> 可以被分割成字典中的单词，我们将 <code>dp[i]</code> 设置为 <code>true</code>。</p>
<p>最终，<code>dp[s.length]</code> 的值就是我们想要的答案，它表示整个字符串 <code>s</code> 能否被分割成字典中的单词。</p>
<h3 id="【实现代码】-16">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wordBreak</span><span class="params">(s <span class="type">string</span>, wordDict []<span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    wordDictSet := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> _, word := <span class="keyword">range</span> wordDict &#123;</span><br><span class="line">        wordDictSet[word] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(s)+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span> <span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> dp[j] &amp;&amp; wordDictSet[s[j:i]] &#123;</span><br><span class="line">                dp[i] = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="built_in">len</span>(s)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="198-打家劫舍">198 打家劫舍</h2>
<h3 id="【题目描述】-17">【题目描述】</h3>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<h3 id="【解题思路】-17">【解题思路】</h3>
<p>这个问题可以使用动态规划来解决。我们可以创建一个数组 <code>dp</code>，其中 <code>dp[i]</code> 表示从第 <code>0</code> 个房间到第 <code>i</code> 个房间可以偷窃到的最高金额。对于每个房间 <code>i</code>，小偷有两个选择：偷窃或不偷窃。</p>
<ul>
<li>如果小偷选择偷窃房间 <code>i</code>，那么他不能偷窃房间 <code>i-1</code>，所以他可以偷窃到的最高金额是房间 <code>i</code> 的金额加上 <code>dp[i-2]</code>。</li>
<li>如果小偷选择不偷窃房间 <code>i</code>，那么他可以偷窃到的最高金额就是 <code>dp[i-1]</code>。</li>
</ul>
<p>因此，我们可以得到状态转移方程：<code>dp[i] = max(dp[i-1], nums[i] + dp[i-2])</code>。</p>
<p>我们从第一个房间开始，使用这个状态转移方程来计算每个房间可以偷窃到的最高金额，最后 <code>dp[n-1]</code> 就是我们想要的答案，其中 <code>n</code> 是房间的总数。</p>
<h3 id="【实现代码】-17">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rob</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">    dp[<span class="number">1</span>] = max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt; n; i++ &#123;</span><br><span class="line">        dp[i] = max(dp[i<span class="number">-1</span>], nums[i]+dp[i<span class="number">-2</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="213-打家劫舍-II">213 打家劫舍 II</h2>
<h3 id="【题目描述】-18">【题目描述】</h3>
<p>这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是相邻的。再次给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<h3 id="【解题思路】-18">【解题思路】</h3>
<p>这道题是打家劫舍的升级版，由于房屋围成一圈的特殊结构，我们不能同时偷窃第一个房屋和最后一个房屋。这就意味着有两种情况：一种是偷窃第一个房屋到倒数第二个房屋，另一种是偷窃第二个房屋到最后一个房屋。我们只需要分别计算这两种情况下可以偷窃到的最高金额，然后取二者的较大值即可。</p>
<p>我们可以复用打家劫舍 I 的逻辑来计算给定起始点和结束点的最大偷窃金额。具体来说，我们定义一个辅助函数 <code>robRange</code>，它接受房屋金额数组 <code>nums</code> 和两个索引 <code>start</code> 和 <code>end</code>，计算在 <code>[start, end]</code> 范围内可以偷窃到的最高金额。</p>
<p>最终，我们比较 <code>robRange(nums, 0, n-2)</code> 和 <code>robRange(nums, 1, n-1)</code> 的结果（其中 <code>n</code> 是房屋的总数），返回二者中的较大值。</p>
<h3 id="【实现代码】-18">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rob</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="keyword">if</span> n &lt;= <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> n &lt;= <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> max(doRob(nums[<span class="number">0</span>:n<span class="number">-1</span>]), doRob(nums[<span class="number">1</span>:n]))</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doRob</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="keyword">if</span> n&lt;=<span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">	dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">	dp[<span class="number">1</span>] = max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">2</span>;i&lt;n;i++ &#123;</span><br><span class="line">		dp[i] = max(dp[i<span class="number">-2</span>]+nums[i],dp[i<span class="number">-1</span>])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[n<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="337-打家劫舍-III">337 打家劫舍 III</h2>
<h3 id="【题目描述】-19">【题目描述】</h3>
<p>在上次打劫完一条街道之后和一圈房屋后，小偷再次发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列形成了一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p>
<p>计算在不触动警报的情况下，小偷一夜之内能够偷窃到的最高金额。</p>
<h3 id="【解题思路】-19">【解题思路】</h3>
<p>这是一个经典的动态规划问题，可以用树形动态规划的方式来解决。对于树上的每个节点，有两种状态：偷或不偷。</p>
<ul>
<li>如果偷当前节点，那么两个子节点就不能偷；</li>
<li>如果不偷当前节点，那么两个子节点可以偷，也可以不偷（取决于哪种方案能得到更大的金额）。</li>
</ul>
<p>因此，对于每个节点，我们需要返回两个值：一个是偷这个节点能得到的最大金额，另一个是不偷这个节点能得到的最大金额。</p>
<p>我们可以用递归的方式，自底向上地解决这个问题。</p>
<h3 id="【实现代码】-19">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// TreeNode is a binary tree node.</span></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rob returns the maximum amount of money the thief can rob without alerting the police.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rob</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    res := dfs(root)</span><br><span class="line">    <span class="keyword">return</span> max(res[<span class="number">0</span>], res[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dfs returns two values, the first is the maximum amount of money when robbing the current node,</span></span><br><span class="line"><span class="comment">// and the second is the maximum amount when not robbing the current node.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(node *TreeNode)</span></span> [<span class="number">2</span>]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">2</span>]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    left := dfs(node.Left)</span><br><span class="line">    right := dfs(node.Right)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rob the current node, cannot rob its children</span></span><br><span class="line">    rob := node.Val + left[<span class="number">1</span>] + right[<span class="number">1</span>]</span><br><span class="line">    <span class="comment">// Do not rob the current node, choose the maximum amount of its children</span></span><br><span class="line">    notRob := max(left[<span class="number">0</span>], left[<span class="number">1</span>]) + max(right[<span class="number">0</span>], right[<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [<span class="number">2</span>]<span class="type">int</span>&#123;rob, notRob&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="121-买卖股票的最佳时机">121 买卖股票的最佳时机</h2>
<h3 id="【题目描述】-20">【题目描述】</h3>
<p>给定一个数组，它的第 <code>i</code> 个元素是一支给定股票第 <code>i</code> 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意：你不能在买入股票前卖出股票。</p>
<h3 id="【解题思路】-20">【解题思路】</h3>
<p>动态规划是一种通过把原问题分解为相对简单的子问题的方式来求解复杂问题的方法。对于本题，我们可以维护两个变量，<code>minPrice</code>和<code>maxProfit</code>。<code>minPrice</code>是到当前价格为止的最低股票价格，<code>maxProfit</code>是我们可以获得的最大利润。</p>
<p>我们初始化<code>minPrice</code>为<code>int</code>的最大值，<code>maxProfit</code>为0。然后遍历价格数组，对于每个价格，我们首先更新<code>minPrice</code>，使其为当前价格和之前的<code>minPrice</code>中的较小值。然后，我们计算当前价格卖出的利润（当前价格减去<code>minPrice</code>），如果这个利润比我们之前记录的<code>maxProfit</code>要大，我们就更新<code>maxProfit</code>。</p>
<p>通过这种方法，我们只需要遍历一次数组，就可以找到最低购买价格和最高卖出价格之间的最大差值，即最大利润。</p>
<h3 id="【实现代码】-20">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">//只能进行一次交易</span></span><br><span class="line">	<span class="comment">//dp[i][0]在第i天交易完后手上有股票的最大利润</span></span><br><span class="line">	<span class="comment">//dp[i][1]在第i天交易完后手上没有股票的最大利润</span></span><br><span class="line">	dp := <span class="built_in">make</span>([][<span class="number">2</span>]<span class="type">int</span>, <span class="built_in">len</span>(prices))</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="built_in">len</span>(prices);i++ &#123;</span><br><span class="line">		<span class="comment">//持有 昨天持有，今天买入的持有</span></span><br><span class="line">		dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], -prices[i])</span><br><span class="line">		<span class="comment">//不持有</span></span><br><span class="line">		dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>]+prices[i])</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dp[<span class="built_in">len</span>(prices)<span class="number">-1</span>][<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//贪心</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(prices) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    minPrice := prices[<span class="number">0</span>]</span><br><span class="line">    maxProfit := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(prices); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> prices[i] &lt; minPrice &#123;</span><br><span class="line">            minPrice = prices[i]</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> prices[i] - minPrice &gt; maxProfit &#123;</span><br><span class="line">            maxProfit = prices[i] - minPrice</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="122-买卖股票的最佳时机-II">122 买卖股票的最佳时机 II</h2>
<h3 id="【题目描述】-21">【题目描述】</h3>
<p>给定一个数组 prices ，其中 prices[i] 表示股票第 i 天的价格。<br>
在每一天，你可能会决定购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以购买它，然后在 同一天 出售。<br>
返回 你能获得的 最大 利润 。</p>
<h3 id="【解题思路】-21">【解题思路】</h3>
<p>这道题可以使用动态规划来解决。我们可以定义两个变量：</p>
<ol>
<li><code>hold</code>：表示当前持有股票时的最大利润</li>
<li><code>notHold</code>：表示当前不持有股票时的最大利润</li>
</ol>
<p>对于每一天，我们可以选择持有股票或不持有股票，并更新相应的最大利润：</p>
<ol>
<li>如果选择持有股票，那么最大利润为前一天不持有股票的利润减去当天股票的价格，即 <code>hold = notHold - prices[i]</code></li>
<li>如果选择不持有股票，那么最大利润为前一天持有股票的利润加上当天股票的价格，即 <code>notHold = max(notHold, hold + prices[i])</code></li>
</ol>
<p>最终，不持有股票时的最大利润即为所求的最大利润。</p>
<h3 id="【实现代码】-21">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123; </span><br><span class="line">	<span class="comment">//0 第i天手上持有股票，1没有股票</span></span><br><span class="line">	<span class="comment">//dp[i][0]</span></span><br><span class="line">	n := <span class="built_in">len</span>(prices)</span><br><span class="line">	dp := <span class="built_in">make</span>([][<span class="number">2</span>]<span class="type">int</span>, n)</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;n;i++ &#123;</span><br><span class="line">		dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>]-prices[i])</span><br><span class="line">		dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>]+prices[i])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//不持有股票肯定收益更大</span></span><br><span class="line">	<span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//贪心</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123; </span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(prices);i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> prices[i]-prices[i<span class="number">-1</span>] &gt; <span class="number">0</span>&#123;</span><br><span class="line">			<span class="comment">//累加利润为正的和就是最大利润</span></span><br><span class="line">			res += prices[i]-prices[i<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="123-买卖股票的最佳时机-III">123 买卖股票的最佳时机 III</h2>
<p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。<br>
设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。<br>
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>
使用三维数组的动态规划来解决“买卖股票的最佳时机 III”问题，可以帮助我们更清晰地理解状态之间的转移关系。在这种方法中，我们将使用一个三维数组 <code>dp</code> 来存储到达每一天，进行了0次、1次或2次交易，并且当前是否持有股票的最大利润。</p>
<h3 id="【解题思路】-22">【解题思路】</h3>
<ol>
<li>
<p><strong>状态定义：</strong> <code>dp[i][j][k]</code> 表示在第i天，已经进行了j次交易（j可以取0, 1, 2），当前持有状态为k时（k可以取0或1，0表示不持有，1表示持有）的最大利润。</p>
</li>
<li>
<p><strong>状态转移：</strong></p>
<ul>
<li>第i天结束后不持有股票的情况（k=0）：
<ul>
<li>前一天也不持有股票，今天什么也没做：<code>dp[i-1][j][0]</code></li>
<li>前一天持有股票，今天卖出了：<code>dp[i-1][j-1][1] + prices[i]</code></li>
</ul>
</li>
<li>第i天结束后持有股票的情况（k=1）：
<ul>
<li>前一天也持有股票，今天什么也没做：<code>dp[i-1][j][1]</code></li>
<li>前一天不持有股票，今天买入了：<code>dp[i-1][j][0] - prices[i]</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>初始化：</strong></p>
<ul>
<li><code>dp[0][0][0] = 0</code> 第0天，0次交易，不持有股票，利润为0。</li>
<li><code>dp[0][0][1] = -prices[0]</code> 第0天，0次交易，持有股票，利润为-prices[0]。</li>
<li>对于所有j &gt; 0，<code>dp[0][j][0] = 0</code>，<code>dp[0][j][1] = -prices[0]</code>。</li>
</ul>
</li>
<li>
<p><strong>目标：</strong> <code>max(dp[n-1][j][0])</code>，其中n为天数，j可以取0, 1, 2。</p>
</li>
</ol>
<h3 id="【实现代码】-22">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(prices)</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	dp := <span class="built_in">make</span>([][][]<span class="type">int</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">		dp[i] = <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">3</span>) <span class="comment">// 0, 1, 2次交易</span></span><br><span class="line">		<span class="keyword">for</span> j := <span class="keyword">range</span> dp[i] &#123;</span><br><span class="line">			dp[i][j] = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>) <span class="comment">// 持有状态：0不持有，1持有</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 初始化</span></span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">2</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">2</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt;= <span class="number">2</span>; j++ &#123;</span><br><span class="line">			dp[i][j][<span class="number">0</span>] = dp[i<span class="number">-1</span>][j][<span class="number">0</span>]</span><br><span class="line">			<span class="keyword">if</span> j &gt; <span class="number">0</span> &#123;</span><br><span class="line">				dp[i][j][<span class="number">0</span>] = max(dp[i][j][<span class="number">0</span>], dp[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">1</span>]+prices[i])</span><br><span class="line">			&#125;</span><br><span class="line">			dp[i][j][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][j][<span class="number">1</span>], dp[i<span class="number">-1</span>][j][<span class="number">0</span>]-prices[i])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> max(dp[n<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>], max(dp[n<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[n<span class="number">-1</span>][<span class="number">2</span>][<span class="number">0</span>]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	prices := []<span class="type">int</span>&#123;<span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>&#125;</span><br><span class="line">	fmt.Println(maxProfit(prices)) <span class="comment">// 输出: 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="188-买卖股票的最佳时机-IV">188 买卖股票的最佳时机 IV</h2>
<h3 id="【题目描述】-22">【题目描述】</h3>
<p>给定一个整数数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 是一支给定的股票在第 <code>i</code> 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>k</strong> 笔交易。</p>
<p><strong>注意：</strong> 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<h3 id="【解题思路】-23">【解题思路】</h3>
<p>这个问题是“买卖股票的最佳时机”系列问题中的一个更通用的形式。我们可以使用动态规划（DP）算法来解决这个问题。</p>
<p>动态规划的核心思想在于找出状态转移方程。对于本题，我们可以设 <code>dp[i][j][0]</code> 表示在第 <code>i</code> 天结束时，最多完成 <code>j</code> 笔交易，并且当前不持有股票时的最大利润；<code>dp[i][j][1]</code> 表示在第 <code>i</code> 天结束时，最多完成 <code>j</code> 笔交易，并且当前持有股票时的最大利润。</p>
<p>状态转移方程如下：</p>
<ul>
<li><code>dp[i][j][0] = max(dp[i-1][j][0], dp[i-1][j][1] + prices[i])</code>：表示第 <code>i</code> 天不持有股票的情况下的最大利润，可以从前一天就不持有股票转移过来，或者是前一天持有股票，但在今天卖出了。</li>
<li><code>dp[i][j][1] = max(dp[i-1][j][1], dp[i-1][j-1][0] - prices[i])</code>：表示第 <code>i</code> 天持有股票的情况下的最大利润，可以从前一天就持有股票转移过来，或者是前一天不持有股票，但在今天买入了。</li>
</ul>
<p>初始状态：对于第 <code>0</code> 天，不持有股票的利润是 <code>0</code>；持有股票的利润是 <code>-prices[0]</code>。</p>
<h3 id="【实现代码】-23">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(k <span class="type">int</span>, prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(prices)</span><br><span class="line">	dp:=<span class="built_in">make</span>([][][<span class="number">2</span>]<span class="type">int</span>, n)</span><br><span class="line">	<span class="comment">//注意是k+1 不是k</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;n;i++ &#123;</span><br><span class="line">		dp[i] = <span class="built_in">make</span>([][<span class="number">2</span>]<span class="type">int</span>, k+<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//dp[i天][j次交易][0:持有，1：不持有]</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=k;i++ &#123;</span><br><span class="line">		dp[<span class="number">0</span>][i][<span class="number">0</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;n;i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j:=<span class="number">1</span>;j&lt;=k;j++ &#123;</span><br><span class="line">			<span class="comment">//持有</span></span><br><span class="line">			dp[i][j][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][j][<span class="number">0</span>], dp[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">1</span>]-prices[i])</span><br><span class="line">			<span class="comment">//不持有</span></span><br><span class="line">			dp[i][j][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][j][<span class="number">1</span>], dp[i<span class="number">-1</span>][j][<span class="number">0</span>]+prices[i])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[n<span class="number">-1</span>][k][<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="309-最佳买卖股票时机含冷冻期">309 最佳买卖股票时机含冷冻期</h2>
<h3 id="【题目描述】-23">【题目描述】</h3>
<p>给定一个整数数组，其中第 <code>i</code> 个元素代表了第 <code>i</code> 天的股票价格。设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<ul>
<li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li>
<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>
</ul>
<h3 id="【解题思路】-24">【解题思路】</h3>
<p>为了使用二维数组简化动态规划的实现，我们可以定义一个<code>dp</code>数组，其中<code>dp[i][j]</code>表示第<code>i</code>天结束时的最大收益，<code>j</code>有三种状态，分别表示：</p>
<ul>
<li><code>0</code>：持有股票（买入股票或保持前一天的持有状态）</li>
<li><code>1</code>：不持有股票，处于冷冻期（即刚刚卖出股票）</li>
<li><code>2</code>：不持有股票，不处于冷冻期（可以买入股票）</li>
</ul>
<p>状态转移方程如下：</p>
<ul>
<li>当<code>j=0</code>时，<code>dp[i][0] = max(dp[i-1][0], dp[i-1][2] - prices[i])</code>，表示第<code>i</code>天持有股票的最大收益。</li>
<li>当<code>j=1</code>时，<code>dp[i][1] = dp[i-1][0] + prices[i]</code>，表示第<code>i</code>天卖出股票后的最大收益。</li>
<li>当<code>j=2</code>时，<code>dp[i][2] = max(dp[i-1][2], dp[i-1][1])</code>，表示第<code>i</code>天不持有股票且不处于冷冻期的最大收益。</li>
</ul>
<p>初始状态设定：</p>
<ul>
<li><code>dp[0][0] = -prices[0]</code>，第一天买入股票</li>
<li><code>dp[0][1] = 0</code>，第一天不可能处于冷冻期</li>
<li><code>dp[0][2] = 0</code>，第一天不买股票</li>
</ul>
<p>最终，我们需要的答案是<code>max(dp[n-1][1], dp[n-1][2])</code>，即最后一天不持有股票的最大收益。</p>
<h3 id="【实现代码】-24">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">//dp[第i天]【0：持有，1：不持有】的最大利润</span></span><br><span class="line">	n := <span class="built_in">len</span>(prices)</span><br><span class="line">	dp := <span class="built_in">make</span>([][<span class="number">2</span>]<span class="type">int</span>, n)</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">	<span class="comment">//卖出, 冷冻期, 买入</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;n;i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> i == <span class="number">1</span> &#123;</span><br><span class="line">			dp[i][<span class="number">0</span>] = max(dp[<span class="number">0</span>][<span class="number">0</span>], -prices[<span class="number">1</span>])</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-2</span>][<span class="number">1</span>]-prices[i])</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>]+prices[i])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">1</span>]</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	prices := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Max profit:&quot;</span>, maxProfit(prices))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="714-买卖股票的最佳时机含手续费">714 买卖股票的最佳时机含手续费</h2>
<h3 id="【题目描述】-24">【题目描述】</h3>
<p>给定一个整数数组 <code>prices</code>，其中第 <code>i</code> 个元素代表了第 <code>i</code> 天的股票价格；非负整数 <code>fee</code> 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每笔交易都需要支付手续费。如果你已经购买了一个股票，在你卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<h3 id="【解题思路】-25">【解题思路】</h3>
<p>使用动态规划，并采用二维数组来表示状态。在这个问题中，我们定义 <code>dp[i][j]</code>，其中 <code>i</code> 表示第 <code>i</code> 天，<code>j</code> 有两种状态，0 和 1：</p>
<ul>
<li><code>j = 0</code> 表示第 <code>i</code> 天结束时不持有股票。</li>
<li><code>j = 1</code> 表示第 <code>i</code> 天结束时持有股票。</li>
</ul>
<p>状态转移方程如下：</p>
<ul>
<li>当不持有股票时（<code>j = 0</code>），<code>dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</code>，即前一天也不持有股票，或者前一天持有股票但在第 <code>i</code> 天卖出。</li>
<li>当持有股票时（<code>j = 1</code>），<code>dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i] - fee)</code>，即前一天也持有股票，或者前一天不持有股票但在第 <code>i</code> 天买入并支付手续费 <code>fee</code>。</li>
</ul>
<p>初始状态：</p>
<ul>
<li><code>dp[0][0] = 0</code>，第一天结束时不持有股票。</li>
<li><code>dp[0][1] = -prices[0] - fee</code>，第一天买入股票并支付手续费。</li>
</ul>
<p>最终答案是 <code>dp[n-1][0]</code>，表示最后一天结束时不持有股票的最大利润。</p>
<h3 id="【实现代码】-25">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>, fee <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(prices)</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dp := <span class="built_in">make</span>([][<span class="number">2</span>]<span class="type">int</span>, n)</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>] - fee</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">		dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i])</span><br><span class="line">		dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i]-fee)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	prices := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">9</span>&#125;</span><br><span class="line">	fee := <span class="number">2</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Max profit:&quot;</span>, maxProfit(prices, fee))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="300-最长递增子序列">300 最长递增子序列</h2>
<h3 id="【题目描述】-25">【题目描述】</h3>
<p>给你一个整数数组 <code>nums</code>，找到其中最长严格递增子序列的长度。子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [10,9,2,5,3,7,101,18] 输出: 4 解释: 最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></figure>
<h3 id="【解题思路】-26">【解题思路】</h3>
<p>这个问题可以通过动态规划（Dynamic Programming，DP）来解决。基本思路是，创建一个和输入数组 <code>nums</code> 同样长度的数组 <code>dp</code>，其中 <code>dp[i]</code> 表示以 <code>nums[i]</code> 结尾的最长递增子序列的长度。对于数组中的每个元素，我们都遍历它之前的元素，找到一个可以追加当前元素形成更长递增子序列的最长序列。</p>
<ol>
<li>初始化 <code>dp</code> 数组，所有元素值为 <code>1</code>，因为最短的递增子序列至少包含它自己。</li>
<li>遍历 <code>nums</code> 数组，对于每个 <code>nums[i]</code>，再遍历 <code>0</code> 到 <code>i-1</code> 的所有元素 <code>nums[j]</code>。如果 <code>nums[j] &lt; nums[i]</code>，说明 <code>nums[i]</code> 可以跟在 <code>nums[j]</code> 后面形成一个更长的递增子序列，此时更新 <code>dp[i]</code> 为 <code>dp[j] + 1</code> 的最大值。</li>
<li>遍历完所有元素后，<code>dp</code> 数组中的最大值即为最长递增子序列的长度。</li>
</ol>
<h3 id="【实现代码】-26">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLIS</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">		dp[i] = <span class="number">1</span> <span class="comment">// 最短的递增子序列至少包含它自己</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	maxLen := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> nums[j] &lt; nums[i] &#123;</span><br><span class="line">				dp[i] = max(dp[i], dp[j]+<span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		maxLen = max(maxLen, dp[i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> maxLen</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums := []<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">101</span>, <span class="number">18</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Length of LIS:&quot;</span>, lengthOfLIS(nums))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="674-最长连续递增序列">674 最长连续递增序列</h2>
<h3 id="【题目描述】-26">【题目描述】</h3>
<p>给定一个未经排序的整数数组，找到最长且连续递增的子序列，并返回该序列的长度。连续递增的子序列可以由两个下标 <code>l</code> 和 <code>r</code>（<code>l &lt; r</code>）确定，如果对于每个 <code>l &lt;= i &lt; r</code>，都有 <code>nums[i] &lt; nums[i + 1]</code>，那么子序列 <code>[nums[l], nums[l + 1], ..., nums[r-1], nums[r]]</code> 就是连续递增子序列。<br>
<strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,5,4,7]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 最长连续递增序列是 [1,3,5], 长度为 3。</span><br><span class="line">尽管 [1,3,5,7] 也是最长递增子序列，但是它不是连续的。</span><br></pre></td></tr></table></figure>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [2,2,2,2,2]</span><br><span class="line">输出: 1</span><br><span class="line">解释: 最长连续递增序列是 [2], 长度为 1。</span><br></pre></td></tr></table></figure>
<h3 id="【解题思路】-27">【解题思路】</h3>
<p>虽然这个问题可以不使用动态规划直接通过一次遍历解决，但是为了遵循任务要求，我们可以考虑使用一维动态规划的方式来实现。一维数组 <code>dp</code> 用来记录以 <code>nums[i]</code> 结尾的最长连续递增序列的长度。对于数组中的每个元素，如果 <code>nums[i]</code> 比 <code>nums[i-1]</code> 大，则说明可以延续之前的连续递增序列，否则，这个位置的连续递增序列长度重新开始计数。</p>
<ol>
<li>初始化一个和输入数组 <code>nums</code> 同样长度的数组 <code>dp</code>，所有元素值初始化为 <code>1</code>，因为最短的连续递增序列至少包含它自己。</li>
<li>从第二个元素开始遍历数组 <code>nums</code>，如果 <code>nums[i]</code> 大于 <code>nums[i-1]</code>，则 <code>dp[i] = dp[i-1] + 1</code>，意味着以 <code>nums[i]</code> 结尾的最长连续递增序列长度可以基于前一个元素的长度加一。</li>
<li>遍历过程中记录 <code>dp</code> 数组的最大值，即为最长连续递增序列的长度。</li>
</ol>
<h3 id="【实现代码】-27">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findLengthOfLCIS</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">//贪心</span></span><br><span class="line">	res := <span class="number">1</span></span><br><span class="line">	start := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> nums[i] &lt;= nums[i<span class="number">-1</span>] &#123;</span><br><span class="line">			start = i</span><br><span class="line">		&#125;</span><br><span class="line">		res = max(res, i-start+<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//动态规划</span></span><br><span class="line">	n := <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">		dp[i] = <span class="number">1</span> <span class="comment">// 每个元素至少可以构成长度为1的连续递增序列</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	maxLength := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> nums[i] &gt; nums[i<span class="number">-1</span>] &#123;</span><br><span class="line">			dp[i] = dp[i<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">			maxLength = max(maxLength, dp[i])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> maxLength</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Length of LCIS:&quot;</span>, findLengthOfLCIS(nums))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="718-最长重复子数组">718 最长重复子数组</h2>
<h3 id="【题目描述】-27">【题目描述】</h3>
<p>给两个整数数组 <code>A</code> 和 <code>B</code>，返回两个数组中公共的、长度最长的子数组的长度(<strong>需要连续</strong>)。<br>
<strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 长度最长的公共子数组是 [3,2,1] 。</span><br></pre></td></tr></table></figure>
<h3 id="【解题思路】-28">【解题思路】</h3>
<p>这个问题可以用动态规划（Dynamic Programming，DP）来解决。我们可以创建一个二维数组 <code>dp</code>，其中 <code>dp[i][j]</code> 表示以 <code>A[i]</code> 和 <code>B[j]</code> 结尾的最长重复子数组的长度。如果 <code>A[i]</code> 和 <code>B[j]</code> 相等，那么 <code>dp[i][j]</code> 应该是 <code>dp[i-1][j-1] + 1</code>。否则，如果它们不相等，<code>dp[i][j]</code> 应该是 <code>0</code>，因为我们是在寻找连续的、重复的子数组。</p>
<ol>
<li>初始化一个 <code>(len(A)+1) * (len(B)+1)</code> 的二维数组 <code>dp</code>，所有元素值为 <code>0</code>。</li>
<li>遍历数组 <code>A</code> 和 <code>B</code>，对于每一对 <code>i</code> 和 <code>j</code>，如果 <code>A[i-1] == B[j-1]</code>，则更新 <code>dp[i][j] = dp[i-1][j-1] + 1</code>。</li>
<li>在遍历的过程中，记录 <code>dp</code> 数组中的最大值，这个最大值就是两个数组中公共的、长度最长的子数组的长度。</li>
</ol>
<h3 id="【实现代码】-28">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findLength</span><span class="params">(nums1 []<span class="type">int</span>, nums2 []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line">	m, n := <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">	<span class="comment">//nums1[i],nums2[j]对应的最长子数组长度</span></span><br><span class="line">	dp := <span class="built_in">make</span>([][]<span class="type">int</span>, m+<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= m; i++ &#123;</span><br><span class="line">		dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= m; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= n; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> nums1[i<span class="number">-1</span>] == nums2[j<span class="number">-1</span>] &#123;</span><br><span class="line">				dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">			&#125;</span><br><span class="line">			res = max(res, dp[i][j])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1143-最长公共子序列">1143 最长公共子序列</h2>
<h3 id="【题目描述】-28">【题目描述】</h3>
<p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长公共子序列的长度。一个字符串的子序列是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。两个字符串的公共子序列是这两个字符串所共同拥有的子序列。<br>
<strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; </span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：最长公共子序列是 &quot;abc&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：两个字符串没有公共子序列，返回 0 。</span><br></pre></td></tr></table></figure>
<h3 id="【解题思路】-29">【解题思路】</h3>
<p>解决这个问题的一个有效方法是使用动态规划。我们可以定义一个二维数组 <code>dp</code>，其中 <code>dp[i][j]</code> 表示 <code>text1</code> 中前 <code>i</code> 个字符和 <code>text2</code> 中前 <code>j</code> 个字符的最长公共子序列的长度。基于这个定义，我们可以得出以下状态转移方程：</p>
<ul>
<li>如果 <code>text1[i-1] == text2[j-1]</code>，那么 <code>dp[i][j] = dp[i-1][j-1] + 1</code>，因为最后一个字符匹配，我们可以在之前的最长公共子序列的基础上加上这个匹配的字符。</li>
<li>如果 <code>text1[i-1] != text2[j-1]</code>，那么 <code>dp[i][j] = max(dp[i-1][j], dp[i][j-1])</code>，因为最后一个字符不匹配，我们需要从 <code>text1</code> 的前 <code>i-1</code> 个字符和 <code>text2</code> 的前 <code>j</code> 个字符的最长公共子序列，以及 <code>text1</code> 的前 <code>i</code> 个字符和 <code>text2</code> 的前 <code>j-1</code> 个字符的最长公共子序列中找到最长的那一个。</li>
</ul>
<p>初始化时，<code>dp[0][j]</code> 和 <code>dp[i][0]</code> 都应该为 <code>0</code>，因为一个字符串与一个空字符串的最长公共子序列长度显然为 <code>0</code>。</p>
<h3 id="【实现代码】-29">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意和718题的区别</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestCommonSubsequence</span><span class="params">(text1 <span class="type">string</span>, text2 <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	n1, n2 := <span class="built_in">len</span>(text1), <span class="built_in">len</span>(text2)</span><br><span class="line">	dp := <span class="built_in">make</span>([][]<span class="type">int</span>, n1+<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= n1; i++ &#123;</span><br><span class="line">		dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n2+<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n1; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= n2; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>] &#123;</span><br><span class="line">				dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>])</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[n1][n2]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数，返回两个整数的较大值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="1035-不相交的线（等同于最长公共子序列）">1035 不相交的线（等同于最长公共子序列）</h2>
<h3 id="【题目描述】-29">【题目描述】</h3>
<p>在两条独立的水平线上分别给定两个数组 <code>nums1</code> 和 <code>nums2</code>，<code>nums1</code> 和 <code>nums2</code> 中的数互不相同，且只存在于一条线上。现在，我们可以绘制一些连接两个数 <code>nums1[i]</code> 和 <code>nums2[j]</code> 的直线，这些直线需要同时满足满足 <code>i &lt; j</code> 且 <code>nums1[i] == nums2[j]</code>。请找出这样的直线的最大数量，使得这些直线之间不会相交。请注意，即使 <code>nums1[i] == nums2[j]</code> 且 <code>i &lt; j</code>，直线 <code>(nums1[i], nums2[j])</code> 与线段 <code>(i, j)</code> 不相交。也就是说，它们在水平方向上相互不重叠，且在垂直方向上也是如此。</p>
<h3 id="【解题思路】-30">【解题思路】</h3>
<p>这个问题可以转化为求两个数组的最长公共子序列问题。因为题目要求找出最多的不相交的直线，这等价于在两个数组中找到最长的相同值序列，且这些值的相对顺序在两个数组中是一致的。</p>
<p>我们可以使用动态规划的方法来求解这个问题：</p>
<ol>
<li>定义一个二维数组 <code>dp</code>，其中 <code>dp[i][j]</code> 表示 <code>nums1</code> 的前 <code>i</code> 个元素（即0-i-1）和 <code>nums2</code> 的前 <code>j</code> 个（即0-j-1）元素可以形成的最长公共子序列的长度。不定义为第0-i的原因是为了简化在$dp[0][i]$处的赋值。</li>
<li>遍历 <code>nums1</code> 和 <code>nums2</code>，对于每一对 <code>i</code> 和 <code>j</code>，如果 <code>nums1[i-1] == nums2[j-1]</code>，则 <code>dp[i][j] = dp[i-1][j-1] + 1</code>；否则，<code>dp[i][j] = max(dp[i-1][j], dp[i][j-1])</code>。</li>
<li>最终，<code>dp[m][n]</code>（其中 <code>m</code> 和 <code>n</code> 分别是 <code>nums1</code> 和 <code>nums2</code> 的长度）就是最长公共子序列的长度，也就是最多的不相交直线数量。</li>
<li></li>
</ol>
<h3 id="【实现代码】-30">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxUncrossedLines</span><span class="params">(nums1 []<span class="type">int</span>, nums2 []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	m, n := <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">	dp := <span class="built_in">make</span>([][]<span class="type">int</span>, m+<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">		dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= m; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= n; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> nums1[i<span class="number">-1</span>] == nums2[j<span class="number">-1</span>] &#123;</span><br><span class="line">				dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>])</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[m][n]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="53-最大子数组和">53 最大子数组和</h2>
<h3 id="【题目描述】-30">【题目描述】</h3>
<p>给你一个整数数组 <code>nums</code>，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。子数组是数组中的一个连续部分。</p>
<h3 id="【解题思路】-31">【解题思路】</h3>
<p>这个问题可以用动态规划（DP）来解决。DP的思想是将大问题分解成小问题，然后解决小问题，逐步得到大问题的解。</p>
<ol>
<li>
<p><strong>状态定义</strong>：设 <code>dp[i]</code> 表示以 <code>nums[i]</code> 结尾的最大子数组和。注意，这里的子数组是指以 <code>nums[i]</code> 结尾的，并不是整个数组的任意子数组，这是为了保证状态的转移是可行的。</p>
</li>
<li>
<p><strong>状态转移方程</strong>：要找到以 <code>nums[i]</code> 结尾的最大子数组和，我们有两种选择：要么加上前面的数组得到更大的和，要么不加（如果前面的数组和小于0，加上反而会让和变小），自己单独成为一个子数组。因此，状态转移方程为：<code>dp[i] = max(nums[i], dp[i-1] + nums[i])</code>。</p>
</li>
<li>
<p><strong>初始化</strong>：<code>dp[0] = nums[0]</code>，因为当数组只有一个元素时，最大子数组和就是它自己。</p>
</li>
<li>
<p><strong>答案</strong>：遍历 <code>dp</code> 数组，找到最大的 <code>dp[i]</code>，这就是整个数组的最大子数组和。</p>
</li>
</ol>
<h3 id="【实现代码】-31">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 初始化dp数组，dp[i]表示以nums[i]结尾的最大子数组和</span></span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">	dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">	maxSum := dp[<span class="number">0</span>] <span class="comment">// 初始化最大和为第一个元素</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 动态规划填表</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		dp[i] = max(nums[i], dp[i<span class="number">-1</span>]+nums[i])</span><br><span class="line">		maxSum = max(maxSum, dp[i]) <span class="comment">// 更新最大子数组和</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> maxSum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数，返回两个整数中的较大值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="392-判断子序列">392 判断子序列</h2>
<h3 id="【题目描述】-31">【题目描述】</h3>
<p>给定字符串 <code>s</code> 和 <code>t</code>，判断 <code>s</code> 是否为 <code>t</code> 的子序列。你可以认为 <code>s</code> 和 <code>t</code> 中仅包含英文小写字母。字符串 <code>t</code> 可能会非常长（长度 ~= 500,000），而 <code>s</code> 是个短字符串（长度 &lt;=100）。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，<code>&quot;ace&quot;</code>是<code>&quot;abcde&quot;</code>的一个子序列，而<code>&quot;aec&quot;</code>不是）。</p>
<h3 id="【解题思路】-32">【解题思路】</h3>
<p>这个问题可以通过贪心算法来解决，但由于要求使用动态规划，我们也可以通过动态规划的方式来思考。动态规划通常不是解决这类问题的最优解，但是为了满足题目要求，我们可以尝试构建一个解决方案。</p>
<p>然而，直接应用动态规划到这个问题上并不直观，因为通常动态规划用于计算最优解的问题，如最短路径、最大子序列和等，而这个问题是一个判断问题。不过，我们可以将问题转化为求 <code>s</code> 和 <code>t</code> 的最长公共子序列，如果最长公共子序列的长度等于 <code>s</code> 的长度，则说明 <code>s</code> 是 <code>t</code> 的子序列。</p>
<ol>
<li><strong>状态定义</strong>：设 <code>dp[i][j]</code> 表示 <code>s</code> 的前 <code>i</code> 个字符和 <code>t</code> 的前 <code>j</code> 个字符的最长公共子序列的长度。</li>
<li><strong>状态转移方程</strong>：如果 <code>s[i-1] == t[j-1]</code>，则 <code>dp[i][j] = dp[i-1][j-1] + 1</code>；否则，<code>dp[i][j] = max(dp[i-1][j], dp[i][j-1])</code>。</li>
<li><strong>初始化</strong>：初始化 <code>dp</code> 数组为0。</li>
<li><strong>答案</strong>：如果 <code>dp[len(s)][len(t)] == len(s)</code>，则 <code>s</code> 是 <code>t</code> 的子序列。</li>
</ol>
<h3 id="【实现代码】-32">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSubsequence</span><span class="params">(s <span class="type">string</span>, t <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	m, n := <span class="built_in">len</span>(s), <span class="built_in">len</span>(t)</span><br><span class="line">	dp := <span class="built_in">make</span>([][]<span class="type">int</span>, m+<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">		dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= m; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= n; j++ &#123;</span><br><span class="line">		<span class="comment">//关于两个序列比较时dp[i][j]表示的都是【i-1】【j-1】时比较，这样能简化【0】【0】处的初始化操作</span></span><br><span class="line">			<span class="keyword">if</span> s[i<span class="number">-1</span>] == t[j<span class="number">-1</span>] &#123;</span><br><span class="line">				dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>])</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dp[m][n] == m</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSubsequence</span><span class="params">(s <span class="type">string</span>, t <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	i, j := <span class="number">0</span>, <span class="number">0</span> <span class="comment">// 初始化双指针</span></span><br><span class="line">	<span class="keyword">for</span> i &lt; <span class="built_in">len</span>(s) &amp;&amp; j &lt; <span class="built_in">len</span>(t) &#123;</span><br><span class="line">		<span class="keyword">if</span> s[i] == t[j] &#123;</span><br><span class="line">			i++ <span class="comment">// 找到匹配的字符，移动指针 i</span></span><br><span class="line">		&#125;</span><br><span class="line">		j++ <span class="comment">// 无论是否匹配，都移动指针 j</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i == <span class="built_in">len</span>(s) <span class="comment">// 如果 i 移动到了 s 的末尾，说明 s 是 t 的子序列</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="115-不同的子序列">115 不同的子序列</h2>
<h3 id="【题目描述】-32">【题目描述】</h3>
<p>给你两个字符串 <code>s</code> 和 <code>t</code> ，统计并返回在 <code>s</code> 的 <strong>子序列</strong> 中 <code>t</code> 出现的个数。<br>
题目数据保证答案符合 32 位带符号整数范围。<br>
<strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;rabbbit&quot;, t = &quot;rabbit&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">如下图所示, 有 3 种可以从 s 中得到 &quot;rabbit&quot; 的方案。</span><br><span class="line">(上箭头符号 ^ 表示选取的字母)</span><br><span class="line"></span><br><span class="line">rabbbit</span><br><span class="line">^^^^ ^^</span><br><span class="line">rabbbit</span><br><span class="line">^^ ^^^^</span><br><span class="line">rabbbit</span><br><span class="line">^^^ ^^^</span><br></pre></td></tr></table></figure>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;babgbag&quot;, t = &quot;bag&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">如下图所示, 有 5 种可以从 s 中得到 &quot;bag&quot; 的方案。</span><br><span class="line">(上箭头符号 ^ 表示选取的字母)</span><br><span class="line"></span><br><span class="line">babgbag</span><br><span class="line">^^ ^</span><br><span class="line">babgbag</span><br><span class="line">^^    ^</span><br><span class="line">babgbag</span><br><span class="line">^    ^ ^</span><br><span class="line">babgbag</span><br><span class="line">  ^^^</span><br><span class="line">babgbag</span><br><span class="line">  ^^   ^</span><br></pre></td></tr></table></figure>
<h3 id="【解题思路】-33">【解题思路】</h3>
<p>在这个实现中，<code>dp[i][j]</code> 表示从 <code>s</code> 的第 <code>i</code> 个字符到第 <code>j</code> 个字符的不同子序列的数量。我们从对角线上的元素开始填充 <code>dp</code> 数组，因为这些元素表示单个字符的子序列数量，始终为 <code>1</code>。然后，我们从右上角开始填充数组的其余部分，使用以下递推关系：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i+1][j] (if s[i] != s[j])</span><br><span class="line">dp[i][j] = dp[i+1][j] + dp[i][j-1] (if s[i] == s[j])</span><br></pre></td></tr></table></figure>
<p>最终，<code>dp[0][n]</code> 将包含 <code>s</code> 的所有不同子序列的数量。</p>
<h3 id="【实现代码】-33">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numDistinct</span><span class="params">(s <span class="type">string</span>, t <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	m,n:=<span class="built_in">len</span>(s),<span class="built_in">len</span>(t)</span><br><span class="line">	<span class="comment">//以i-1为结尾的s子序列中出现以j-1为结尾的t的个数</span></span><br><span class="line">	dp := <span class="built_in">make</span>([][]<span class="type">int</span>, m+<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;=m;i++ &#123;</span><br><span class="line">		dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;=m;i++ &#123;</span><br><span class="line">		dp[i][<span class="number">0</span>] =<span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=m;i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j:=<span class="number">1</span>;j&lt;=n;j++ &#123;</span><br><span class="line">			<span class="comment">//使用i-1结尾的元素，不使用i-1结尾的元素</span></span><br><span class="line">			<span class="comment">//一部分是用s[i - 1]来匹配，那么个数为dp[i - 1][j - 1]</span></span><br><span class="line">			<span class="comment">//一部分是不用s[i - 1]来匹配，个数为dp[i - 1][j]</span></span><br><span class="line">			<span class="keyword">if</span> s[i<span class="number">-1</span>] == t[j<span class="number">-1</span>] &#123;</span><br><span class="line">				dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + dp[i<span class="number">-1</span>][j]</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//当s[i - 1] 与 t[j - 1]不相等时，dp[i][j]只有一部分组成，不用s[i - 1]来匹配（就是模拟在s中删除这个元素），即：dp[i - 1][j]</span></span><br><span class="line">				dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dp[m][n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="583-两个字符串的删除操作">583 两个字符串的删除操作</h2>
<h3 id="【题目描述】-33">【题目描述】</h3>
<p>给定两个字符串 <code>word1</code> 和 <code>word2</code>，返回使 <code>word1</code> 和 <code>word2</code> 相同所需的最小删除操作次数。</p>
<h3 id="【解题思路】-34">【解题思路】</h3>
<p>我们可以使用动态规划来解决这个问题。我们创建一个二维数组 <code>dp</code>，其中 <code>dp[i][j]</code> 表示删除 <code>word1</code> 的前 <code>i</code> 个字符和 <code>word2</code> 的前 <code>j</code> 个字符后，使剩余字符串相同的最小删除操作次数。</p>
<p>我们从 <code>dp[0][0] = 0</code> 开始，因为空字符串不需要任何删除操作即可变成相等。对于 <code>word1</code> 的每个字符，我们检查它是否与 <code>word2</code> 的当前字符匹配。如果匹配，则 <code>dp[i][j]</code> 等于 <code>dp[i-1][j-1]</code>（不进行任何删除操作）。如果不匹配，则 <code>dp[i][j]</code> 等于 <code>dp[i-1][j]</code>（删除 <code>word1</code> 的当前字符）和 <code>dp[i][j-1]</code>（删除 <code>word2</code> 的当前字符）中的最小值加上 <code>1</code>。</p>
<h3 id="【实现代码】-34">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minDistance</span><span class="params">(word1 <span class="type">string</span>, word2 <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    m, n := <span class="built_in">len</span>(word1), <span class="built_in">len</span>(word2)</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="type">int</span>, m+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>] &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = min(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]) + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="72-编辑距离">72 编辑距离</h2>
<h3 id="【题目描述】-34">【题目描述】</h3>
<p>给定两个字符串 <code>word1</code> 和 <code>word2</code>，计算将 <code>word1</code> 编辑成 <code>word2</code> 所需的最小操作次数。<br>
允许的编辑操作包括：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<h3 id="【解题思路】-35">【解题思路】</h3>
<p>我们可以使用动态规划来解决这个问题。我们创建一个二维数组 <code>dp</code>，其中 <code>dp[i][j]</code> 表示将 <code>word1</code> 的前 <code>i</code> 个字符编辑成 <code>word2</code> 的前 <code>j</code> 个字符所需的最小操作次数。</p>
<p>我们从 <code>dp[0][0] = 0</code> 开始，因为空字符串不需要任何编辑操作即可变成相等。对于 <code>word1</code> 的每个字符，我们检查它是否与 <code>word2</code> 的当前字符匹配。如果匹配，则 <code>dp[i][j]</code> 等于 <code>dp[i-1][j-1]</code>（不进行任何编辑操作）。如果 <code>word1</code> 的当前字符不匹配 <code>word2</code> 的当前字符，则 <code>dp[i][j]</code> 等于 <code>dp[i-1][j]</code>（删除 <code>word1</code> 的当前字符）、<code>dp[i][j-1]</code>（插入 <code>word2</code> 的当前字符）和 <code>dp[i-1][j-1]</code>（替换 <code>word1</code> 的当前字符）中的最小值加上 <code>1</code>。</p>
<h3 id="【实现代码】-35">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(arr ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	res := arr[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="built_in">len</span>(arr);i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> arr[i] &lt; res &#123;</span><br><span class="line">			res = arr[i]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minDistance</span><span class="params">(word1 <span class="type">string</span>, word2 <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	m, n := <span class="built_in">len</span>(word1), <span class="built_in">len</span>(word2)</span><br><span class="line">	<span class="comment">//其中 dp[i][j] 表示将 word1 的前 i 个字符编辑成 word2 的前 j 个字符所需的最小操作次数</span></span><br><span class="line">	dp := <span class="built_in">make</span>([][]<span class="type">int</span> ,m +<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;=m;i++ &#123;</span><br><span class="line">		dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// word2为空的情况，编辑次数为i</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=m;i++ &#123;</span><br><span class="line">		dp[i][<span class="number">0</span>] = i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=n;i++ &#123;</span><br><span class="line">		dp[<span class="number">0</span>][i] = i</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=m;i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j:=<span class="number">1</span>;j&lt;=n;j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>] &#123;</span><br><span class="line">				<span class="comment">//如果相等，则不需要操作</span></span><br><span class="line">				dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//不相等</span></span><br><span class="line">				<span class="comment">// 1. 删除word1 dp[i-1][j]+1</span></span><br><span class="line">				<span class="comment">// 2. 删除word2 dp[i][j-1]+1</span></span><br><span class="line">				<span class="comment">// 3. 替换word1或word2，dp[i-1][j-1] + 1</span></span><br><span class="line">				<span class="comment">// 4. 添加，word1添加等于word2删除，所以不需要写添加的代码</span></span><br><span class="line">				dp[i][j] = min(dp[i<span class="number">-1</span>][j]+<span class="number">1</span>, dp[i][j<span class="number">-1</span>]+<span class="number">1</span>, dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dp[m][n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="647-回文子串">647 回文子串</h2>
<h3 id="【题目描述】-35">【题目描述】</h3>
<p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。具体来说，就是找出有多少个子串是回文的，这里的回文定义与标准回文字符串相同，即正着读和反着读都一样。</p>
<h3 id="【解题思路】-36">【解题思路】</h3>
<p>这个问题可以通过动态规划的方式来解决。动态规划是一种解决问题的方法，它将问题分解成更小的子问题，通过解决子问题来解决原问题。</p>
<p>对于这个问题，我们可以定义一个二维的动态规划数组<code>dp[i][j]</code>，其中<code>i</code>和<code>j</code>是字符串中字符的索引，<code>i</code>&lt;=<code>j</code>。如果子字符串<code>s[i...j]</code>是回文，则<code>dp[i][j]</code>为真，否则为假。</p>
<p>以下是解题的步骤：</p>
<ol>
<li>初始化长度为<code>n</code>的字符串<code>s</code>的二维动态规划数组<code>dp</code>，<code>n</code>是字符串<code>s</code>的长度。所有的<code>dp[i][j]</code>初始值为假。</li>
<li>对于每个字符<code>s[i]</code>，我们都将<code>dp[i][i]</code>设为真，因为每个单独的字符都是回文子串。</li>
<li>对于长度为2的子串，如果<code>s[i] == s[i+1]</code>，则<code>dp[i][i+1]</code>为真。</li>
<li>对于长度大于2的子串，如果<code>s[i] == s[j]</code>并且<code>dp[i+1][j-1]</code>为真（即去掉头尾的子串也是回文），则<code>dp[i][j]</code>为真。</li>
<li>通过上面的步骤，我们可以填满动态规划数组。最后，我们遍历这个数组，计算<code>dp[i][j]</code>为真的个数，即为答案。</li>
</ol>
<h3 id="【实现代码】-36">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countSubstrings</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(s)</span><br><span class="line">	<span class="comment">// dp[i][j]表示的是s[i][j]是否为回文串 [i,j]是闭区间</span></span><br><span class="line">	dp := <span class="built_in">make</span>([][]<span class="type">bool</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;n;i++ &#123;</span><br><span class="line">		dp[i] = <span class="built_in">make</span>([]<span class="type">bool</span>, n)</span><br><span class="line">	&#125;</span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line">	<span class="comment">//注意遍历顺序，[i][j]由[i+1][j-1]推出，所以i由左下到左上遍历</span></span><br><span class="line">	<span class="keyword">for</span> i:=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i-- &#123;</span><br><span class="line">		<span class="keyword">for</span> j:=i;j&lt;n;j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> s[i] == s[j] &#123;</span><br><span class="line">				<span class="comment">//i == j</span></span><br><span class="line">				<span class="keyword">if</span> i == j &#123;</span><br><span class="line">					dp[i][j] = <span class="literal">true</span></span><br><span class="line">					res++</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> i == j<span class="number">-1</span> &#123;</span><br><span class="line">					dp[i][j] = <span class="literal">true</span></span><br><span class="line">					res++</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> i+<span class="number">1</span>&lt;n &amp;&amp; j<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; dp[i+<span class="number">1</span>][j<span class="number">-1</span>] &#123;</span><br><span class="line">					dp[i][j] = <span class="literal">true</span></span><br><span class="line">					res++</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双指针实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countSubstrings</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">	    <span class="comment">//回文串 需要分以一个单词为中心如 bab，和两个单词为中心如baab来区分</span></span><br><span class="line">        <span class="comment">// 奇数长度的回文</span></span><br><span class="line">        count += expandAroundCenter(s, i, i)</span><br><span class="line">        <span class="comment">// 偶数长度的回文</span></span><br><span class="line">        count += expandAroundCenter(s, i, i+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从left和right开始向外扩展，计算回文子串的数量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">expandAroundCenter</span><span class="params">(s <span class="type">string</span>, left, right <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> left &gt;= <span class="number">0</span> &amp;&amp; right &lt; <span class="built_in">len</span>(s) &amp;&amp; s[left] == s[right] &#123;</span><br><span class="line">        count++</span><br><span class="line">        left--</span><br><span class="line">        right++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="516-最长回文子序列">516 最长回文子序列</h2>
<h3 id="【题目描述】-36">【题目描述】</h3>
<p>给定一个字符串<code>s</code>，找到其中最长的回文子序列，并返回该序列的长度。可以假设<code>s</code>的最大长度为<code>1000</code>。</p>
<h3 id="【解题思路】-37">【解题思路】</h3>
<p>要解决这个问题，我们可以使用动态规划。动态规划是一种算法思想，它将大问题分解为小问题，通过解决小问题来解决大问题。</p>
<p>对于这个问题，我们定义一个二维数组<code>dp</code>，其中<code>dp[i][j]</code>表示字符串<code>s</code>中第<code>i</code>到第<code>j</code>个字符组成的子串中，最长回文子序列的长度。根据定义，我们想要的最终答案就是<code>dp[0][len(s)-1]</code>。</p>
<p>状态转移方程如下：</p>
<ul>
<li>如果<code>s[i] == s[j]</code>，那么<code>dp[i][j] = dp[i+1][j-1] + 2</code>。这是因为如果两端的字符相等，那么它们可以构成回文的一部分，并且加上中间部分的最长回文子序列长度。</li>
<li>如果<code>s[i] != s[j]</code>，那么<code>dp[i][j] = max(dp[i+1][j], dp[i][j-1])</code>。这是因为两端的字符不能同时作为回文的一部分，我们需要在不包含<code>s[i]</code>和不包含<code>s[j]</code>的子串中找到最长的回文子序列。</li>
</ul>
<p>初始化时，当<code>i == j</code>时，<code>dp[i][j]</code>显然等于<code>1</code>，因为任何单个字符都是一个回文子序列。</p>
<h3 id="【实现代码】-37">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindromeSubseq</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(s)</span><br><span class="line">	<span class="comment">// dp[i][j]标识s[i][j]之间的最长回文子序列的长度</span></span><br><span class="line">	dp := <span class="built_in">make</span>([][]<span class="type">int</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;n;i++ &#123;</span><br><span class="line">		dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i:=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i-- &#123;</span><br><span class="line">		<span class="keyword">for</span> j:=i;j&lt;n;j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> s[i] != s[j] &#123;</span><br><span class="line">				dp[i][j] = max(dp[i+<span class="number">1</span>][j], dp[i][j<span class="number">-1</span>])</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> i == j &#123;</span><br><span class="line">					dp[i][j] = <span class="number">1</span></span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> i+<span class="number">1</span> == j &#123;</span><br><span class="line">					dp[i][j] = <span class="number">2</span></span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>]+<span class="number">2</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数，用于取两个整数中的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">&quot;bbbab&quot;</span></span><br><span class="line">    fmt.Println(longestPalindromeSubseq(s)) <span class="comment">// 输出应为 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="42-接雨水">42 接雨水</h2>
<h3 id="【题目描述】-37">【题目描述】</h3>
<p>给定<code>n</code>个非负整数表示每个宽度为<code>1</code>的柱子的高度图，计算下雨后能接多少雨水。</p>
<h3 id="【解题思路】-38">【解题思路】</h3>
<p>这个问题可以通过动态规划的方式来解决。动态规划的核心思想是将一个复杂问题分解成子问题来逐个击破，并存储已经解决的子问题的答案，在需要时直接使用，从而减少计算量。</p>
<p>对于接雨水这个问题，我们可以分别计算每个位置左边和右边最高的柱子。然后，对于每个位置，能接的雨水量等于左右两边最高的柱子中较矮那个减去当前位置的高度（如果结果是负数，则当前位置不接雨水，也就是雨水量为0）。</p>
<ol>
<li>首先，创建两个数组<code>leftMax</code>和<code>rightMax</code>。<code>leftMax[i]</code>存储位置<code>i</code>左边最高柱子的高度，<code>rightMax[i]</code>存储位置<code>i</code>右边最高柱子的高度。</li>
<li>从左到右遍历高度图填充<code>leftMax</code>，从右到左遍历高度图填充<code>rightMax</code>。</li>
<li>再次遍历每个位置，使用<code>min(leftMax[i], rightMax[i]) - height[i]</code>计算每个位置的接水量，如果结果大于0，则累加到总接水量中。</li>
</ol>
<h3 id="【实现代码】-38">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trap</span><span class="params">(height []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(height) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n := <span class="built_in">len</span>(height)</span><br><span class="line">    leftMax := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    rightMax := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    water := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    leftMax[<span class="number">0</span>] = height[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        leftMax[i] = max(leftMax[i<span class="number">-1</span>], height[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rightMax[n<span class="number">-1</span>] = height[n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">for</span> i := n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        rightMax[i] = max(rightMax[i+<span class="number">1</span>], height[i])</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//两端的列不会存储水</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n<span class="number">-1</span>; i++ &#123;</span><br><span class="line">        water += min(leftMax[i], rightMax[i]) - height[i]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> water</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单调栈实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trap</span><span class="params">(height []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// stack有栈顶到栈底是 小到大   [ 3 2 1</span></span><br><span class="line">	stack := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	stack = <span class="built_in">append</span>(stack, <span class="number">0</span>)</span><br><span class="line">	water := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i, h := <span class="keyword">range</span> height &#123;</span><br><span class="line">		<span class="keyword">if</span> h &lt; height[stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]] &#123;<span class="comment">//比栈顶元素小，入栈</span></span><br><span class="line">			stack = <span class="built_in">append</span>(stack, i)</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> h == height[stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]] &#123;<span class="comment">//相等，更新栈顶元素</span></span><br><span class="line">			stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">			stack = <span class="built_in">append</span>(stack, i)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;<span class="comment">//小于</span></span><br><span class="line">			<span class="comment">//出栈</span></span><br><span class="line">			<span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &amp;&amp; h &gt; height[stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]] &#123;</span><br><span class="line">				<span class="comment">// 当前元素</span></span><br><span class="line">				mid := height[stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]]</span><br><span class="line">				<span class="comment">// 当前元素出栈</span></span><br><span class="line">				stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">					<span class="comment">// 计算高度</span></span><br><span class="line">					h := min(h, height[stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]]) - mid</span><br><span class="line">					<span class="comment">// 计算宽度</span></span><br><span class="line">					w := i - stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] - <span class="number">1</span></span><br><span class="line">					water += h * w</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			stack = <span class="built_in">append</span>(stack, i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> water</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    height := []<span class="type">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>&#125;</span><br><span class="line">    fmt.Println(trap(height)) <span class="comment">// 输出应为 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="84-柱状图中最大的矩形">84 柱状图中最大的矩形</h2>
<h3 id="【题目描述】-38">【题目描述】</h3>
<p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<h3 id="【解题思路】-39">【解题思路】</h3>
<p>本题的关键是找到每根柱子左右两边第一个小于该柱子高度的柱子，这样我们就能确定该柱子能够扩展的最大宽度，从而计算出以该柱子高度为矩形的最大面积。</p>
<p>为了高效找到每根柱子左右两边的界限，我们可以使用单调栈的数据结构。单调栈可以保证栈内元素保持单调递增或递减，这样当我们遇到一个新的柱子时，就可以通过栈顶元素迅速知道前一个比当前柱子小的柱子，同理，当新的柱子比栈顶元素小，那么我们就找到了栈顶元素右边第一个比它小的柱子。</p>
<p>具体步骤如下：</p>
<ol>
<li>初始化一个栈，为了简化计算，我们在柱状图的两端各添加一个高度为0的柱子。</li>
<li>从左到右遍历柱状图，对于每根柱子：
<ul>
<li>当前柱子的高度大于栈顶柱子的高度时，将当前柱子的下标入栈。</li>
<li>当前柱子的高度小于栈顶柱子的高度时，说明找到了栈顶柱子右边第一个比它小的柱子。此时，将栈顶柱子出栈，并计算以该柱子为高度的矩形的面积，直到栈顶柱子的高度小于当前柱子的高度。然后，将当前柱子的下标入栈。</li>
</ul>
</li>
<li>最后，栈中剩余的柱子，它们的右边界都是柱状图的最右边，可以按照步骤2同样的方法计算面积。</li>
</ol>
<h3 id="【实现代码】-39">【实现代码】</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largestRectangleArea</span><span class="params">(heights []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">//防止严格递增或递减的情况，收尾都加上0</span></span><br><span class="line">	heights = <span class="built_in">append</span>([]<span class="type">int</span>&#123;<span class="number">0</span>&#125;, heights...)</span><br><span class="line">	heights = <span class="built_in">append</span>(heights, <span class="number">0</span>)</span><br><span class="line">	stack := []<span class="type">int</span>&#123;<span class="number">0</span>&#125;</span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i,height := <span class="keyword">range</span> heights &#123;</span><br><span class="line">		<span class="keyword">if</span> height &gt; heights[stack[<span class="built_in">len</span>(stack) <span class="number">-1</span>]] &#123;</span><br><span class="line">			stack = <span class="built_in">append</span>(stack, i)</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> height ==  heights[stack[<span class="built_in">len</span>(stack) <span class="number">-1</span>]] &#123;</span><br><span class="line">			stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">			stack = <span class="built_in">append</span>(stack, i)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &amp;&amp; height &lt;  heights[stack[<span class="built_in">len</span>(stack) <span class="number">-1</span>]]&#123;</span><br><span class="line">				mid := stack[<span class="built_in">len</span>(stack) <span class="number">-1</span>]</span><br><span class="line">				stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">					l := stack[<span class="built_in">len</span>(stack) <span class="number">-1</span>]</span><br><span class="line">					width := i-l<span class="number">-1</span></span><br><span class="line">					</span><br><span class="line">					res = max(res, width * heights[mid])</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">			stack = <span class="built_in">append</span>(stack, i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数，求两个整数的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/categories/">Category</a></li>
        
          <li><a href="/tags/">Tag</a></li>
        
          <li><a href="/search">Search</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/jonasrepo.github.io">Projects</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">核心</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E9%83%A8%E6%9B%B2"><span class="toc-number">1.1.</span> <span class="toc-text">五部曲</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%BD%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.</span> <span class="toc-text">能解决的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0"><span class="toc-number">1.3.</span> <span class="toc-text">509 斐波那契数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91"><span class="toc-number">1.3.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91"><span class="toc-number">1.3.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91"><span class="toc-number">1.3.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#70-%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-number">1.4.</span> <span class="toc-text">70 爬楼梯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-2"><span class="toc-number">1.4.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-2"><span class="toc-number">1.4.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-2"><span class="toc-number">1.4.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-number">1.5.</span> <span class="toc-text">746 使用最小花费爬楼梯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-3"><span class="toc-number">1.5.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-3"><span class="toc-number">1.5.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-3"><span class="toc-number">1.5.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="toc-number">1.6.</span> <span class="toc-text">62 不同路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-4"><span class="toc-number">1.6.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-4"><span class="toc-number">1.6.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-4"><span class="toc-number">1.6.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-II"><span class="toc-number">1.7.</span> <span class="toc-text">63 不同路径 II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-5"><span class="toc-number">1.7.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-5"><span class="toc-number">1.7.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-5"><span class="toc-number">1.7.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#343-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86"><span class="toc-number">1.8.</span> <span class="toc-text">343 整数拆分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-6"><span class="toc-number">1.8.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-6"><span class="toc-number">1.8.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-6"><span class="toc-number">1.8.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.9.</span> <span class="toc-text">96 不同的二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-7"><span class="toc-number">1.9.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-7"><span class="toc-number">1.9.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-7"><span class="toc-number">1.9.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="toc-number">1.10.</span> <span class="toc-text">416 分割等和子集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-8"><span class="toc-number">1.10.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-8"><span class="toc-number">1.10.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-8"><span class="toc-number">1.10.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1049-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F-II"><span class="toc-number">1.11.</span> <span class="toc-text">1049 最后一块石头的重量 II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-9"><span class="toc-number">1.11.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-9"><span class="toc-number">1.11.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-9"><span class="toc-number">1.11.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#494-%E7%9B%AE%E6%A0%87%E5%92%8C"><span class="toc-number">1.12.</span> <span class="toc-text">494 目标和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-10"><span class="toc-number">1.12.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-10"><span class="toc-number">1.12.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-10"><span class="toc-number">1.12.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#474-%E4%B8%80%E5%92%8C%E9%9B%B6"><span class="toc-number">1.13.</span> <span class="toc-text">474 一和零</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-11"><span class="toc-number">1.13.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-11"><span class="toc-number">1.13.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-11"><span class="toc-number">1.13.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-II"><span class="toc-number">1.14.</span> <span class="toc-text">518 零钱兑换 II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-12"><span class="toc-number">1.14.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-12"><span class="toc-number">1.14.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-12"><span class="toc-number">1.14.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%E2%85%A3"><span class="toc-number">1.15.</span> <span class="toc-text">377 组合总和 Ⅳ</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-13"><span class="toc-number">1.15.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-13"><span class="toc-number">1.15.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-13"><span class="toc-number">1.15.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="toc-number">1.16.</span> <span class="toc-text">322 零钱兑换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-14"><span class="toc-number">1.16.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-14"><span class="toc-number">1.16.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-14"><span class="toc-number">1.16.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="toc-number">1.17.</span> <span class="toc-text">279 完全平方数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-15"><span class="toc-number">1.17.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-15"><span class="toc-number">1.17.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-15"><span class="toc-number">1.17.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="toc-number">1.18.</span> <span class="toc-text">139 单词拆分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-16"><span class="toc-number">1.18.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-16"><span class="toc-number">1.18.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-16"><span class="toc-number">1.18.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-number">1.19.</span> <span class="toc-text">198 打家劫舍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-17"><span class="toc-number">1.19.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-17"><span class="toc-number">1.19.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-17"><span class="toc-number">1.19.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#213-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-II"><span class="toc-number">1.20.</span> <span class="toc-text">213 打家劫舍 II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-18"><span class="toc-number">1.20.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-18"><span class="toc-number">1.20.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-18"><span class="toc-number">1.20.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#337-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-III"><span class="toc-number">1.21.</span> <span class="toc-text">337 打家劫舍 III</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-19"><span class="toc-number">1.21.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-19"><span class="toc-number">1.21.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-19"><span class="toc-number">1.21.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="toc-number">1.22.</span> <span class="toc-text">121 买卖股票的最佳时机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-20"><span class="toc-number">1.22.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-20"><span class="toc-number">1.22.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-20"><span class="toc-number">1.22.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II"><span class="toc-number">1.23.</span> <span class="toc-text">122 买卖股票的最佳时机 II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-21"><span class="toc-number">1.23.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-21"><span class="toc-number">1.23.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-21"><span class="toc-number">1.23.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-III"><span class="toc-number">1.24.</span> <span class="toc-text">123 买卖股票的最佳时机 III</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-22"><span class="toc-number">1.24.1.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-22"><span class="toc-number">1.24.2.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-IV"><span class="toc-number">1.25.</span> <span class="toc-text">188 买卖股票的最佳时机 IV</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-22"><span class="toc-number">1.25.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-23"><span class="toc-number">1.25.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-23"><span class="toc-number">1.25.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F"><span class="toc-number">1.26.</span> <span class="toc-text">309 最佳买卖股票时机含冷冻期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-23"><span class="toc-number">1.26.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-24"><span class="toc-number">1.26.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-24"><span class="toc-number">1.26.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9"><span class="toc-number">1.27.</span> <span class="toc-text">714 买卖股票的最佳时机含手续费</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-24"><span class="toc-number">1.27.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-25"><span class="toc-number">1.27.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-25"><span class="toc-number">1.27.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">1.28.</span> <span class="toc-text">300 最长递增子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-25"><span class="toc-number">1.28.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-26"><span class="toc-number">1.28.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-26"><span class="toc-number">1.28.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#674-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97"><span class="toc-number">1.29.</span> <span class="toc-text">674 最长连续递增序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-26"><span class="toc-number">1.29.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-27"><span class="toc-number">1.29.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-27"><span class="toc-number">1.29.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#718-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">1.30.</span> <span class="toc-text">718 最长重复子数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-27"><span class="toc-number">1.30.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-28"><span class="toc-number">1.30.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-28"><span class="toc-number">1.30.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">1.31.</span> <span class="toc-text">1143 最长公共子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-28"><span class="toc-number">1.31.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-29"><span class="toc-number">1.31.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-29"><span class="toc-number">1.31.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1035-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF%EF%BC%88%E7%AD%89%E5%90%8C%E4%BA%8E%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%89"><span class="toc-number">1.32.</span> <span class="toc-text">1035 不相交的线（等同于最长公共子序列）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-29"><span class="toc-number">1.32.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-30"><span class="toc-number">1.32.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-30"><span class="toc-number">1.32.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-number">1.33.</span> <span class="toc-text">53 最大子数组和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-30"><span class="toc-number">1.33.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-31"><span class="toc-number">1.33.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-31"><span class="toc-number">1.33.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#392-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">1.34.</span> <span class="toc-text">392 判断子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-31"><span class="toc-number">1.34.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-32"><span class="toc-number">1.34.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-32"><span class="toc-number">1.34.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#115-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">1.35.</span> <span class="toc-text">115 不同的子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-32"><span class="toc-number">1.35.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-33"><span class="toc-number">1.35.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-33"><span class="toc-number">1.35.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#583-%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">1.36.</span> <span class="toc-text">583 两个字符串的删除操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-33"><span class="toc-number">1.36.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-34"><span class="toc-number">1.36.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-34"><span class="toc-number">1.36.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="toc-number">1.37.</span> <span class="toc-text">72 编辑距离</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-34"><span class="toc-number">1.37.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-35"><span class="toc-number">1.37.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-35"><span class="toc-number">1.37.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-number">1.38.</span> <span class="toc-text">647 回文子串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-35"><span class="toc-number">1.38.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-36"><span class="toc-number">1.38.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-36"><span class="toc-number">1.38.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#516-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">1.39.</span> <span class="toc-text">516 最长回文子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-36"><span class="toc-number">1.39.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-37"><span class="toc-number">1.39.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-37"><span class="toc-number">1.39.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="toc-number">1.40.</span> <span class="toc-text">42 接雨水</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-37"><span class="toc-number">1.40.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-38"><span class="toc-number">1.40.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-38"><span class="toc-number">1.40.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2"><span class="toc-number">1.41.</span> <span class="toc-text">84 柱状图中最大的矩形</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-38"><span class="toc-number">1.41.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-39"><span class="toc-number">1.41.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-39"><span class="toc-number">1.41.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://localhost:4000/2024/03/11/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://localhost:4000/2024/03/11/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&text=动态规划"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://localhost:4000/2024/03/11/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&title=动态规划"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://localhost:4000/2024/03/11/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&is_video=false&description=动态规划"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=动态规划&body=Check out this article: http://localhost:4000/2024/03/11/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://localhost:4000/2024/03/11/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&title=动态规划"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://localhost:4000/2024/03/11/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&title=动态规划"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://localhost:4000/2024/03/11/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&title=动态规划"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://localhost:4000/2024/03/11/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&title=动态规划"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://localhost:4000/2024/03/11/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&name=动态规划&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://localhost:4000/2024/03/11/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&t=动态规划"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2024
    jonas
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/categories/">Category</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a href="/search">Search</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/jonasrepo.github.io">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
