<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="&gt; 原理 回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案为了让回溯法高效一些，会加一些剪枝的操作回溯法解决的问题都可以抽象为树形结构，集合的大小就构成了树的宽度，递归的深度构成的树的深度  回溯法，一般可以解决如下几种问题：  组合问题（不强调顺序）：N个数里面按一定规则找出k个数的集合 排列问题（强调顺序）：N个数按一定规则全排列，有几种排列方式 切割问题：一个字符串按一定规则有几">
<meta property="og:type" content="article">
<meta property="og:title" content="回溯">
<meta property="og:url" content="http://localhost:4000/2024/03/26/leetcode/%E5%9B%9E%E6%BA%AF/index.html">
<meta property="og:site_name" content="Jonas">
<meta property="og:description" content="&gt; 原理 回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案为了让回溯法高效一些，会加一些剪枝的操作回溯法解决的问题都可以抽象为树形结构，集合的大小就构成了树的宽度，递归的深度构成的树的深度  回溯法，一般可以解决如下几种问题：  组合问题（不强调顺序）：N个数里面按一定规则找出k个数的集合 排列问题（强调顺序）：N个数按一定规则全排列，有几种排列方式 切割问题：一个字符串按一定规则有几">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png">
<meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20201124201331223.png">
<meta property="og:image" content="https://www.hello-algo.com/chapter_backtracking/n_queens_problem.assets/n_queens_placing.png">
<meta property="article:published_time" content="2024-03-26T03:23:24.947Z">
<meta property="article:modified_time" content="2024-05-28T01:32:25.526Z">
<meta property="article:author" content="jonas">
<meta property="article:tag" content="leetcode">
<meta property="article:tag" content="回溯">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>回溯</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<meta name="generator" content="Hexo 7.1.1"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/categories/">Category</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a href="/search">Search</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/jonasrepo.github.io">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2024/03/28/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2024/03/11/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://localhost:4000/2024/03/26/leetcode/%E5%9B%9E%E6%BA%AF/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://localhost:4000/2024/03/26/leetcode/%E5%9B%9E%E6%BA%AF/&text=回溯"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://localhost:4000/2024/03/26/leetcode/%E5%9B%9E%E6%BA%AF/&title=回溯"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://localhost:4000/2024/03/26/leetcode/%E5%9B%9E%E6%BA%AF/&is_video=false&description=回溯"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=回溯&body=Check out this article: http://localhost:4000/2024/03/26/leetcode/%E5%9B%9E%E6%BA%AF/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://localhost:4000/2024/03/26/leetcode/%E5%9B%9E%E6%BA%AF/&title=回溯"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://localhost:4000/2024/03/26/leetcode/%E5%9B%9E%E6%BA%AF/&title=回溯"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://localhost:4000/2024/03/26/leetcode/%E5%9B%9E%E6%BA%AF/&title=回溯"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://localhost:4000/2024/03/26/leetcode/%E5%9B%9E%E6%BA%AF/&title=回溯"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://localhost:4000/2024/03/26/leetcode/%E5%9B%9E%E6%BA%AF/&name=回溯&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://localhost:4000/2024/03/26/leetcode/%E5%9B%9E%E6%BA%AF/&t=回溯"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">&gt; 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90"><span class="toc-number">1.1.</span> <span class="toc-text">22 括号生成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91"><span class="toc-number">1.1.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91"><span class="toc-number">1.1.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91"><span class="toc-number">1.1.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-number">2.</span> <span class="toc-text">题目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#77-%E7%BB%84%E5%90%88"><span class="toc-number">2.1.</span> <span class="toc-text">77 组合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-1"><span class="toc-number">2.1.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-1"><span class="toc-number">2.1.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-1"><span class="toc-number">2.1.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III"><span class="toc-number">2.2.</span> <span class="toc-text">216 组合总和 III</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-2"><span class="toc-number">2.2.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-2"><span class="toc-number">2.2.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-2"><span class="toc-number">2.2.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span class="toc-number">2.3.</span> <span class="toc-text">17 电话号码的字母组合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-3"><span class="toc-number">2.3.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-3"><span class="toc-number">2.3.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-3"><span class="toc-number">2.3.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-number">2.4.</span> <span class="toc-text">39 组合总和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-4"><span class="toc-number">2.4.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-4"><span class="toc-number">2.4.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-4"><span class="toc-number">2.4.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II"><span class="toc-number">2.5.</span> <span class="toc-text">40 组合总和 II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-5"><span class="toc-number">2.5.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-5"><span class="toc-number">2.5.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-5"><span class="toc-number">2.5.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="toc-number">2.6.</span> <span class="toc-text">131 分割回文串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-6"><span class="toc-number">2.6.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-6"><span class="toc-number">2.6.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-6"><span class="toc-number">2.6.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#93-%E5%A4%8D%E5%8E%9F-IP-%E5%9C%B0%E5%9D%80"><span class="toc-number">2.7.</span> <span class="toc-text">93 复原 IP 地址</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-7"><span class="toc-number">2.7.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-7"><span class="toc-number">2.7.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-7"><span class="toc-number">2.7.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#78-%E5%AD%90%E9%9B%86"><span class="toc-number">2.8.</span> <span class="toc-text">78 子集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-8"><span class="toc-number">2.8.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-8"><span class="toc-number">2.8.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-8"><span class="toc-number">2.8.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#90-%E5%AD%90%E9%9B%86-II"><span class="toc-number">2.9.</span> <span class="toc-text">90 子集 II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-9"><span class="toc-number">2.9.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-9"><span class="toc-number">2.9.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-9"><span class="toc-number">2.9.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#491-%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">2.10.</span> <span class="toc-text">491 递增子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-10"><span class="toc-number">2.10.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-10"><span class="toc-number">2.10.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-10"><span class="toc-number">2.10.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46-%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-number">2.11.</span> <span class="toc-text">46 全排列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-11"><span class="toc-number">2.11.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-11"><span class="toc-number">2.11.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-11"><span class="toc-number">2.11.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#47-%E5%85%A8%E6%8E%92%E5%88%97-II"><span class="toc-number">2.12.</span> <span class="toc-text">47 全排列 II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-12"><span class="toc-number">2.12.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-12"><span class="toc-number">2.12.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-12"><span class="toc-number">2.12.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51-N%E7%9A%87%E5%90%8E"><span class="toc-number">2.13.</span> <span class="toc-text">51 N皇后</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-13"><span class="toc-number">2.13.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-13"><span class="toc-number">2.13.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-13"><span class="toc-number">2.13.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        回溯
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">jonas</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-03-26T03:23:24.947Z" class="dt-published" itemprop="datePublished">2024-03-26</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/leetcode/">leetcode</a>
    </div>


      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/leetcode/" rel="tag">leetcode</a>, <a class="p-category" href="/tags/%E5%9B%9E%E6%BA%AF/" rel="tag">回溯</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1 id="原理"><a href="#原理" class="headerlink" title="&gt; 原理"></a>&gt; 原理</h1><blockquote>
<p>回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案<br>为了让回溯法高效一些，会加一些剪枝的操作<br>回溯法解决的问题都可以抽象为树形结构，集合的大小就构成了树的宽度，递归的深度构成的树的深度</p>
</blockquote>
<p>回溯法，一般可以解决如下几种问题：</p>
<ul>
<li>组合问题（不强调顺序）：N个数里面按一定规则找出k个数的集合</li>
<li>排列问题（强调顺序）：N个数按一定规则全排列，有几种排列方式</li>
<li>切割问题：一个字符串按一定规则有几种切割方式</li>
<li>子集问题：一个N个数的集合里有多少符合条件的子集</li>
<li>棋盘问题：N皇后，解数独等等</li>
</ul>
<p>去重逻辑：<br>所有的去重都需要先对数组进行排序（递增子序列除外）</p>
<ol>
<li>对于组合类，子集类的去重 <code> i &gt; startIndex &amp;&amp; candidates[i] == candidates[i-1]</code></li>
<li>递增子序列，不能排序，因为会改变顺序，在for循环外层定义used数组，循环里对数组赋值，且不需要对used做回溯处理 <code>(len(path)&gt; 0 &amp;&amp;  path[len(path)-1] &gt; nums[i]) || used[nums[i]]</code></li>
<li>全排列，顶层定义used数组，<code>i&gt;0 &amp;&amp; nums[i] == nums[i-1]) &amp;&amp; !used[i-1]</code></li>
</ol>
<p>递归流程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/* 回溯算法框架 */</span><br><span class="line">// 如果有重复元素，防止重复元素出现，需要先对数组排序，然后加上if i&gt;start &amp;&amp; nums[i] == nums[i-1]:continue 剪枝处理</span><br><span class="line">func backtrack(state *State, choices []Choice, res *[]State) &#123;</span><br><span class="line">    // 判断是否为解</span><br><span class="line">    if isSolution(state) &#123;</span><br><span class="line">        // 记录解</span><br><span class="line">        recordSolution(state, res)</span><br><span class="line">        // 不再继续搜索</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    // 遍历所有选择</span><br><span class="line">    //start 是否从0开始决定了元素是否需要重复取</span><br><span class="line">    // i:= start 标识不能重复取</span><br><span class="line">    for i:=0;i&lt;len(chocices);i++ &#123;</span><br><span class="line">	    //如果只需要取一个元素则是choices[i]， 如果是一段元素，可能是choices[start:i+1]</span><br><span class="line">	    choice ：= choices[i]</span><br><span class="line">        // 剪枝：判断选择是否合法</span><br><span class="line">        if isValid(state, choice) &#123;</span><br><span class="line">            // 尝试：做出选择，更新状态</span><br><span class="line">            makeChoice(state, choice)</span><br><span class="line">            backtrack(state, choices, res)</span><br><span class="line">            // 回退：撤销选择，恢复到之前的状态</span><br><span class="line">            undoChoice(state, choice)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22 括号生成"></a>22 括号生成</h2><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p>
<p>例如，给出 n &#x3D; 3，一个可能的解为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &quot;((()))&quot;,</span><br><span class="line">  &quot;(()())&quot;,</span><br><span class="line">  &quot;(())()&quot;,</span><br><span class="line">  &quot;()(())&quot;,</span><br><span class="line">  &quot;()()()&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="【解题思路】"><a href="#【解题思路】" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>本题可以使用回溯法解决。回溯法是一种通过探索所有可能的候选解来找出所有的解的算法。如果候选解被确认不是一个解（或者至少不是最后一个解），回溯算法会丢弃它，并且回退到之前的步骤，尝试其他可能的解。</p>
<p>对于这个题目，我们可以从空字符串开始，递归地添加左括号和右括号，但是要遵守以下规则：</p>
<ol>
<li>只有当还有左括号剩余时才能添加左括号。</li>
<li>只有当右括号的数量大于左括号的数量时才能添加右括号。</li>
<li>当左括号和右括号都添加完毕，形成一个有效的组合。</li>
</ol>
<p>通过这种方式，我们可以保证生成的括号组合是有效的。</p>
<h3 id="【实现代码】"><a href="#【实现代码】" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateParenthesis</span><span class="params">(n <span class="type">int</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> isValid <span class="function"><span class="keyword">func</span><span class="params">(str []<span class="type">byte</span>)</span></span> <span class="type">bool</span></span><br><span class="line">	isValid = <span class="function"><span class="keyword">func</span><span class="params">(str []<span class="type">byte</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		stack := []<span class="type">byte</span>&#123;&#125;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(str); i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> str[i] == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">				stack = <span class="built_in">append</span>(stack, str[i])</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(stack) &lt;= <span class="number">0</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] != <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">				&#125;</span><br><span class="line">				stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">len</span>(stack) == <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	res := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> backtrack <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">	path := []<span class="type">byte</span>&#123;&#125;</span><br><span class="line">	brack := []<span class="type">byte</span>&#123;<span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;)&#x27;</span>&#125;</span><br><span class="line">	backtrack = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(path) &gt; <span class="number">2</span>*n &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="number">2</span>*n &#123;</span><br><span class="line">			<span class="keyword">if</span> isValid(path) &#123;</span><br><span class="line">				res = <span class="built_in">append</span>(res, <span class="type">string</span>(path))</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">			path = <span class="built_in">append</span>(path, brack[i])</span><br><span class="line">			backtrack()</span><br><span class="line">			path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	backtrack()</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="77-组合"><a href="#77-组合" class="headerlink" title="77 组合"></a>77 组合</h2><h3 id="【题目描述】-1"><a href="#【题目描述】-1" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</p>
<p>你可以按 任何顺序 返回答案。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4, k = 2</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1, k = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li>1 &lt;&#x3D; n &lt;&#x3D; 20</li>
<li>1 &lt;&#x3D; k &lt;&#x3D; n</li>
</ul>
<h3 id="【解题思路】-1"><a href="#【解题思路】-1" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这道题可以使用回溯算法来解决。回溯算法是一种通过探索所有可能的候选解来找出所有的解的算法。如果候选解被确认不是一个解（或者至少不是最后一个解），回溯算法会通过在上一步进行一些变化抛弃该解，即回溯并且再次尝试。</p>
<p>具体思路如下：</p>
<ol>
<li>从数字1开始，递归地选择数字，直到选择的数字个数达到k个。</li>
<li>在选择过程中，需要保证选择的数字是递增的，且不能重复选择。</li>
<li>当选择的数字个数达到k个时，将当前选择的数字组合加入结果集合中。</li>
<li>回溯：将当前选择的数字从组合中移除，并尝试选择下一个数字。</li>
</ol>
<h3 id="【实现代码】-1"><a href="#【实现代码】-1" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(n <span class="type">int</span>, k <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result [][]<span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> combination []<span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> backtrack <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line">    </span><br><span class="line">    backtrack = <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(combination) == k &#123;</span><br><span class="line">            temp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(combination))</span><br><span class="line">            <span class="built_in">copy</span>(temp, combination)</span><br><span class="line">            result = <span class="built_in">append</span>(result, temp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i := start; i &lt;= n; i++ &#123;</span><br><span class="line">            combination = <span class="built_in">append</span>(combination, i)</span><br><span class="line">            backtrack(i + <span class="number">1</span>)</span><br><span class="line">            combination = combination[:<span class="built_in">len</span>(combination)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    backtrack(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216 组合总和 III"></a>216 组合总和 III</h2><h3 id="【题目描述】-2"><a href="#【题目描述】-2" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：</p>
<ul>
<li>只使用数字1到9</li>
<li>每个数字 最多使用一次</li>
</ul>
<p>返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: k = 3, n = 7</span><br><span class="line">输出: [[1,2,4]]</span><br><span class="line">解释:</span><br><span class="line">1 + 2 + 4 = 7</span><br><span class="line">没有其他符合的组合了。</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: k = 3, n = 9</span><br><span class="line">输出: [[1,2,6], [1,3,5], [2,3,4]]</span><br><span class="line">解释:</span><br><span class="line">1 + 2 + 6 = 9</span><br><span class="line">1 + 3 + 5 = 9</span><br><span class="line">2 + 3 + 4 = 9</span><br><span class="line">没有其他符合的组合了。</span><br></pre></td></tr></table></figure>

<p>示例 3:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: k = 4, n = 1</span><br><span class="line">输出: []</span><br><span class="line">解释: 不存在有效的组合。</span><br><span class="line">在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 &gt; 1，没有有效的组合。</span><br></pre></td></tr></table></figure>

<p>提示:</p>
<ul>
<li>2 &lt;&#x3D; k &lt;&#x3D; 9</li>
<li>1 &lt;&#x3D; n &lt;&#x3D; 60</li>
</ul>
<h3 id="【解题思路】-2"><a href="#【解题思路】-2" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这道题可以使用回溯算法来解决。我们可以从数字1开始，递归地选择数字，直到选择的数字个数达到k个，并且它们的和等于n。</p>
<p>具体思路如下：</p>
<ol>
<li>从数字1开始，递归地选择数字，直到选择的数字个数达到k个。</li>
<li>在选择过程中，需要保证选择的数字是递增的，且不能重复选择。</li>
<li>在选择过程中，记录当前选择的数字的和，如果和等于n，并且选择的数字个数等于k，则将当前选择的数字组合加入结果集合中。</li>
<li>如果当前选择的数字的和已经大于n，或者选择的数字个数已经达到k个，则不再继续选择，进行回溯。</li>
<li>回溯：将当前选择的数字从组合中移除，并尝试选择下一个数字。</li>
</ol>
<h3 id="【实现代码】-2"><a href="#【实现代码】-2" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum3</span><span class="params">(k <span class="type">int</span>, n <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">//和为n 的k个数</span></span><br><span class="line">	res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	path := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> backtrace <span class="function"><span class="keyword">func</span><span class="params">(left <span class="type">int</span>, start <span class="type">int</span>)</span></span> </span><br><span class="line">	backtrace = <span class="function"><span class="keyword">func</span><span class="params">(left <span class="type">int</span>, start <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(path) &gt; k || left &lt; <span class="number">0</span>&#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(path) == k  &amp;&amp; left == <span class="number">0</span>&#123;</span><br><span class="line">			<span class="built_in">copy</span> := <span class="built_in">append</span>([]<span class="type">int</span>(<span class="literal">nil</span>), path...)</span><br><span class="line">			res = <span class="built_in">append</span>(res, <span class="built_in">copy</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> i:=start;i&lt;=<span class="number">9</span>;i++ &#123;</span><br><span class="line">			path = <span class="built_in">append</span>(path, i)</span><br><span class="line">			backtrace(left-i, i+<span class="number">1</span>)</span><br><span class="line">			path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	backtrace(n, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17 电话号码的字母组合"></a>17 电话号码的字母组合</h2><h3 id="【题目描述】-3"><a href="#【题目描述】-3" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png" alt="image"></p>
<p>示例 1：<br>输入：digits &#x3D; “23”<br>输出：[“ad”,”ae”,”af”,”bd”,”be”,”bf”,”cd”,”ce”,”cf”]</p>
<p>示例 2：<br>输入：digits &#x3D; “”<br>输出：[]</p>
<p>示例 3：<br>输入：digits &#x3D; “2”<br>输出：[“a”,”b”,”c”]</p>
<h3 id="【解题思路】-3"><a href="#【解题思路】-3" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这道题可以使用回溯算法来解决。我们可以将数字字符串中的每个数字映射到对应的字母列表，然后通过回溯的方式生成所有可能的字母组合。</p>
<p>具体思路如下：</p>
<ol>
<li>创建一个映射表，将每个数字映射到对应的字母列表。</li>
<li>定义一个递归函数 backtrack，它接受当前的字母组合、剩余的数字字符串以及结果列表作为参数。</li>
<li>如果剩余的数字字符串为空，说明当前的字母组合已经完成，将其添加到结果列表中。</li>
<li>否则，取出当前数字字符串的第一个数字，获取其对应的字母列表。</li>
<li>遍历字母列表，将每个字母添加到当前的字母组合中，并递归调用 backtrack 函数，处理剩余的数字字符串。</li>
<li>递归结束后，将最后一个添加的字母从当前字母组合中移除，以回溯到上一层。</li>
<li>最终，结果列表中将包含所有可能的字母组合。</li>
</ol>
<h3 id="【实现代码】-3"><a href="#【实现代码】-3" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">letterCombinations</span><span class="params">(digits <span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">len</span>(digits) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> []<span class="type">string</span>&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	mp := <span class="keyword">map</span>[<span class="type">byte</span>][]<span class="type">byte</span>&#123;</span><br><span class="line">		<span class="string">&#x27;2&#x27;</span>: &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;,</span><br><span class="line">		<span class="string">&#x27;3&#x27;</span>: &#123;<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>&#125;,</span><br><span class="line">		<span class="string">&#x27;4&#x27;</span>: &#123;<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>&#125;,</span><br><span class="line">		<span class="string">&#x27;5&#x27;</span>: &#123;<span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;,</span><br><span class="line">		<span class="string">&#x27;6&#x27;</span>: &#123;<span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;,</span><br><span class="line">		<span class="string">&#x27;7&#x27;</span>: &#123;<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;s&#x27;</span>&#125;,</span><br><span class="line">		<span class="string">&#x27;8&#x27;</span>: &#123;<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;v&#x27;</span>&#125;,</span><br><span class="line">		<span class="string">&#x27;9&#x27;</span>: &#123;<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	res := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">	path := []<span class="type">byte</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> backtrace <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span></span><br><span class="line">	backtrace = <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(digits) &#123;</span><br><span class="line">			<span class="built_in">copy</span> := <span class="built_in">append</span>([]<span class="type">byte</span>(<span class="literal">nil</span>), path...)</span><br><span class="line">			res = <span class="built_in">append</span>(res, <span class="type">string</span>(<span class="built_in">copy</span>))</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> i := start; i &lt; <span class="built_in">len</span>(digits); i++ &#123;</span><br><span class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(mp[digits[i]]); j++ &#123;</span><br><span class="line">				path = <span class="built_in">append</span>(path, mp[digits[i]][j])</span><br><span class="line">				backtrace(i + <span class="number">1</span>)</span><br><span class="line">				path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	backtrace(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39 组合总和"></a>39 组合总和</h2><h3 id="【题目描述】-4"><a href="#【题目描述】-4" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p>
<p>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p>
<p>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p>
<p>示例 1：<br>输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7<br>输出：$[[2,2,3],[7]]$<br>解释：<br>2 和 3 可以形成一组候选，2 + 2 + 3 &#x3D; 7 。注意 2 可以使用多次。<br>7 也是一个候选， 7 &#x3D; 7 。<br>仅有这两种组合。</p>
<p>示例 2：<br>输入: candidates &#x3D; [2,3,5], target &#x3D; 8<br>输出:$[[2,2,2,2],[2,3,3],[3,5]]$</p>
<p>示例 3：<br>输入: candidates &#x3D; [2], target &#x3D; 1<br>输出: []</p>
<h3 id="【解题思路】-4"><a href="#【解题思路】-4" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这道题可以使用回溯算法来解决。我们可以将问题看作是在候选数组中选择数字，使得选择的数字之和等于目标值。</p>
<p>具体思路如下：</p>
<ol>
<li>定义一个递归函数 backtrack，它接受当前的组合、剩余的目标值以及当前考虑的候选数字的起始索引作为参数。</li>
<li>如果剩余的目标值为 0，说明当前的组合满足条件，将其添加到结果列表中。</li>
<li>如果剩余的目标值小于 0，说明当前的组合不满足条件，直接返回。</li>
<li>否则，从当前考虑的候选数字的起始索引开始遍历候选数组。</li>
<li>对于每个候选数字，将其添加到当前的组合中，并递归调用 backtrack 函数，更新剩余的目标值和下一个考虑的候选数字的起始索引。</li>
<li>递归结束后，将最后一个添加的候选数字从当前组合中移除，以回溯到上一层。</li>
<li>最终，结果列表中将包含所有满足条件的组合。</li>
</ol>
<h3 id="【实现代码】-4"><a href="#【实现代码】-4" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum</span><span class="params">(candidates []<span class="type">int</span>, target <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">	res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	path := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> backtrack <span class="function"><span class="keyword">func</span><span class="params">(start, left <span class="type">int</span>)</span></span></span><br><span class="line">	backtrack = <span class="function"><span class="keyword">func</span><span class="params">(start, left <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> left &lt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> left == <span class="number">0</span>  &#123;</span><br><span class="line">			res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="type">int</span>(<span class="literal">nil</span>), path...))</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> i:=start;i&lt;<span class="built_in">len</span>(candidates);i++ &#123;</span><br><span class="line">			path = <span class="built_in">append</span>(path, candidates[i])</span><br><span class="line">			backtrack(i, left-candidates[i])</span><br><span class="line">			path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	backtrack(<span class="number">0</span>, target)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40 组合总和 II"></a>40 组合总和 II</h2><h3 id="【题目描述】-5"><a href="#【题目描述】-5" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。<br>candidates 中的每个数字在每个组合中只能使用 一次 。<br>注意：解集不能包含重复的组合。<br>示例 1:<br>输入: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,<br>输出:<br>$$<br>[<br>[1,1,6],<br>[1,2,5],<br>[1,7],<br>[2,6]<br>]<br>$$</p>
<p>示例 2:<br>输入: candidates &#x3D; [2,5,2,1,2], target &#x3D; 5,<br>输出:</p>
<p>$$[<br>[1,2,2],<br>[5]<br>]$$</p>
<h3 id="【解题思路】-5"><a href="#【解题思路】-5" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这道题与组合总和类似，但有以下不同点：</p>
<ol>
<li>每个数字在每个组合中只能使用一次。</li>
<li>解集不能包含重复的组合。</li>
</ol>
<p>为了满足这些条件，我们可以对候选数组进行排序，然后在回溯的过程中进行去重操作。</p>
<p>具体思路如下：</p>
<ol>
<li>对候选数组进行排序，方便后续的去重操作。</li>
<li>定义一个递归函数 backtrack，它接受当前的组合、剩余的目标值以及当前考虑的候选数字的起始索引作为参数。</li>
<li>如果剩余的目标值为 0，说明当前的组合满足条件，将其添加到结果列表中。</li>
<li>如果剩余的目标值小于 0，说明当前的组合不满足条件，直接返回。</li>
<li>否则，从当前考虑的候选数字的起始索引开始遍历候选数组。</li>
<li>对于每个候选数字，如果它与前一个数字相同且前一个数字没有被使用过，则跳过当前数字，避免产生重复的组合。</li>
<li>将当前候选数字添加到组合中，并递归调用 backtrack 函数，更新剩余的目标值和下一个考虑的候选数字的起始索引。</li>
<li>递归结束后，将最后一个添加的候选数字从当前组合中移除，以回溯到上一层。</li>
<li>最终，结果列表中将包含所有满足条件的组合。</li>
</ol>
<h3 id="【实现代码】-5"><a href="#【实现代码】-5" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum2</span><span class="params">(candidates []<span class="type">int</span>, target <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result [][]<span class="type">int</span></span><br><span class="line">    <span class="comment">// 对候选数组进行排序</span></span><br><span class="line">    sort.Ints(candidates)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义回溯函数</span></span><br><span class="line">    <span class="keyword">var</span> backtrack <span class="function"><span class="keyword">func</span><span class="params">(combination []<span class="type">int</span>, remainingTarget <span class="type">int</span>, startIndex <span class="type">int</span>)</span></span></span><br><span class="line">    backtrack = <span class="function"><span class="keyword">func</span><span class="params">(combination []<span class="type">int</span>, remainingTarget <span class="type">int</span>, startIndex <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 如果剩余目标值为 0，将当前组合添加到结果列表中</span></span><br><span class="line">        <span class="keyword">if</span> remainingTarget == <span class="number">0</span> &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, <span class="built_in">append</span>([]<span class="type">int</span>&#123;&#125;, combination...))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果剩余目标值小于 0，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> remainingTarget &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从当前考虑的候选数字的起始索引开始遍历候选数组</span></span><br><span class="line">        <span class="keyword">for</span> i := startIndex; i &lt; <span class="built_in">len</span>(candidates); i++ &#123;</span><br><span class="line">            <span class="comment">// 如果当前数字与前一个数字相同且前一个数字被使用过，则跳过当前数字</span></span><br><span class="line">            <span class="comment">// 所以需要对数组进行排序</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; startIndex &amp;&amp; candidates[i] == candidates[i<span class="number">-1</span>] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将当前候选数字添加到组合中</span></span><br><span class="line">            combination = <span class="built_in">append</span>(combination, candidates[i])</span><br><span class="line">            <span class="comment">// 递归调用回溯函数，更新剩余目标值和下一个考虑的候选数字的起始索引</span></span><br><span class="line">            backtrack(combination, remainingTarget-candidates[i], i+<span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 回溯，移除最后一个添加的候选数字</span></span><br><span class="line">            combination = combination[:<span class="built_in">len</span>(combination)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用回溯函数，生成组合</span></span><br><span class="line">    backtrack([]<span class="type">int</span>&#123;&#125;, target, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131 分割回文串"></a>131 分割回文串</h2><h3 id="【题目描述】-6"><a href="#【题目描述】-6" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。</p>
<p>回文串 是正着读和反着读都一样的字符串。</p>
<p>示例 1：<br>输入：s &#x3D; “aab”<br>输出：[[“a”,”a”,”b”],[“aa”,”b”]]</p>
<p>示例 2：<br>输入：s &#x3D; “a”<br>输出：[[“a”]]</p>
<h3 id="【解题思路】-6"><a href="#【解题思路】-6" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这道题可以使用回溯算法来解决。我们可以将问题看作是在字符串中选择分割点，使得分割后的每个子串都是回文串。</p>
<p>具体思路如下：</p>
<ol>
<li>定义一个递归函数 backtrack，它接受当前的分割方案、剩余的字符串以及字符串的起始索引作为参数。</li>
<li>如果剩余字符串为空，说明当前的分割方案满足条件，将其添加到结果列表中。</li>
<li>否则，从当前字符串的起始索引开始遍历字符串。</li>
<li>对于每个可能的分割点，判断从起始索引到分割点之间的子串是否为回文串。</li>
<li>如果是回文串，将其添加到当前的分割方案中，并递归调用 backtrack 函数，处理剩余的字符串。</li>
<li>递归结束后，将最后一个添加的子串从当前分割方案中移除，以回溯到上一层。</li>
<li>最终，结果列表中将包含所有可能的分割方案。</li>
</ol>
<h3 id="【实现代码】-6"><a href="#【实现代码】-6" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(s <span class="type">string</span>)</span></span> [][]<span class="type">string</span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(s)</span><br><span class="line">	res := [][]<span class="type">string</span>&#123;&#125;</span><br><span class="line">	path := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> backtrace <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span></span><br><span class="line">	backtrace = <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> start &gt; n &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> start  == n &#123;</span><br><span class="line">			res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="type">string</span>(<span class="literal">nil</span>), path...))</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> i := start; i &lt; n; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> isPaladim(s[start:i+<span class="number">1</span>]) &#123;</span><br><span class="line">				path = <span class="built_in">append</span>(path, s[start:i+<span class="number">1</span>])</span><br><span class="line">				backtrace(i+<span class="number">1</span>)</span><br><span class="line">				path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	backtrace(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPaladim</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	l, r := <span class="number">0</span>, <span class="built_in">len</span>(s)<span class="number">-1</span></span><br><span class="line">	<span class="keyword">for</span> l &lt;= r &#123;</span><br><span class="line">		<span class="keyword">if</span> s[l] != s[r] &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		l++</span><br><span class="line">		r--</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="93-复原-IP-地址"><a href="#93-复原-IP-地址" class="headerlink" title="93 复原 IP 地址"></a>93 复原 IP 地址</h2><h3 id="【题目描述】-7"><a href="#【题目描述】-7" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p>
<p>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:&#49;&#57;&#50;&#46;&#x31;&#54;&#56;&#64;&#x31;&#46;&#x31;">&#49;&#57;&#50;&#46;&#x31;&#54;&#56;&#64;&#x31;&#46;&#x31;</a>“ 是 无效 IP 地址。<br>给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。</p>
<p>示例 1：<br>输入：s &#x3D; “25525511135”<br>输出：[“255.255.11.135”,”255.255.111.35”]</p>
<p>示例 2：<br>输入：s &#x3D; “0000”<br>输出：[“0.0.0.0”]</p>
<p>示例 3：<br>输入：s &#x3D; “101023”<br>输出：[“1.0.10.23”,”1.0.102.3”,”10.1.0.23”,”10.10.2.3”,”101.0.2.3”]</p>
<h3 id="【解题思路】-7"><a href="#【解题思路】-7" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这道题可以使用回溯算法来解决。我们可以将问题看作是在字符串中选择三个分割点，使得分割后的四个子串都是有效的 IP 地址段</p>
<h3 id="【实现代码】-7"><a href="#【实现代码】-7" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">restoreIpAddresses</span><span class="params">(s <span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(s)</span><br><span class="line">	res := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">	path := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> backtrace <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span></span><br><span class="line">	backtrace = <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> start &gt; n &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> start == n &amp;&amp; <span class="built_in">len</span>(path) == <span class="number">4</span> &#123;</span><br><span class="line">			res = <span class="built_in">append</span>(res, strings.Join(path, <span class="string">&quot;.&quot;</span>))</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> i := start; i &lt; n; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> isValid(s[start : i+<span class="number">1</span>]) &#123;</span><br><span class="line">				path = <span class="built_in">append</span>(path, s[start:i+<span class="number">1</span>])</span><br><span class="line">				backtrace(i + <span class="number">1</span>)</span><br><span class="line">				path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	backtrace(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; <span class="number">1</span> &amp;&amp; s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">3</span> &amp;&amp; s &gt;<span class="string">&quot;255&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; <span class="number">3</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78 子集"></a>78 子集</h2><h3 id="【题目描述】-8"><a href="#【题目描述】-8" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p>
<p>示例 1：<br>输入：nums &#x3D; [1,2,3]<br>输出：$[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]$</p>
<p>示例 2：<br>输入：nums &#x3D; [0]<br>输出：$[[],[0]]$</p>
<h3 id="【解题思路】-8"><a href="#【解题思路】-8" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这道题可以使用回溯算法来解决。我们可以将问题看作是在数组中选择或不选择每个元素，生成所有可能的子集。</p>
<p>具体思路如下：</p>
<ol>
<li>定义一个递归函数 backtrack，它接受当前的子集、剩余的数组以及当前考虑的元素的索引作为参数。</li>
<li>将当前的子集添加到结果列表中，因为空集也是一个有效的子集。</li>
<li>从当前考虑的元素的索引开始遍历数组。</li>
<li>对于每个元素，我们有两种选择：<ul>
<li>将当前元素添加到子集中，并递归调用 backtrack 函数，处理剩余的数组和下一个元素的索引。</li>
<li>不将当前元素添加到子集中，直接递归调用 backtrack 函数，处理剩余的数组和下一个元素的索引。</li>
</ul>
</li>
<li>递归结束后，我们将得到所有可能的子集。</li>
</ol>
<h3 id="【实现代码】-8"><a href="#【实现代码】-8" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsets</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">	res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	path := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	n := <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> backtrace <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span></span><br><span class="line">	backtrace = <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		</span><br><span class="line">		res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="type">int</span>(<span class="literal">nil</span>), path...))</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> i := start; i &lt; n; i++ &#123;</span><br><span class="line">			path = <span class="built_in">append</span>(path, nums[i])</span><br><span class="line">			backtrace(i + <span class="number">1</span>)</span><br><span class="line">			path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	backtrace(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90 子集 II"></a>90 子集 II</h2><h3 id="【题目描述】-9"><a href="#【题目描述】-9" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,2]</span><br><span class="line">输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure>

<h3 id="【解题思路】-9"><a href="#【解题思路】-9" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题可以通过回溯算法来解决。回溯算法是一种通过探索所有可能的候选解来找出所有的解的算法。对于这个问题，我们可以从空集开始，逐步添加元素构建子集。</p>
<ol>
<li><strong>排序</strong>：首先，将数组排序。这样做是为了让重复的元素在数组中相邻，便于我们在后面的步骤中跳过重复的子集。</li>
<li><strong>回溯</strong>：然后，我们使用回溯法逐个访问数组中的每个元素，考虑将它加入当前子集中或不加入。对于加入的情况，我们将元素添加到当前子集中，然后进行下一步递归；对于不加入的情况，我们直接进行下一步递归。</li>
<li><strong>去重</strong>：在每一步递归调用之前，如果当前元素和前一个元素相同，且前一个元素没有被加入到子集中，我们则跳过当前元素，以避免生成重复的子集。</li>
</ol>
<p>通过这种方法，我们可以生成所有不重复的子集。</p>
<h3 id="【实现代码】-9"><a href="#【实现代码】-9" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsetsWithDup</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">	res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	path := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	n := <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="comment">// 和78相比，多了个去重的要求</span></span><br><span class="line">	sort.Ints(nums)</span><br><span class="line">	<span class="keyword">var</span> backtrace <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span></span><br><span class="line">	backtrace = <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="type">int</span>(<span class="literal">nil</span>), path...))</span><br><span class="line">		<span class="keyword">for</span> i := start; i &lt; n; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> i&gt;start &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			path = <span class="built_in">append</span>(path, nums[i])</span><br><span class="line">			backtrace(i + <span class="number">1</span>)</span><br><span class="line">			path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	backtrace(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="491-递增子序列"><a href="#491-递增子序列" class="headerlink" title="491 递增子序列"></a>491 递增子序列</h2><h3 id="【题目描述】-10"><a href="#【题目描述】-10" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个整型数组，你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是 2。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4, 6, 7, 7]</span><br><span class="line">输出: [[4, 6], [4, 6, 7], [4, 6, 7, 7], [4, 7], [4, 7, 7], [6, 7], [6, 7, 7], [7,7]]</span><br></pre></td></tr></table></figure>

<h3 id="【解题思路】-10"><a href="#【解题思路】-10" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题可以通过回溯法来解决。关键点在于如何避免生成重复的子序列，以及如何确保子序列是递增的。</p>
<ol>
<li><p><strong>去重复</strong>：为了避免生成重复的子序列，我们可以在同一深度的递归中，如果当前元素与前一个元素相同，就跳过当前元素。</p>
</li>
<li><p><strong>保持递增</strong>：为了确保子序列是递增的，我们只在当前元素不小于子序列的最后一个元素时，才将当前元素添加到子序列中。</p>
</li>
<li><p><strong>回溯法</strong>：从数组的第一个元素开始，尝试所有可能的递增子序列组合。对于每个元素，我们有两个选择：包含这个元素或不包含。如果包含这个元素，我们就将它添加到当前的子序列中，并继续递归。如果不包含，我们直接进行下一步递归。</p>
</li>
<li><p><strong>终止条件</strong>：当我们处理完数组中的所有元素后，如果当前子序列的长度至少为2，则将其添加到结果集中。</p>
</li>
</ol>
<h3 id="【实现代码】-10"><a href="#【实现代码】-10" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findSubsequences</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">	res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	path := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	n := <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="keyword">var</span> backtrack <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span></span><br><span class="line">	backtrack = <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		<span class="comment">//满足要求</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(path) &gt;= <span class="number">2</span>&#123;</span><br><span class="line">			res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="type">int</span>(<span class="literal">nil</span>), path...))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//这个要求不改变顺序的递增，所以不能使用i&gt;start &amp;&amp; nums[i] == nums[i-1]这种方式来去重</span></span><br><span class="line">		<span class="comment">//需要引入map来对每一层去重，注意used是定义在backtrack之内的，且没有对used的撤回操作，因为是对每一层进行去重</span></span><br><span class="line">		used := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>&#123;&#125;</span><br><span class="line">		<span class="keyword">for</span> i := start; i &lt; n; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">len</span>(path)&gt; <span class="number">0</span> &amp;&amp;  path[<span class="built_in">len</span>(path)<span class="number">-1</span>] &gt; nums[i]) || used[nums[i]] &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			used[nums[i]] = <span class="literal">true</span></span><br><span class="line">			path = <span class="built_in">append</span>(path, nums[i])</span><br><span class="line">			backtrack(i + <span class="number">1</span>)</span><br><span class="line">			path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	backtrack(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46 全排列"></a>46 全排列</h2><h3 id="【题目描述】-11"><a href="#【题目描述】-11" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个不含重复数字的数组 <code>nums</code>，返回其所有可能的全排列。你可以按任意顺序返回答案。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="【解题思路】-11"><a href="#【解题思路】-11" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题是经典的回溯算法应用场景。要解决这个问题，我们可以遵循以下几个步骤：</p>
<ol>
<li><strong>选择路径</strong>：我们需要一个路径变量来记录我们到目前为止做的选择，即已经选择的数字。</li>
<li><strong>选择列表</strong>：我们需要知道我们当前可以做的选择，即还没有被选择的数字。</li>
<li><strong>结束条件</strong>：我们需要知道何时保存遍历到的结果，即路径变量的长度等于输入数组的长度。</li>
</ol>
<p>具体步骤如下：</p>
<ul>
<li>从数组的第一个元素开始，选择当前元素，然后进入下一层递归。</li>
<li>在递归中，从数组中选择一个还未被选择的元素，继续递归。</li>
<li>重复这个过程，直到所有的元素都被选择，这时我们得到了一个全排列，将其添加到结果列表中。</li>
<li>回溯到上一步，撤销上一步的选择，尝试其他的选择。</li>
</ul>
<p>通过这样的过程，我们可以遍历得到所有可能的全排列。</p>
<h3 id="【实现代码】-11"><a href="#【实现代码】-11" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permute</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">	res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	path := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	n := <span class="built_in">len</span>(nums)</span><br><span class="line">	used := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> backtrack <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">	backtrack = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(path) == n &#123;</span><br><span class="line">			res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="type">int</span>(<span class="literal">nil</span>), path...))</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> used[i] &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			path = <span class="built_in">append</span>(path, nums[i])</span><br><span class="line">			used[i] = <span class="literal">true</span></span><br><span class="line">			backtrack()</span><br><span class="line">			path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">			used[i] = <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	backtrack()</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47 全排列 II"></a>47 全排列 II</h2><h3 id="【题目描述】-12"><a href="#【题目描述】-12" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个可包含重复数字的序列 <code>nums</code>，返回所有不重复的全排列。</p>
<h3 id="【解题思路】-12"><a href="#【解题思路】-12" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>全排列问题通常可以使用回溯法解决，但在本题中由于序列中可能存在重复数字，因此需要额外地处理重复情况，避免生成重复的排列。<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201124201331223.png"><br>解题步骤如下：</p>
<ol>
<li><p>先对数组进行排序，这样相同的数字会相邻，方便后续的去重处理。</p>
</li>
<li><p>定义回溯函数<code>backtrack</code>，参数包括：当前处理的数字索引<code>first</code>、已选择的数字列表<code>chosen</code>和原始数组<code>nums</code>。</p>
</li>
<li><p>在<code>backtrack</code>中，首先检查是否已经选取了所有的数字（即<code>chosen</code>的长度是否等于<code>nums</code>的长度）。如果是，则找到了一个有效的全排列，将其添加到结果列表中。</p>
</li>
<li><p>如果还有未选择的数字，则从<code>first</code>开始遍历数组<code>nums</code>：</p>
<ul>
<li><p>检查当前数字<code>nums[i]</code>是否与前面的某个数字重复，且前面的数字尚未被选择（即<code>i &gt; first</code>且<code>nums[i] == nums[i-1]</code>且<code>!chosen[i-1]</code>）。如果是，则跳过当前数字，以避免生成重复的排列。</p>
</li>
<li><p>否则，将当前数字添加到<code>chosen</code>中，标记为已选择，并递归调用<code>backtrack</code>处理下一个数字。</p>
</li>
<li><p>回溯时，将当前数字从<code>chosen</code>中移除，标记为未选择，以便尝试其他可能的数字。</p>
</li>
</ul>
</li>
</ol>
<h3 id="【实现代码】-12"><a href="#【实现代码】-12" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permuteUnique</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">	res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	path := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	n := <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="comment">//需要排序</span></span><br><span class="line">	sort.Ints(nums)</span><br><span class="line">	used := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> backtrack <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">	backtrack = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(path) == n &#123;</span><br><span class="line">			res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="type">int</span>(<span class="literal">nil</span>), path...))</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">			<span class="comment">// nums[i] == nums[i-1] &amp;&amp; !used[i-1] 防止的是同一层重复 防止的是同一层重复</span></span><br><span class="line">			<span class="comment">// 同一层 上一次循环有相等元素，递归回溯后成了false</span></span><br><span class="line">			<span class="comment">//需要加上 !used[i-1]， 否则同一树枝上可能出现nums[i] == nums[i-1] 的情况，但是这种情况下used[i-1]是true</span></span><br><span class="line">			<span class="comment">// 这也是和第46题的区别</span></span><br><span class="line">			<span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) &amp;&amp; !used[i<span class="number">-1</span>] &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// used[i]保证的是树枝层不重复</span></span><br><span class="line">			<span class="keyword">if</span> used[i] &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			used[i] = <span class="literal">true</span></span><br><span class="line">			path = <span class="built_in">append</span>(path, nums[i])</span><br><span class="line">			backtrack()</span><br><span class="line">			path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">			used[i] = <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	backtrack()</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="51-N皇后"><a href="#51-N皇后" class="headerlink" title="51 N皇后"></a>51 N皇后</h2><h3 id="【题目描述】-13"><a href="#【题目描述】-13" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。给你一个整数 n ，返回所有不同的 n 皇后问题的解决方案。每一种解法包含一个不同的 n 皇后在棋盘上的位置，输出的解应该不包含重复的解。皇后可以攻击与之处在同一行、同一列或同一斜线上的棋子。</p>
<h3 id="【解题思路】-13"><a href="#【解题思路】-13" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>解决 N 皇后问题的一个有效方法是使用回溯法。回溯法是一种通过探索所有可能的候选解来找到所有解的算法。如果一个候选解最终不是一个解，那么回溯算法会丢弃它，并回溯到之前的步骤，尝试另一个可能的解。</p>
<p>对于 N 皇后问题，我们可以从第一行开始，尝试在每一列中放置一个皇后，然后移动到下一行。每当我们放置一个皇后时，我们需要检查当前位置是否安全（即在当前位置的行、列和对角线上没有其他皇后）。如果当前位置安全，我们继续在下一行放置另一个皇后。如果我们达到了一个状态，在当前行没有安全的位置可以放置皇后，我们就回溯到上一行，改变上一个皇后的位置。</p>
<p>通过递归实现回溯算法，我们可以找到所有可能的解决方案。<br><img src="https://www.hello-algo.com/chapter_backtracking/n_queens_problem.assets/n_queens_placing.png"></p>
<h3 id="【实现代码】-13"><a href="#【实现代码】-13" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;strings&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">solveNQueens</span><span class="params">(n <span class="type">int</span>)</span></span> [][]<span class="type">string</span> &#123;</span><br><span class="line">    results := [][]<span class="type">string</span>&#123;&#125;</span><br><span class="line">    board := <span class="built_in">make</span>([][]<span class="type">string</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> board &#123;</span><br><span class="line">        board[i] = <span class="built_in">make</span>([]<span class="type">string</span>, n)</span><br><span class="line">        <span class="keyword">for</span> j := <span class="keyword">range</span> board[i] &#123;</span><br><span class="line">            board[i][j] = <span class="string">&quot;.&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backtrack(&amp;results, board, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backtrack</span><span class="params">(results *[][]<span class="type">string</span>, board [][]<span class="type">string</span>, row <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> row == <span class="built_in">len</span>(board) &#123;</span><br><span class="line">        tempResult := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(board))</span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">range</span> board &#123;</span><br><span class="line">            tempResult[i] = strings.Join(board[i], <span class="string">&quot;&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        *results = <span class="built_in">append</span>(*results, tempResult)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    n := <span class="built_in">len</span>(board[row])</span><br><span class="line">    <span class="keyword">for</span> col := <span class="number">0</span>; col &lt; n; col++ &#123;</span><br><span class="line">        <span class="keyword">if</span> !isValid(board, row, col) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        board[row][col] = <span class="string">&quot;Q&quot;</span></span><br><span class="line">        backtrack(results, board, row+<span class="number">1</span>)</span><br><span class="line">        board[row][col] = <span class="string">&quot;.&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">(board [][]<span class="type">string</span>, row, col <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(board)</span><br><span class="line">    <span class="comment">// Check column</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; row; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> board[i][col] == <span class="string">&quot;Q&quot;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Check upper left diagonal</span></span><br><span class="line">    <span class="keyword">for</span> i, j := row<span class="number">-1</span>, col<span class="number">-1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i, j = i<span class="number">-1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> board[i][j] == <span class="string">&quot;Q&quot;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Check upper right diagonal</span></span><br><span class="line">    <span class="keyword">for</span> i, j := row<span class="number">-1</span>, col+<span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i, j = i<span class="number">-1</span>, j+<span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> board[i][j] == <span class="string">&quot;Q&quot;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Example: solve a 4-queens problem</span></span><br><span class="line">    results := solveNQueens(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> _, solution := <span class="keyword">range</span> results &#123;</span><br><span class="line">        <span class="keyword">for</span> _, row := <span class="keyword">range</span> solution &#123;</span><br><span class="line">            <span class="built_in">println</span>(row)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;------&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/categories/">Category</a></li>
        
          <li><a href="/tags/">Tag</a></li>
        
          <li><a href="/search">Search</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/jonasrepo.github.io">Projects</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">&gt; 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90"><span class="toc-number">1.1.</span> <span class="toc-text">22 括号生成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91"><span class="toc-number">1.1.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91"><span class="toc-number">1.1.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91"><span class="toc-number">1.1.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-number">2.</span> <span class="toc-text">题目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#77-%E7%BB%84%E5%90%88"><span class="toc-number">2.1.</span> <span class="toc-text">77 组合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-1"><span class="toc-number">2.1.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-1"><span class="toc-number">2.1.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-1"><span class="toc-number">2.1.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III"><span class="toc-number">2.2.</span> <span class="toc-text">216 组合总和 III</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-2"><span class="toc-number">2.2.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-2"><span class="toc-number">2.2.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-2"><span class="toc-number">2.2.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span class="toc-number">2.3.</span> <span class="toc-text">17 电话号码的字母组合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-3"><span class="toc-number">2.3.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-3"><span class="toc-number">2.3.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-3"><span class="toc-number">2.3.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-number">2.4.</span> <span class="toc-text">39 组合总和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-4"><span class="toc-number">2.4.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-4"><span class="toc-number">2.4.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-4"><span class="toc-number">2.4.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II"><span class="toc-number">2.5.</span> <span class="toc-text">40 组合总和 II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-5"><span class="toc-number">2.5.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-5"><span class="toc-number">2.5.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-5"><span class="toc-number">2.5.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="toc-number">2.6.</span> <span class="toc-text">131 分割回文串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-6"><span class="toc-number">2.6.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-6"><span class="toc-number">2.6.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-6"><span class="toc-number">2.6.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#93-%E5%A4%8D%E5%8E%9F-IP-%E5%9C%B0%E5%9D%80"><span class="toc-number">2.7.</span> <span class="toc-text">93 复原 IP 地址</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-7"><span class="toc-number">2.7.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-7"><span class="toc-number">2.7.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-7"><span class="toc-number">2.7.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#78-%E5%AD%90%E9%9B%86"><span class="toc-number">2.8.</span> <span class="toc-text">78 子集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-8"><span class="toc-number">2.8.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-8"><span class="toc-number">2.8.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-8"><span class="toc-number">2.8.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#90-%E5%AD%90%E9%9B%86-II"><span class="toc-number">2.9.</span> <span class="toc-text">90 子集 II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-9"><span class="toc-number">2.9.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-9"><span class="toc-number">2.9.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-9"><span class="toc-number">2.9.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#491-%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">2.10.</span> <span class="toc-text">491 递增子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-10"><span class="toc-number">2.10.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-10"><span class="toc-number">2.10.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-10"><span class="toc-number">2.10.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46-%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-number">2.11.</span> <span class="toc-text">46 全排列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-11"><span class="toc-number">2.11.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-11"><span class="toc-number">2.11.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-11"><span class="toc-number">2.11.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#47-%E5%85%A8%E6%8E%92%E5%88%97-II"><span class="toc-number">2.12.</span> <span class="toc-text">47 全排列 II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-12"><span class="toc-number">2.12.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-12"><span class="toc-number">2.12.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-12"><span class="toc-number">2.12.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51-N%E7%9A%87%E5%90%8E"><span class="toc-number">2.13.</span> <span class="toc-text">51 N皇后</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-13"><span class="toc-number">2.13.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-13"><span class="toc-number">2.13.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-13"><span class="toc-number">2.13.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://localhost:4000/2024/03/26/leetcode/%E5%9B%9E%E6%BA%AF/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://localhost:4000/2024/03/26/leetcode/%E5%9B%9E%E6%BA%AF/&text=回溯"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://localhost:4000/2024/03/26/leetcode/%E5%9B%9E%E6%BA%AF/&title=回溯"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://localhost:4000/2024/03/26/leetcode/%E5%9B%9E%E6%BA%AF/&is_video=false&description=回溯"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=回溯&body=Check out this article: http://localhost:4000/2024/03/26/leetcode/%E5%9B%9E%E6%BA%AF/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://localhost:4000/2024/03/26/leetcode/%E5%9B%9E%E6%BA%AF/&title=回溯"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://localhost:4000/2024/03/26/leetcode/%E5%9B%9E%E6%BA%AF/&title=回溯"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://localhost:4000/2024/03/26/leetcode/%E5%9B%9E%E6%BA%AF/&title=回溯"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://localhost:4000/2024/03/26/leetcode/%E5%9B%9E%E6%BA%AF/&title=回溯"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://localhost:4000/2024/03/26/leetcode/%E5%9B%9E%E6%BA%AF/&name=回溯&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://localhost:4000/2024/03/26/leetcode/%E5%9B%9E%E6%BA%AF/&t=回溯"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2024
    jonas
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/categories/">Category</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a href="/search">Search</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/jonasrepo.github.io">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
