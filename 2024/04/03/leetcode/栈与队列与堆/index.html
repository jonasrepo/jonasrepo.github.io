<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="栈：先进后出 队列：先进先出 小[大]顶堆，又叫优先队列，最大值用小顶堆，最小值用大顶堆  相关题目32 最长有效括号【题目描述】给定一个只包含 &#39;(&#39; 和 &#39;)&#39; 的字符串，找出最长的包含有效括号的子串的长度。 示例：12345678910输入：s &#x3D; &quot;(()&quot;输出：2解释：最长有效括号子串是 &quot;()&quot;输入：s &#x3D; &amp;q">
<meta property="og:type" content="article">
<meta property="og:title" content="栈与队列与堆">
<meta property="og:url" content="http://localhost:4000/2024/04/03/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%8E%E5%A0%86/index.html">
<meta property="og:site_name" content="Jonas">
<meta property="og:description" content="栈：先进后出 队列：先进先出 小[大]顶堆，又叫优先队列，最大值用小顶堆，最小值用大顶堆  相关题目32 最长有效括号【题目描述】给定一个只包含 &#39;(&#39; 和 &#39;)&#39; 的字符串，找出最长的包含有效括号的子串的长度。 示例：12345678910输入：s &#x3D; &quot;(()&quot;输出：2解释：最长有效括号子串是 &quot;()&quot;输入：s &#x3D; &amp;q">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://code-thinking.cdn.bcebos.com/gifs/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-2.gif">
<meta property="article:published_time" content="2024-04-03T01:29:41.198Z">
<meta property="article:modified_time" content="2024-07-14T09:45:28.407Z">
<meta property="article:author" content="jonas">
<meta property="article:tag" content="leetcode">
<meta property="article:tag" content="栈与队列">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://code-thinking.cdn.bcebos.com/gifs/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-2.gif">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>栈与队列与堆</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<meta name="generator" content="Hexo 7.1.1"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/categories/">Category</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a href="/search">Search</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/jonasrepo.github.io">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2024/04/07/leetcode/%E5%8F%8C%E6%8C%87%E9%92%88/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2024/03/28/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://localhost:4000/2024/04/03/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%8E%E5%A0%86/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://localhost:4000/2024/04/03/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%8E%E5%A0%86/&text=栈与队列与堆"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://localhost:4000/2024/04/03/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%8E%E5%A0%86/&title=栈与队列与堆"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://localhost:4000/2024/04/03/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%8E%E5%A0%86/&is_video=false&description=栈与队列与堆"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=栈与队列与堆&body=Check out this article: http://localhost:4000/2024/04/03/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%8E%E5%A0%86/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://localhost:4000/2024/04/03/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%8E%E5%A0%86/&title=栈与队列与堆"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://localhost:4000/2024/04/03/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%8E%E5%A0%86/&title=栈与队列与堆"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://localhost:4000/2024/04/03/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%8E%E5%A0%86/&title=栈与队列与堆"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://localhost:4000/2024/04/03/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%8E%E5%A0%86/&title=栈与队列与堆"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://localhost:4000/2024/04/03/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%8E%E5%A0%86/&name=栈与队列与堆&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://localhost:4000/2024/04/03/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%8E%E5%A0%86/&t=栈与队列与堆"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE"><span class="toc-number">1.</span> <span class="toc-text">相关题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7"><span class="toc-number">2.</span> <span class="toc-text">32 最长有效括号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91"><span class="toc-number">2.1.</span> <span class="toc-text">【题目描述】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-number">2.1.1.</span> <span class="toc-text">示例：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91"><span class="toc-number">2.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91"><span class="toc-number">2.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#155-%E6%9C%80%E5%B0%8F%E6%A0%88"><span class="toc-number">3.</span> <span class="toc-text">155 最小栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-1"><span class="toc-number">3.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-1"><span class="toc-number">3.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-1"><span class="toc-number">3.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">4.</span> <span class="toc-text">23 合并K个升序链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-2"><span class="toc-number">4.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-2"><span class="toc-number">4.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-2"><span class="toc-number">4.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-number">5.</span> <span class="toc-text">232 用栈实现队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-3"><span class="toc-number">5.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-3"><span class="toc-number">5.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-3"><span class="toc-number">5.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#225-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="toc-number">6.</span> <span class="toc-text">225 用队列实现栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-4"><span class="toc-number">6.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-4"><span class="toc-number">6.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-4"><span class="toc-number">6.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="toc-number">7.</span> <span class="toc-text">20 有效的括号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-5"><span class="toc-number">7.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-5"><span class="toc-number">7.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-5"><span class="toc-number">7.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1047-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="toc-number">8.</span> <span class="toc-text">1047 删除字符串中的所有相邻重复项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-6"><span class="toc-number">8.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-6"><span class="toc-number">8.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-6"><span class="toc-number">8.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-number">9.</span> <span class="toc-text">150 逆波兰表达式求值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-7"><span class="toc-number">9.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-7"><span class="toc-number">9.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-7"><span class="toc-number">9.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">10.</span> <span class="toc-text">239 滑动窗口最大值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-8"><span class="toc-number">10.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-8"><span class="toc-number">10.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-8"><span class="toc-number">10.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#347-%E5%89%8D-K-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0"><span class="toc-number">11.</span> <span class="toc-text">347 前 K 个高频元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-9"><span class="toc-number">11.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-9"><span class="toc-number">11.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-9"><span class="toc-number">11.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#71-%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84"><span class="toc-number">12.</span> <span class="toc-text">71 简化路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-10"><span class="toc-number">12.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-10"><span class="toc-number">12.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-10"><span class="toc-number">12.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="toc-number">13.</span> <span class="toc-text">215 数组中的第K个最大元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-11"><span class="toc-number">13.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-11"><span class="toc-number">13.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-11"><span class="toc-number">13.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        栈与队列与堆
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">jonas</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-04-03T01:29:41.198Z" class="dt-published" itemprop="datePublished">2024-04-03</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/leetcode/">leetcode</a>
    </div>


      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/leetcode/" rel="tag">leetcode</a>, <a class="p-category" href="/tags/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/" rel="tag">栈与队列</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <ol>
<li>栈：先进后出</li>
<li>队列：先进先出</li>
<li>小[大]顶堆，又叫优先队列，最大值用小顶堆，最小值用大顶堆</li>
</ol>
<h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><h2 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32 最长有效括号"></a>32 最长有效括号</h2><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长的包含有效括号的子串的长度。</p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;(()&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：最长有效括号子串是 &quot;()&quot;</span><br><span class="line"></span><br><span class="line">输入：s = &quot;)()())&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：最长有效括号子串是 &quot;()()&quot;</span><br><span class="line"></span><br><span class="line">输入：s = &quot;&quot;</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<h3 id="【解题思路】"><a href="#【解题思路】" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><ol>
<li><strong>使用栈</strong>：<ul>
<li>使用一个栈来存储索引，以帮助我们匹配括号。</li>
<li>栈中维护一个“基础”索引，初始值为 -1。这个基础索引可以帮助计算从第一个有效括号开始的长度。</li>
<li>遍历字符串：<ul>
<li>如果遇到 <code>&#39;(&#39;</code>，将其索引压入栈中。</li>
<li>如果遇到 <code>&#39;)&#39;</code>，弹出栈顶元素：<ul>
<li>如果栈为空，说明当前的 <code>&#39;)&#39;</code> 无法匹配，将其索引压入栈中作为新的基础索引。</li>
<li>如果栈不为空，计算当前有效括号的长度 <code>i - stack[top]</code>，更新最大长度。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="【实现代码】"><a href="#【实现代码】" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestValidParentheses</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 初始化栈，基础索引为 -1</span></span><br><span class="line">	stack := []<span class="type">int</span>&#123;<span class="number">-1</span>&#125;</span><br><span class="line">	maxLength := <span class="number">0</span></span><br><span class="line">	<span class="comment">//// 栈底元素为当前已经遍历过的元素中「最后一个没有被匹配的右括号的下标」</span></span><br><span class="line">	<span class="keyword">for</span> i, char := <span class="keyword">range</span> s &#123;</span><br><span class="line">		<span class="keyword">if</span> char == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">			<span class="comment">// 将索引压入栈中</span></span><br><span class="line">			stack = <span class="built_in">append</span>(stack, i)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 弹出栈顶元素</span></span><br><span class="line">			stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// 栈为空，当前索引作为新的基础索引</span></span><br><span class="line">				stack = <span class="built_in">append</span>(stack, i)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 计算当前有效括号的长度</span></span><br><span class="line">				maxLength = max(maxLength, i-stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>])</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> maxLength</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：返回两个整数中的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155 最小栈"></a>155 最小栈</h2><h3 id="【题目描述】-1"><a href="#【题目描述】-1" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>设计一个支持 <code>push</code>，<code>pop</code>，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p>
<ul>
<li><code>push(x)</code> —— 将元素 x 推入栈中。</li>
<li><code>pop()</code> —— 删除栈顶的元素。</li>
<li><code>top()</code> —— 获取栈顶元素。</li>
<li><code>getMin()</code> —— 检索栈中的最小元素。</li>
</ul>
<p>你必须在常数时间内完成 <code>getMin</code> 操作。</p>
<h3 id="【解题思路】-1"><a href="#【解题思路】-1" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>为了在常数时间内检索到最小元素，我们可以使用一个辅助栈来同步保存每个元素入栈时的当前最小值。每次元素入栈时，我们比较新元素和当前最小值，将较小值推入辅助栈。这样，主栈的每个元素都对应一个在辅助栈中的当前最小值。</p>
<ul>
<li><strong>Push 操作</strong>：将元素推入主栈，并将当前最小值推入辅助栈。</li>
<li><strong>Pop 操作</strong>：同时从主栈和辅助栈弹出顶部元素。</li>
<li><strong>Top 操作</strong>：返回主栈顶部元素。</li>
<li><strong>GetMin 操作</strong>：返回辅助栈顶部元素，因为辅助栈顶部元素始终是当前栈中的最小值。</li>
</ul>
<h3 id="【实现代码】-1"><a href="#【实现代码】-1" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MinStack <span class="keyword">struct</span> &#123;</span><br><span class="line">    stack    []<span class="type">int</span> <span class="comment">// 主栈</span></span><br><span class="line">    minStack []<span class="type">int</span> <span class="comment">// 辅助栈，用于存储每个状态的最小值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** initialize your data structure here. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> MinStack &#123;</span><br><span class="line">    <span class="keyword">return</span> MinStack&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span></span> Push(x <span class="type">int</span>) &#123;</span><br><span class="line">    this.stack = <span class="built_in">append</span>(this.stack, x)</span><br><span class="line">    min := x</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.minStack) &gt; <span class="number">0</span> &amp;&amp; this.GetMin() &lt; x &#123;</span><br><span class="line">        min = this.GetMin()</span><br><span class="line">    &#125;</span><br><span class="line">    this.minStack = <span class="built_in">append</span>(this.minStack, min)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span></span> Pop() &#123;</span><br><span class="line">    this.stack = this.stack[:<span class="built_in">len</span>(this.stack)<span class="number">-1</span>]</span><br><span class="line">    this.minStack = this.minStack[:<span class="built_in">len</span>(this.minStack)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span></span> Top() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.stack[<span class="built_in">len</span>(this.stack)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span></span> GetMin() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.minStack[<span class="built_in">len</span>(this.minStack)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23 合并K个升序链表"></a>23 合并K个升序链表</h2><h3 id="【题目描述】-2"><a href="#【题目描述】-2" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你一个链表数组，每个链表都已经按升序排列。<br>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<h3 id="【解题思路】-2"><a href="#【解题思路】-2" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>合并K个有序链表的问题可以通过构造一个最小堆来解决。最小堆能够帮助我们维护当前所有链表头部节点中的最小节点。具体步骤如下：</p>
<ol>
<li>初始化一个最小堆，并定义堆的基本操作，如插入（push）和删除（pop）。</li>
<li>遍历所有链表，将每个链表的头节点插入最小堆中。</li>
<li>创建一个哑节点（dummy head）作为合并后链表的起始节点，这样可以简化代码逻辑。</li>
<li>当最小堆不为空时，执行以下步骤：<ul>
<li>从堆中弹出最小节点（即堆顶元素），将其添加到合并链表的末尾。</li>
<li>如果最小节点有下一个节点，将这个下一个节点插入最小堆中。</li>
</ul>
</li>
<li>当堆为空时，所有链表都已经合并完毕。</li>
</ol>
<p>为了不使用Go语言内置的<code>container/heap</code>包，我们将手动实现最小堆的操作。</p>
<h3 id="【实现代码】-2"><a href="#【实现代码】-2" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeKLists</span><span class="params">(lists []*ListNode)</span></span> *ListNode &#123;</span><br><span class="line">	<span class="comment">// 构建堆</span></span><br><span class="line">	heap := []*ListNode&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(lists); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> lists[i] != <span class="literal">nil</span> &#123;</span><br><span class="line">			heap = <span class="built_in">append</span>(heap, lists[i])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(heap) &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	n := <span class="built_in">len</span>(heap)</span><br><span class="line">	i := n/<span class="number">2</span> - <span class="number">1</span></span><br><span class="line">	<span class="comment">// shifdown</span></span><br><span class="line">	<span class="keyword">for</span> j := i; j &gt;= <span class="number">0</span>; j-- &#123;</span><br><span class="line">		shiftdown(heap, j, n)</span><br><span class="line">	&#125;</span><br><span class="line">	dummy := &amp;ListNode&#123;<span class="number">0</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">	cur := dummy</span><br><span class="line">	j := n - <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> j &gt;= <span class="number">0</span> &#123;</span><br><span class="line">		cur.Next = heap[<span class="number">0</span>]</span><br><span class="line">		cur = cur.Next</span><br><span class="line">		<span class="comment">// if the lists has next element add to the top</span></span><br><span class="line">		<span class="keyword">if</span> heap[<span class="number">0</span>].Next != <span class="literal">nil</span> &#123;</span><br><span class="line">			heap[<span class="number">0</span>] = heap[<span class="number">0</span>].Next</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// swap the end with top</span></span><br><span class="line">			heap[<span class="number">0</span>], heap[j] = heap[j], heap[<span class="number">0</span>]</span><br><span class="line">			j--</span><br><span class="line">		&#125;</span><br><span class="line">		shiftdown(heap, <span class="number">0</span>, j+<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小顶堆</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shiftdown</span><span class="params">(heap []*ListNode, i, n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i &lt; n &#123;</span><br><span class="line">		l, r := <span class="number">2</span>*i+<span class="number">1</span>, <span class="number">2</span>*i+<span class="number">2</span></span><br><span class="line">		min := i</span><br><span class="line">		<span class="keyword">if</span> l &lt; n &amp;&amp; heap[min].Val &gt; heap[l].Val &#123;</span><br><span class="line">			min = l</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> r &lt; n &amp;&amp; heap[min].Val &gt; heap[r].Val &#123;</span><br><span class="line">			min = r</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> min != i &#123;</span><br><span class="line">			heap[i], heap[min] = heap[min], heap[i]</span><br><span class="line">			i = min</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232 用栈实现队列"></a>232 用栈实现队列</h2><h3 id="【题目描述】-3"><a href="#【题目描述】-3" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>使用栈实现队列的下列操作：</p>
<ul>
<li>push(x) – 将一个元素放入队列的尾部。</li>
<li>pop() – 从队列首部移除元素。</li>
<li>peek() – 返回队列首部的元素。</li>
<li>empty() – 返回队列是否为空。</li>
</ul>
<p>注意:</p>
<ul>
<li>你只能使用标准的栈操作 – 也就是只有 push to top, peek&#x2F;pop from top, size, 和 is empty 操作是合法的。</li>
<li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li>
<li>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</li>
</ul>
<h3 id="【解题思路】-3"><a href="#【解题思路】-3" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题的关键在于理解栈和队列的基本差别：栈是后进先出（LIFO），而队列是先进先出（FIFO）。要用栈实现队列，我们需要两个栈：一个用来反转元素顺序（<code>inputStack</code>），另一个用来执行队列操作（<code>outputStack</code>）。</p>
<p>实现步骤如下：</p>
<ol>
<li><strong>Push 操作</strong>：元素总是被推入 <code>inputStack</code>。</li>
<li><strong>Pop&#x2F;Peek 操作</strong>：当需要执行 pop 或 peek 操作时，如果 <code>outputStack</code> 为空，我们就将 <code>inputStack</code> 中的所有元素弹出并推入 <code>outputStack</code>，这样 <code>outputStack</code> 的顶部元素就是队列的首部元素。如果 <code>outputStack</code> 不为空，我们直接从 <code>outputStack</code> 中弹出或返回顶部元素。</li>
<li><strong>Empty 操作</strong>：队列为空的条件是 <code>inputStack</code> 和 <code>outputStack</code> 都为空。</li>
</ol>
<p>这种方法的巧妙之处在于，它通过两次栈的后进先出操作，实现了元素的顺序反转，从而使得最早进入 <code>inputStack</code> 的元素可以最先从 <code>outputStack</code> 弹出，达到队列先进先出的效果。</p>
<h3 id="【实现代码】-3"><a href="#【实现代码】-3" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">    inputStack  []<span class="type">int</span></span><br><span class="line">    outputStack []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> MyQueue &#123;</span><br><span class="line">    <span class="keyword">return</span> MyQueue&#123;</span><br><span class="line">        inputStack:  []<span class="type">int</span>&#123;&#125;,</span><br><span class="line">        outputStack: []<span class="type">int</span>&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span></span> Push(x <span class="type">int</span>)  &#123;</span><br><span class="line">    this.inputStack = <span class="built_in">append</span>(this.inputStack, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span></span> Pop() <span class="type">int</span> &#123;</span><br><span class="line">    this.moveInputToOutput()</span><br><span class="line">    popVal := this.outputStack[<span class="built_in">len</span>(this.outputStack)<span class="number">-1</span>]</span><br><span class="line">    this.outputStack = this.outputStack[:<span class="built_in">len</span>(this.outputStack)<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> popVal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span></span> Peek() <span class="type">int</span> &#123;</span><br><span class="line">    this.moveInputToOutput()</span><br><span class="line">    <span class="keyword">return</span> this.outputStack[<span class="built_in">len</span>(this.outputStack)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span></span> Empty() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(this.inputStack) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(this.outputStack) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 inputStack 中的所有元素移动到 outputStack，以便执行 FIFO 操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span></span> moveInputToOutput() &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.outputStack) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(this.inputStack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            this.outputStack = <span class="built_in">append</span>(this.outputStack, this.inputStack[<span class="built_in">len</span>(this.inputStack)<span class="number">-1</span>])</span><br><span class="line">            this.inputStack = this.inputStack[:<span class="built_in">len</span>(this.inputStack)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225 用队列实现栈"></a>225 用队列实现栈</h2><h3 id="【题目描述】-4"><a href="#【题目描述】-4" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>使用队列实现栈的下列操作：</p>
<ul>
<li>push(x) – 元素 x 入栈</li>
<li>pop() – 移除栈顶元素</li>
<li>top() – 获取栈顶元素</li>
<li>empty() – 返回栈是否为空</li>
</ul>
<p>注意:</p>
<ul>
<li>你只能使用队列的基本操作– 也就是 push to back, peek&#x2F;pop from front, size, 和 is empty 这些操作是合法的。</li>
<li>你所使用的语言可能不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li>
<li>你可以假设所有操作都是有效的 （例如, 对一个空的栈不会调用 pop 或者 top 操作）。</li>
</ul>
<h3 id="【解题思路】-4"><a href="#【解题思路】-4" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>要用队列实现一个后进先出（LIFO）的栈，我们可以使用两个队列：一个主队列（<code>mainQueue</code>）用于存储栈内的元素，另一个辅助队列（<code>helperQueue</code>）用于操作时的元素转移。</p>
<ul>
<li><strong>Push 操作</strong>：直接将元素加入到 <code>mainQueue</code>，因为队列是先进先出（FIFO），我们不需要做其他操作。</li>
<li><strong>Pop 操作</strong>：需要移除栈顶元素，即 <code>mainQueue</code> 的最后一个元素。为此，我们将 <code>mainQueue</code> 中除最后一个元素外的所有元素移动到 <code>helperQueue</code>，然后移除 <code>mainQueue</code> 中的最后一个元素（此时 <code>mainQueue</code> 为空），最后交换 <code>mainQueue</code> 和 <code>helperQueue</code>。这样，下次进行 pop 或 top 操作时，新的栈顶元素就在 <code>mainQueue</code> 的前端了。</li>
<li><strong>Top 操作</strong>：类似于 pop 操作，但是我们需要返回 <code>mainQueue</code> 最后一个元素的值，而不是移除它。</li>
<li><strong>Empty 操作</strong>：检查 <code>mainQueue</code> 是否为空即可。</li>
</ul>
<p>这个方法的关键在于使用辅助队列在每次 pop 和 top 操作时重新排序，确保栈顶元素总是可以通过 <code>mainQueue</code> 的 front 访问。</p>
<h3 id="【实现代码】-4"><a href="#【实现代码】-4" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyStack <span class="keyword">struct</span> &#123;</span><br><span class="line">	queue1 []<span class="type">int</span></span><br><span class="line">	queue2 []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> MyStack &#123;</span><br><span class="line">	<span class="keyword">return</span> MyStack&#123;</span><br><span class="line">		queue1: []<span class="type">int</span>&#123;&#125;,</span><br><span class="line">		queue2: []<span class="type">int</span>&#123;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyStack)</span></span> Push(x <span class="type">int</span>) &#123;</span><br><span class="line">	this.queue1 = <span class="built_in">append</span>(this.queue1, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyStack)</span></span> Pop() <span class="type">int</span> &#123;</span><br><span class="line">	this.move()</span><br><span class="line">	v := this.queue1[<span class="number">0</span>]</span><br><span class="line">	this.queue1 = []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	this.queue1, this.queue2 = this.queue2, this.queue1</span><br><span class="line">	<span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyStack)</span></span> Top() <span class="type">int</span> &#123;</span><br><span class="line">	this.move()</span><br><span class="line">	<span class="keyword">return</span> this.queue1[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyStack)</span></span> Empty() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(this.queue1) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(this.queue2) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyStack)</span></span> move() &#123;</span><br><span class="line">	<span class="comment">//queue1中保留一个元素，用于top，peak</span></span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(this.queue1) &gt; <span class="number">1</span> &#123;</span><br><span class="line">		this.queue2 = <span class="built_in">append</span>(this.queue2, this.queue1[<span class="number">0</span>])</span><br><span class="line">		this.queue1 = this.queue1[<span class="number">1</span>:]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20 有效的括号"></a>20 有效的括号</h2><h3 id="【题目描述】-5"><a href="#【题目描述】-5" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个只包括 <code>&#39;(&#39;，&#39;)&#39;，&#39;&#123;&#39;，&#39;&#125;&#39;，&#39;[&#39;，&#39;]&#39;</code> 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>注意空字符串可被认为是有效字符串。</li>
</ol>
<h3 id="【解题思路】-5"><a href="#【解题思路】-5" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这道题的关键在于如何检测括号的匹配顺序。一种高效的方法是使用栈的数据结构。栈具有后进先出（LIFO）的特性，这对于跟踪括号是否有效是非常有用的。</p>
<p>具体步骤如下：</p>
<ol>
<li>遍历给定的字符串中的每一个字符。</li>
<li>当遇到一个左括号时，将其推入栈中。</li>
<li>当遇到一个右括号时，检查栈顶元素是否是对应的左括号：<ul>
<li>如果是，从栈中弹出栈顶元素，继续检查下一个字符。</li>
<li>如果不是，或者栈为空（无法匹配当前右括号），那么字符串不是有效的括号序列。</li>
</ul>
</li>
<li>最后，如果栈为空，则所有括号都有效匹配；如果栈中仍有元素，则表示有未匹配的左括号，因此字符串不是有效的括号序列。</li>
</ol>
<h3 id="【实现代码】-5"><a href="#【实现代码】-5" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 使用map存储括号对应关系，方便查找</span></span><br><span class="line">    bracketMap := <span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">rune</span>&#123;<span class="string">&#x27;)&#x27;</span>: <span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;&#125;&#x27;</span>: <span class="string">&#x27;&#123;&#x27;</span>, <span class="string">&#x27;]&#x27;</span>: <span class="string">&#x27;[&#x27;</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> stack []<span class="type">rune</span> <span class="comment">// 使用切片作为栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, char := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="comment">// 如果是右括号</span></span><br><span class="line">        <span class="keyword">if</span> _, exists := bracketMap[char]; exists &#123;</span><br><span class="line">            <span class="comment">// 如果栈为空或者栈顶元素与当前右括号不匹配</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span> || stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] != bracketMap[char] &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 匹配成功，弹出栈顶元素</span></span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果是左括号，推入栈中</span></span><br><span class="line">            stack = <span class="built_in">append</span>(stack, char)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果栈为空，说明所有括号都成功匹配</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(stack) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047 删除字符串中的所有相邻重复项"></a>1047 删除字符串中的所有相邻重复项</h2><h3 id="【题目描述】-6"><a href="#【题目描述】-6" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给出由小写字母组成的字符串 <code>S</code>，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p>
<p>在 <code>S</code> 上反复执行重复项删除操作，直到无法继续删除。</p>
<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<h3 id="【解题思路】-6"><a href="#【解题思路】-6" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题可以通过栈的数据结构来高效解决。基本思路是遍历字符串中的每个字符，对每个字符执行以下操作：</p>
<ol>
<li>如果栈不为空，并且当前字符与栈顶字符相同，则这两个字符都需要被删除。这可以通过弹出栈顶字符来实现。</li>
<li>如果栈为空，或者当前字符与栈顶字符不同，则将当前字符推入栈中。</li>
</ol>
<p>遍历完成后，栈中剩下的字符就是删除所有相邻重复项后的结果。我们只需要将栈中的字符拼接起来即可得到最终答案。</p>
<h3 id="【实现代码】-6"><a href="#【实现代码】-6" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicates</span><span class="params">(S <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stack []<span class="type">rune</span> <span class="comment">// 使用切片模拟栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, char := <span class="keyword">range</span> S &#123;</span><br><span class="line">        <span class="comment">// 如果栈不为空且当前字符与栈顶字符相同，则弹出栈顶字符（删除两个相邻重复字符）</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &amp;&amp; stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] == char &#123;</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，将当前字符推入栈中</span></span><br><span class="line">            stack = <span class="built_in">append</span>(stack, char)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将栈中剩余的字符拼接起来，得到最终结果</span></span><br><span class="line">    result := <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> _, char := <span class="keyword">range</span> stack &#123;</span><br><span class="line">        result += <span class="type">string</span>(char)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150 逆波兰表达式求值"></a>150 逆波兰表达式求值</h2><h3 id="【题目描述】-7"><a href="#【题目描述】-7" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>根据逆波兰表示法，求表达式的值。</p>
<p>有效的运算符包括 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p>
<p>说明：</p>
<ul>
<li>整数除法只保留整数部分。</li>
<li>给定逆波兰表达式总是有效的。换句话说，表达式总会得出一个结果，并且不会有任何除以零的操作。</li>
</ul>
<h3 id="【解题思路】-7"><a href="#【解题思路】-7" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>逆波兰表达式（也称后缀表达式）的求值可以通过使用栈这一数据结构来实现。基本思路是：</p>
<ol>
<li>创建一个栈来存储整数。</li>
<li>遍历每个元素：<ul>
<li>如果遇到一个数，就将它推入栈中。</li>
<li>如果遇到一个运算符，则从栈中弹出两个数，先弹出的数作为右操作数，后弹出的数作为左操作数，进行运算后，将结果再推回栈中。</li>
</ul>
</li>
<li>遍历结束后，栈顶元素就是表达式的结果。</li>
</ol>
<h3 id="【实现代码】-7"><a href="#【实现代码】-7" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;strconv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evalRPN</span><span class="params">(tokens []<span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stack []<span class="type">int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, token := <span class="keyword">range</span> tokens &#123;</span><br><span class="line">        <span class="keyword">switch</span> token &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>, <span class="string">&quot;-&quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="string">&quot;/&quot;</span>:</span><br><span class="line">            <span class="comment">// 弹出栈顶的两个元素</span></span><br><span class="line">            right, left := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>], stack[<span class="built_in">len</span>(stack)<span class="number">-2</span>]</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-2</span>] <span class="comment">// 更新栈</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 进行运算并将结果推回栈中</span></span><br><span class="line">            result := <span class="number">0</span></span><br><span class="line">            <span class="keyword">switch</span> token &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                result = left + right</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                result = left - right</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                result = left * right</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                result = left / right</span><br><span class="line">            &#125;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, result)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// 如果是数，将其转换为整数并推入栈中</span></span><br><span class="line">            num, _ := strconv.Atoi(token)</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, num)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 栈顶元素即为最终结果</span></span><br><span class="line">    <span class="keyword">return</span> stack[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239 滑动窗口最大值"></a>239 滑动窗口最大值</h2><h3 id="【题目描述】-8"><a href="#【题目描述】-8" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左端移动到数组的最右端。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。返回滑动窗口中的最大值。</p>
<h3 id="【解题思路】-8"><a href="#【解题思路】-8" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>解决这个问题的关键是如何在每次窗口移动时，有效地找到当前窗口的最大值。一个直观的方法是每次窗口移动时，遍历窗口中的所有元素来找最大值，但这种方法的时间复杂度较高。</p>
<p>一个更高效的方法是使用双端队列（Deque）来维护窗口内的最大值，使得时间复杂度降低。双端队列能够从两端以常数时间插入或删除元素。</p>
<p>具体步骤如下：</p>
<ol>
<li>使用一个双端队列存储元素的索引，队列中的第一个元素是当前窗口的最大值的索引。</li>
<li>遍历数组 <code>nums</code>，对于每个元素，做以下操作：<ul>
<li>首先，移除所有小于当前元素 <code>nums[i]</code> 的元素的索引，因为它们不可能是窗口的最大值。</li>
<li>然后，如果队列的头部元素（当前最大值的索引）已经不在窗口内（索引小于 <code>i-k+1</code>），就将其从队列中移除。</li>
<li>将当前元素的索引添加到队列的末尾。</li>
<li>如果已经遍历到第 <code>k</code> 个元素（<code>i ≥ k-1</code>），将当前窗口的最大值（队列头部元素对应的值）添加到结果数组中。</li>
</ul>
</li>
<li>返回结果数组。<br><img src="https://code-thinking.cdn.bcebos.com/gifs/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-2.gif"></li>
</ol>
<h3 id="【实现代码】-8"><a href="#【实现代码】-8" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先，我们需要定义一个双端队列（deque）来存储窗口内的元素下标。队列中的元素按照从大到小的顺序排列，保证队头元素是当前窗口中的最大值。</span></span><br><span class="line"><span class="comment">// 然后，我们遍历整个数组。在遍历过程中，我们需要维护以下规则：</span></span><br><span class="line"><span class="comment">// 如果队列不为空且当前元素大于等于队尾元素，我们将队尾元素出队，直到队列为空或者当前元素小于队尾元素。</span></span><br><span class="line"><span class="comment">// 将当前元素的下标入队。</span></span><br><span class="line"><span class="comment">// 在遍历过程中，我们需要判断当前窗口是否已经形成。如果窗口的左边界大于等于k-1，我们可以将队头元素加入结果数组中。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSlidingWindow</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	res := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	deque := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	<span class="comment">//找出前卡个元素</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> <span class="built_in">len</span>(deque) &gt; <span class="number">0</span> &amp;&amp; deque[<span class="built_in">len</span>(deque)<span class="number">-1</span>] &lt; nums[i] &#123;</span><br><span class="line">			deque = deque[:<span class="built_in">len</span>(deque)<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">		deque = <span class="built_in">append</span>(deque, nums[i])</span><br><span class="line">	&#125;</span><br><span class="line">	res = <span class="built_in">append</span>(res, deque[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> j := k; j &lt; <span class="built_in">len</span>(nums); j++ &#123;</span><br><span class="line">		<span class="comment">//如果队列的头部元素（当前最大值的索引）已经不在窗口内（索引小于 `i-k+1`），就将其从队列中移除。</span></span><br><span class="line">		<span class="keyword">if</span> nums[j-k] == deque[<span class="number">0</span>] &#123;</span><br><span class="line">			deque = deque[<span class="number">1</span>:]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> <span class="built_in">len</span>(deque) &gt; <span class="number">0</span> &amp;&amp; deque[<span class="built_in">len</span>(deque)<span class="number">-1</span>] &lt; nums[j] &#123;</span><br><span class="line">			deque = deque[:<span class="built_in">len</span>(deque)<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">		deque = <span class="built_in">append</span>(deque, nums[j])</span><br><span class="line">		res = <span class="built_in">append</span>(res, deque[<span class="number">0</span>])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347 前 K 个高频元素"></a>347 前 K 个高频元素</h2><h3 id="【题目描述】-9"><a href="#【题目描述】-9" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。</p>
<h3 id="【解题思路】-9"><a href="#【解题思路】-9" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题可以使用哈希表和优先队列（最小堆）来解决。</p>
<p>首先，我们可以使用哈希表来统计每个元素在数组中出现的频率。哈希表的键为元素，值为该元素出现的次数。</p>
<p>然后，我们可以使用优先队列（最小堆）来存储前 k 个高频元素。我们遍历哈希表中的所有键值对，对于每个键值对，如果优先队列的大小小于 k，我们就将该键值对直接加入优先队列。如果优先队列的大小等于 k，我们比较当前键值对的值和优先队列顶部键值对的值，如果当前键值对的值大于优先队列顶部的值，我们就将顶部的键值对移除，并将当前键值对加入优先队列。</p>
<p>最后，优先队列中剩下的就是前 k 个高频元素。我们将优先队列中的元素转换为数组并返回即可。</p>
<h3 id="【实现代码】-9"><a href="#【实现代码】-9" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">topKFrequent</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">type</span> Pair <span class="keyword">struct</span> &#123;</span><br><span class="line">		Val       <span class="type">int</span></span><br><span class="line">		Frequency <span class="type">int</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//统计</span></span><br><span class="line">	mp := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		mp[num]++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//保存在pairlist中</span></span><br><span class="line">	pairList := []Pair&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> mp &#123;</span><br><span class="line">		pairList = <span class="built_in">append</span>(pairList, Pair&#123;k, v&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 堆排序</span></span><br><span class="line">	heap := <span class="built_in">make</span>([]Pair, k)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">		heap[i] = pairList[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> shifdown <span class="function"><span class="keyword">func</span><span class="params">(heap []Pair, i, n <span class="type">int</span>)</span></span></span><br><span class="line">	shifdown = <span class="function"><span class="keyword">func</span><span class="params">(heap []Pair, i, n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		l, r := <span class="number">2</span>*i+<span class="number">1</span>, <span class="number">2</span>*i+<span class="number">2</span></span><br><span class="line">		min := i</span><br><span class="line">		<span class="comment">//heap[min].Frequency 中的是heap[min].Frequency， 不是heap[i].Frequency</span></span><br><span class="line">		<span class="comment">//因为要找左右子节点中最小的</span></span><br><span class="line">		<span class="keyword">if</span> l &lt; n &amp;&amp; heap[l].Frequency &lt; heap[min].Frequency &#123;</span><br><span class="line">			min = l</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> r &lt; n &amp;&amp; heap[r].Frequency &lt; heap[min].Frequency &#123;</span><br><span class="line">			min = r</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> min != i &#123;</span><br><span class="line">			heap[i], heap[min] = heap[min], heap[i]</span><br><span class="line">			shifdown(heap, min, n)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := k/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		shifdown(heap, i, k)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> j := k; j &lt; <span class="built_in">len</span>(pairList); j++ &#123;</span><br><span class="line">		<span class="keyword">if</span> pairList[j].Frequency &gt; heap[<span class="number">0</span>].Frequency &#123;</span><br><span class="line">			heap[<span class="number">0</span>] = pairList[j]</span><br><span class="line">			shifdown(heap, <span class="number">0</span>, k)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	res := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">		res = <span class="built_in">append</span>(res, heap[i].Val)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="71-简化路径"><a href="#71-简化路径" class="headerlink" title="71 简化路径"></a>71 简化路径</h2><h3 id="【题目描述】-10"><a href="#【题目描述】-10" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。</p>
<p>在 Unix 风格的文件系统中，一个点（<code>.</code>）表示当前目录本身；此外，两个点 （<code>..</code>） 表示将目录切换到上一级（指向父目录）；两者都可以是复合路径的一部分。任意多个连续的斜杠（即，<code>&#39;//&#39;</code>）都被视为单个斜杠 <code>&#39;/&#39;</code>。对于此问题，任何其他格式的点（例如，<code>&#39;...&#39;</code>）都被视为文件&#x2F;目录名称。</p>
<p>请注意，返回的规范路径必须始终以斜杠 <code>&#39;/&#39;</code> 开头，并且两个目录名之间必须只有一个斜杠 <code>&#39;/&#39;</code>。最后一个目录名（如果存在）不能以 <code>&#39;/&#39;</code> 结束。此外，规范路径必须是表示绝对路径的最短字符串。</p>
<h3 id="【解题思路】-10"><a href="#【解题思路】-10" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><ol>
<li><strong>分割路径</strong>: 首先，我们需要根据斜杠 <code>&#39;/&#39;</code> 分割给定的路径，从而得到构成路径的各个部分。</li>
<li><strong>使用栈处理路径</strong>: 接着，我们可以使用一个栈来处理路径。遍历分割后的路径部分，对于每个部分：<ul>
<li>如果是 <code>&#39;..&#39;</code>，则表示需要返回上级目录，此时如果栈不为空，我们就弹出栈顶元素。</li>
<li>如果是 <code>&#39;.&#39;</code> 或者是空字符串（即连续的斜杠情况），我们不做任何操作。</li>
<li>如果是其他字符串，则表示是目录名，我们将其压入栈中。</li>
</ul>
</li>
<li><strong>构建简化后的路径</strong>: 最后，我们将栈中的元素连接起来，每个元素之间用斜杠 <code>&#39;/&#39;</code> 分隔，并在最前面加上 <code>&#39;/&#39;</code>，构成简化后的路径。</li>
</ol>
<h3 id="【实现代码】-10"><a href="#【实现代码】-10" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">simplifyPath</span><span class="params">(path <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="comment">// 分割路径</span></span><br><span class="line">	parts := strings.Split(path, <span class="string">&quot;/&quot;</span>)</span><br><span class="line">	<span class="keyword">var</span> stack []<span class="type">string</span> <span class="comment">// 使用切片作为栈</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, part := <span class="keyword">range</span> parts &#123;</span><br><span class="line">		<span class="keyword">switch</span> part &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;..&quot;</span>:</span><br><span class="line">			<span class="comment">// 弹出栈顶元素（返回上级目录）</span></span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">				stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;.&quot;</span>, <span class="string">&quot;&quot;</span>:</span><br><span class="line">			<span class="comment">// 不做任何操作</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="comment">// 将目录名压入栈</span></span><br><span class="line">			stack = <span class="built_in">append</span>(stack, part)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 构建简化后的路径</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;/&quot;</span> + strings.Join(stack, <span class="string">&quot;/&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215 数组中的第K个最大元素"></a>215 数组中的第K个最大元素</h2><h3 id="【题目描述】-11"><a href="#【题目描述】-11" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>在未排序的数组中找到第 k 个最大的元素。注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
<h3 id="【解题思路】-11"><a href="#【解题思路】-11" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题可以通过多种方式解决，但最直观的方法可能是使用排序。首先，将数组排序，然后直接访问第 k 个最大元素。在 Go 语言中，我们可以使用内置的排序方法来完成这一任务。然而，这种方法的时间复杂度是 O(NlogN)，其中 N 是数组的长度。</p>
<p>更高效的方法是使用堆排序或快速选择算法。这里，我将采用快速选择算法，它是快速排序算法的一个变体，可以在平均情况下以 O(N) 的时间复杂度找到第 k 个最大元素。快速选择算法的基本思想是随机选择一个元素作为枢轴，然后将数组分成两部分：一部分包含所有大于枢轴的元素，另一部分包含所有小于或等于枢轴的元素。这样，枢轴的最终位置就是它在排序数组中的确切位置。因此，我们可以比较枢轴的位置和 k 的大小，以决定是继续在左侧数组中查找，还是在右侧数组中查找。</p>
<h3 id="【实现代码】-11"><a href="#【实现代码】-11" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//堆思路</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthLargest</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="comment">// 使用堆排序实现</span></span><br><span class="line">	heap := <span class="built_in">make</span>([]<span class="type">int</span>, k)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">		heap[i] = nums[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 非叶子节点 shiftdown</span></span><br><span class="line">	i := n/<span class="number">2</span> - <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> ; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		shiftdown(heap, i)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(heap)</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="keyword">for</span> i := k; i &lt; n; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> nums[i] &gt; heap[<span class="number">0</span>] &#123;</span><br><span class="line">			heap[<span class="number">0</span>] = nums[i]</span><br><span class="line">			shiftdown(heap, <span class="number">0</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> heap[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shiftdown</span><span class="params">(heap []<span class="type">int</span>, i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(heap)</span><br><span class="line">	<span class="keyword">for</span> i &lt; n &#123;</span><br><span class="line">		l, r := <span class="number">2</span>*i+<span class="number">1</span>, <span class="number">2</span>*i+<span class="number">2</span></span><br><span class="line">		min := i</span><br><span class="line">		<span class="keyword">if</span> l &lt; n &amp;&amp; heap[min] &gt; heap[l] &#123;</span><br><span class="line">			min = l</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> r &lt; n &amp;&amp; heap[min] &gt; heap[r] &#123;</span><br><span class="line">			min = r</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> i != min &#123;</span><br><span class="line">			heap[i], heap[min] = heap[min], heap[i]</span><br><span class="line">			i = min</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快排思路</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthLargest</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	<span class="keyword">return</span> selectKth(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>, <span class="built_in">len</span>(nums)-k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectKth</span><span class="params">(nums []<span class="type">int</span>, left, right, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> left == right &#123;</span><br><span class="line">		<span class="keyword">return</span> nums[left]</span><br><span class="line">	&#125;</span><br><span class="line">	pivotIndex := partition(nums, left, right)</span><br><span class="line">	<span class="keyword">if</span> k == pivotIndex &#123;</span><br><span class="line">		<span class="keyword">return</span> nums[k]</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> k &lt; pivotIndex &#123;</span><br><span class="line">		<span class="keyword">return</span> selectKth(nums, left, pivotIndex<span class="number">-1</span>, k)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> selectKth(nums, pivotIndex+<span class="number">1</span>, right, k)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(nums []<span class="type">int</span>, left, right <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	pivotIndex := left + rand.Intn(right-left+<span class="number">1</span>)</span><br><span class="line">	pivot := nums[pivotIndex]</span><br><span class="line">	nums[pivotIndex], nums[right] = nums[right], nums[pivotIndex]</span><br><span class="line">	storeIndex := left</span><br><span class="line">	<span class="keyword">for</span> i := left; i &lt;= right; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> nums[i] &lt; pivot &#123;</span><br><span class="line">			nums[storeIndex], nums[i] = nums[i], nums[storeIndex]</span><br><span class="line">			storeIndex++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	nums[right], nums[storeIndex] = nums[storeIndex], nums[right]</span><br><span class="line">	<span class="keyword">return</span> storeIndex</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/categories/">Category</a></li>
        
          <li><a href="/tags/">Tag</a></li>
        
          <li><a href="/search">Search</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/jonasrepo.github.io">Projects</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE"><span class="toc-number">1.</span> <span class="toc-text">相关题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7"><span class="toc-number">2.</span> <span class="toc-text">32 最长有效括号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91"><span class="toc-number">2.1.</span> <span class="toc-text">【题目描述】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-number">2.1.1.</span> <span class="toc-text">示例：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91"><span class="toc-number">2.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91"><span class="toc-number">2.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#155-%E6%9C%80%E5%B0%8F%E6%A0%88"><span class="toc-number">3.</span> <span class="toc-text">155 最小栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-1"><span class="toc-number">3.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-1"><span class="toc-number">3.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-1"><span class="toc-number">3.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">4.</span> <span class="toc-text">23 合并K个升序链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-2"><span class="toc-number">4.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-2"><span class="toc-number">4.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-2"><span class="toc-number">4.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-number">5.</span> <span class="toc-text">232 用栈实现队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-3"><span class="toc-number">5.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-3"><span class="toc-number">5.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-3"><span class="toc-number">5.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#225-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="toc-number">6.</span> <span class="toc-text">225 用队列实现栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-4"><span class="toc-number">6.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-4"><span class="toc-number">6.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-4"><span class="toc-number">6.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="toc-number">7.</span> <span class="toc-text">20 有效的括号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-5"><span class="toc-number">7.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-5"><span class="toc-number">7.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-5"><span class="toc-number">7.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1047-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="toc-number">8.</span> <span class="toc-text">1047 删除字符串中的所有相邻重复项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-6"><span class="toc-number">8.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-6"><span class="toc-number">8.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-6"><span class="toc-number">8.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-number">9.</span> <span class="toc-text">150 逆波兰表达式求值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-7"><span class="toc-number">9.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-7"><span class="toc-number">9.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-7"><span class="toc-number">9.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">10.</span> <span class="toc-text">239 滑动窗口最大值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-8"><span class="toc-number">10.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-8"><span class="toc-number">10.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-8"><span class="toc-number">10.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#347-%E5%89%8D-K-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0"><span class="toc-number">11.</span> <span class="toc-text">347 前 K 个高频元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-9"><span class="toc-number">11.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-9"><span class="toc-number">11.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-9"><span class="toc-number">11.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#71-%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84"><span class="toc-number">12.</span> <span class="toc-text">71 简化路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-10"><span class="toc-number">12.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-10"><span class="toc-number">12.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-10"><span class="toc-number">12.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="toc-number">13.</span> <span class="toc-text">215 数组中的第K个最大元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91-11"><span class="toc-number">13.1.</span> <span class="toc-text">【题目描述】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E3%80%91-11"><span class="toc-number">13.2.</span> <span class="toc-text">【解题思路】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%91-11"><span class="toc-number">13.3.</span> <span class="toc-text">【实现代码】</span></a></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://localhost:4000/2024/04/03/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%8E%E5%A0%86/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://localhost:4000/2024/04/03/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%8E%E5%A0%86/&text=栈与队列与堆"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://localhost:4000/2024/04/03/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%8E%E5%A0%86/&title=栈与队列与堆"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://localhost:4000/2024/04/03/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%8E%E5%A0%86/&is_video=false&description=栈与队列与堆"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=栈与队列与堆&body=Check out this article: http://localhost:4000/2024/04/03/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%8E%E5%A0%86/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://localhost:4000/2024/04/03/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%8E%E5%A0%86/&title=栈与队列与堆"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://localhost:4000/2024/04/03/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%8E%E5%A0%86/&title=栈与队列与堆"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://localhost:4000/2024/04/03/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%8E%E5%A0%86/&title=栈与队列与堆"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://localhost:4000/2024/04/03/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%8E%E5%A0%86/&title=栈与队列与堆"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://localhost:4000/2024/04/03/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%8E%E5%A0%86/&name=栈与队列与堆&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://localhost:4000/2024/04/03/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%8E%E5%A0%86/&t=栈与队列与堆"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2024
    jonas
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/categories/">Category</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a href="/search">Search</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/jonasrepo.github.io">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
