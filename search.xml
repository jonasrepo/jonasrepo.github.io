<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>elasticsearch</title>
      <link href="/2024/04/14/read/elasticsearch/"/>
      <url>/2024/04/14/read/elasticsearch/</url>
      
        <content type="html"><![CDATA[<blockquote><p>es 是基于lucene开发出的近实时文档型数据库</p></blockquote><p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/ElasticSearch%e7%9f%a5%e8%af%86%e4%bd%93%e7%b3%bb%e8%af%a6%e8%a7%a3/01%20%e8%ae%a4%e7%9f%a5%ef%bc%9aElasticSearch%e5%9f%ba%e7%a1%80%e6%a6%82%e5%bf%b5.md">参考阅读</a></p><p>分片<br>分片：索引数据被分片存在不同的节点上，分片本质是一个Lucene索引<br>副本：对副分片的复制分片称为副本分片</p><p>节点：</p><ol><li>主节点：负责集群的管理和源数据的维护，索引的创建和删除操作，确保集群正常运行，不需要涉及到文档级别的变更和搜索等操作</li><li>数据节点: 存储，检索和处理数据，提供搜索和聚合功能（数据节点，热数据节点，冷数据节点，温数据节点）</li><li>协调节点：处理客户端请求，协调数据节点工作，优化分布式搜索</li><li>ingest节点：预处理节点，负责数据预处理，如过滤，转换等</li></ol><p>映射类型</p><ol><li>动态映射：不创建index，直接写入，boolean，float，long，(嵌套数据类型)object，array，date，字符串类型能被检测，其他的会映射成text，可能会出现字段不匹配的情况</li><li>静态映射：需要先建立索引，明确字段类型<ol><li>dynamic : false, 可以不创建索引写入数据，但是不能被_search, 可以被_get</li><li>dynamic : strict, 写入报错<br>如果不希望doc被索引，可以在mappings的设置中将enabled:false,如果只是想索引enabled:false文档的其他字段，可以将该字段的strore:true</li></ol></li></ol><p>null_value<br>默认情况下null字段不能被检索，可以设置null_value:”NULL”改为可null检索，支持的字段有arrays，boolean，date，Gore—point，ip, keyword, numeric, point等</p><p>数据类型</p><table><thead><tr><th>数据类型</th><th>类型类别</th><th>描述</th></tr></thead><tbody><tr><td><strong>text</strong></td><td>核心数据类型</td><td>用于全文搜索的文本数据，会被分析（分词）。</td></tr><tr><td><strong>keyword</strong></td><td>核心数据类型</td><td>用于精确值搜索，不会被分析（不分词），适用于过滤、排序和聚合操作。</td></tr><tr><td><strong>date</strong></td><td>核心数据类型</td><td>日期或日期时间，支持多种日期格式。</td></tr><tr><td><strong>long</strong></td><td>数值类型</td><td>用于长整型数据。</td></tr><tr><td><strong>integer</strong></td><td>数值类型</td><td>用于整型数据。</td></tr><tr><td><strong>short</strong></td><td>数值类型</td><td>用于短整型数据。</td></tr><tr><td><strong>byte</strong></td><td>数值类型</td><td>用于字节数据。</td></tr><tr><td><strong>double</strong></td><td>数值类型</td><td>用于双精度浮点数数据。</td></tr><tr><td><strong>float</strong></td><td>数值类型</td><td>用于浮点数数据。</td></tr><tr><td><strong>boolean</strong></td><td>核心数据类型</td><td>布尔类型，接受<code>true</code>和<code>false</code>。</td></tr><tr><td><strong>object</strong></td><td>复杂数据类型</td><td>用于单个JSON对象。</td></tr><tr><td><strong>nested</strong></td><td>复杂数据类型</td><td>用于<strong>对象数组</strong>，支持数组中的每个对象独立索引和查询。</td></tr><tr><td><strong>geo_point</strong></td><td>地理位置数据类型</td><td>用于地理位置数据，支持经纬度坐标。</td></tr><tr><td><strong>geo_shape</strong></td><td>地理位置数据类型</td><td>用于复杂地理位置数据，如多边形等。</td></tr><tr><td><strong>ip</strong></td><td>特殊数据类型</td><td>用于IP地址，支持IPv4和IPv6。</td></tr><tr><td><strong>completion</strong></td><td>特殊数据类型</td><td>用于自动补全功能，快速提供搜索建议。</td></tr><tr><td><strong>token_count</strong></td><td>特殊数据类型</td><td>用于统计分词后的词元数量。</td></tr><tr><td><strong>integer_range</strong></td><td>范围数据类型</td><td>用于存储整数的范围数据。</td></tr><tr><td><strong>float_range</strong></td><td>范围数据类型</td><td>用于存储浮点数的范围数据。</td></tr><tr><td><strong>long_range</strong></td><td>范围数据类型</td><td>用于存储长整型的范围数据。</td></tr><tr><td><strong>double_range</strong></td><td>范围数据类型</td><td>用于存储双精度浮点数的范围数据。</td></tr><tr><td><strong>date_range</strong></td><td>范围数据类型</td><td>用于存储日期的范围数据。</td></tr></tbody></table><h2 id="与Mysql的对比"><a href="#与Mysql的对比" class="headerlink" title="与Mysql的对比"></a>与Mysql的对比</h2><p>以下表格展示了Elasticsearch和MySQL在不同概念上的映射关系，帮助理解它们在概念上的对应和差异：</p><table><thead><tr><th>Elasticsearch</th><th>MySQL</th><th>描述</th></tr></thead><tbody><tr><td>索引(Index)</td><td>数据库(Database)</td><td>存储数据的顶层单位。Elasticsearch的索引是数据的容器，MySQL的数据库也是。</td></tr><tr><td>类型(Type)（已废弃）</td><td>表(Table)</td><td>以前Elasticsearch使用类型来区分索引内的数据，但现在已经废弃。MySQL的表是结构化数据的集合。</td></tr><tr><td>文档(Document)</td><td>行(Row)</td><td>数据的基本单位。Elasticsearch存储JSON文档，而MySQL存储行数据。</td></tr><tr><td>字段(Field)</td><td>列(Column)</td><td>数据的属性。Elasticsearch的文档由字段组成，MySQL的行由列组成。</td></tr><tr><td>映射(Mapping)</td><td>表结构(Schema)</td><td>定义数据结构的规则。Elasticsearch的映射定义了索引中文档的字段类型，MySQL的表结构定义了列的数据类型。</td></tr><tr><td>倒排索引(Inverted Index)</td><td>索引(Index)</td><td>优化搜索的数据结构。Elasticsearch通过倒排索引实现快速文本搜索，MySQL的索引（如B树索引）优化查询性能。</td></tr><tr><td>查询DSL(Query DSL)</td><td>SQL(Structured Query Language)</td><td>查询语言。Elasticsearch使用Query DSL进行数据查询，MySQL使用SQL。</td></tr><tr><td>分片(Shard)</td><td>分区(Partition)</td><td>数据分布策略。Elasticsearch用分片实现数据的水平分割和分布，MySQL的分区也是将数据分散存储。</td></tr><tr><td>复制(Replica)</td><td>副本(Replica)</td><td>数据的冗余副本。Elasticsearch和MySQL都支持数据复制，提高数据的可用性和读取性能。</td></tr></tbody></table><h2 id="DSL"><a href="#DSL" class="headerlink" title="DSL"></a>DSL</h2><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">PUT /goods</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;brandName&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;categoryName&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;createTime&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;date&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;format&quot;</span><span class="punctuation">:</span> <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">      <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;search_analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  # 根据情况选择是否要修改</span><br><span class="line">  <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;number_of_shards&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;number_of_replicas&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE goods</span><br></pre></td></tr></table></figure><h4 id="重建索引"><a href="#重建索引" class="headerlink" title="重建索引"></a>重建索引</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">POST _reindex                    </span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;goods&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dest&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;goods1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">DELETE goods</span><br><span class="line"></span><br><span class="line">POST _reindex                    </span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;goods1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dest&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;goods&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">DELETE goods1</span><br></pre></td></tr></table></figure><h3 id="操作文档"><a href="#操作文档" class="headerlink" title="操作文档"></a>操作文档</h3><h4 id="创建文档"><a href="#创建文档" class="headerlink" title="创建文档"></a>创建文档</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 这种方式，同样的id无法重新创建</span><br><span class="line">PUT goods/_create/<span class="number">1</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;brandName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Apple&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;categoryName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;手机&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;createTime&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-10-22 19:12:56&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="number">8799</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;saleNum&quot;</span><span class="punctuation">:</span> <span class="number">599</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;stock&quot;</span><span class="punctuation">:</span> <span class="number">1000</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Apple iPhone 15 Pro 512GB 远峰蓝色 支持移动联通电信5G 双卡双待手机&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"># 这种方式，同样的id会覆盖原有的</span><br><span class="line">PUT goods/_doc/<span class="number">2</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;brandName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Apple&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;categoryName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;手机&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;createTime&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-10-22 19:12:56&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="number">8799</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;saleNum&quot;</span><span class="punctuation">:</span> <span class="number">599</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;stock&quot;</span><span class="punctuation">:</span> <span class="number">1000</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Apple iPhone 15 Pro 256GB 远峰蓝色 支持移动联通电信5G 双卡双待手机&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST goods/_update/<span class="number">1</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;doc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="string">&quot;Apple iPhone 13 Pro (A2639) 256GB 远峰蓝色 支持移动联通电信5G 双卡双待手机111&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE goods/_doc/<span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="获取文档"><a href="#获取文档" class="headerlink" title="获取文档"></a>获取文档</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 获取单个文档</span><br><span class="line">GET goods/_doc/<span class="number">1</span></span><br><span class="line"></span><br><span class="line"># 批量获取</span><br><span class="line">GET books/_doc/_mget</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;ids&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;1&quot;</span><span class="punctuation">,</span><span class="string">&quot;2&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Match查询"><a href="#Match查询" class="headerlink" title="Match查询"></a>Match查询</h3><blockquote><p>query的查询字段会进行相关性_score的计算，而filter仅仅用来筛选</p></blockquote><h4 id="查询所有"><a href="#查询所有" class="headerlink" title="查询所有"></a>查询所有</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST goods/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      </span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="match-phrase短语查询"><a href="#match-phrase短语查询" class="headerlink" title="match_phrase短语查询"></a>match_phrase短语查询</h4><blockquote><p>match 是做分词匹配，批到到分词的word就行，match_phrase是必须要找到满足顺序的word+phase才行</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST goods/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_phrase&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;支持&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="匹配查询"><a href="#匹配查询" class="headerlink" title="匹配查询"></a>匹配查询</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST goods/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;移动多余&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;minimum_should_match&quot;</span><span class="punctuation">:</span> <span class="string">&quot;75%&quot;</span><span class="comment">//至少满足条件的比例</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="模糊匹配查询"><a href="#模糊匹配查询" class="headerlink" title="模糊匹配查询"></a>模糊匹配查询</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POST goods/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;wildcard&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*鞋&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Term查询"><a href="#Term查询" class="headerlink" title="Term查询"></a>Term查询</h3><p>Term查询对查询内容不做分词，直接去倒排索引里去匹配文档，<strong>精确匹配</strong>。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">POST goods/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;手机&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"># 匹配多个term</span><br><span class="line">POST goods/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;双卡&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;待&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h3><p>复杂查询基本会用到<code>bool</code>关键字。</p><ul><li><strong>must</strong> : 多个查询条件的完全匹配,相当于 and。</li><li><strong>must_not</strong> ::多个查询条件的相反匹配，相当于 not。</li><li><strong>should</strong> : 至少有一个查询条件匹配, 相当于 or</li></ul><h4 id="bool-must"><a href="#bool-must" class="headerlink" title="bool + must"></a>bool + must</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># 布尔查询，可以组合多个过滤语句来过滤文档</span><br><span class="line">POST goods/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;must&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Wolfgang Mauerer&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;date&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2010-06-01&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"># 匹配多个字段</span><br><span class="line">GET product/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;must&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span> <span class="attr">&quot;match_phrase&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;连衣裙&quot;</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span> <span class="attr">&quot;match_phrase&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;en_intro&quot;</span><span class="punctuation">:</span> <span class="string">&quot;korean&quot;</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span> <span class="attr">&quot;match_phrase&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;intro&quot;</span><span class="punctuation">:</span> <span class="string">&quot;御姐&quot;</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="bool-filter-range"><a href="#bool-filter-range" class="headerlink" title="bool + filter + range"></a>bool + filter + range</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">POST books/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;must&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Wolfgang Mauerer&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;date&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2010-06-01&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">POST goods/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;must&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;华为&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;gte&quot;</span><span class="punctuation">:</span> <span class="number">5000</span><span class="punctuation">,</span></span><br><span class="line">              <span class="attr">&quot;lte&quot;</span><span class="punctuation">:</span> <span class="number">10000</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="boosting-query-提高查询"><a href="#boosting-query-提高查询" class="headerlink" title="boosting query(提高查询)"></a>boosting query(提高查询)</h3><blockquote><p>不同于bool查询，bool查询中只要一个子查询条件不匹配那么搜索的数据就不会出现。而boosting query则是降低显示的权重&#x2F;优先级（即score)。</p></blockquote><p>比如搜索逻辑是 name &#x3D; ‘apple’ and type &#x3D;‘fruit’，对于只满足部分条件的数据，不是不显示，而是降低显示的优先级（即score)</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对匹配`pie`的做降级显示处理</span></span><br><span class="line">GET /test-dsl-boosting/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;boosting&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;positive&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;apple&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;negative&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pie&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;negative_boost&quot;</span><span class="punctuation">:</span> <span class="number">0.5</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="query-string查询"><a href="#query-string查询" class="headerlink" title="query_string查询"></a>query_string查询</h3><p><code>query_string</code>查询在Elasticsearch中提供了强大且灵活的查询语法，允许用户执行复杂的搜索，包括字段特定搜索、通配符搜索、布尔搜索等。这种查询类型让用户可以在一个查询中结合使用多种查询语法，非常适合那些需要执行高级文本搜索的场景。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;query_string&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="string">&quot;this AND that OR thus&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;default_field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;content&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这将搜索`title`字段中包含短语&quot;quick brown fox&quot;的文档。</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;query_string&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="string">&quot;title: (quick brown fox)&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="comment">//正则</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;query_string&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="string">&quot;name: John*&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="comment">//bool</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;query_string&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="string">&quot;title: (quick OR brown) AND body: fox&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="comment">//范围搜索，使用`[]`表示闭区间，使用`&#123;&#125;`表示开区间：</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;query_string&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="string">&quot;publish_date: [2020-01-01 TO 2020-12-31]&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="翻页查询"><a href="#翻页查询" class="headerlink" title="翻页查询"></a>翻页查询</h3><h4 id="Scroll分页"><a href="#Scroll分页" class="headerlink" title="Scroll分页"></a>Scroll分页</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 第一次使用 scroll API</span><br><span class="line">POST goods/_search?scroll=<span class="number">2</span>m</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"># 进行翻页</span><br><span class="line">POST /_search/scroll                                                    </span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scroll&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;2m&quot;</span><span class="punctuation">,</span>   </span><br><span class="line">  <span class="attr">&quot;scroll_id&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;FGluY2x1ZGVfY29udGV4dF91dWlkDXF1ZXJ5QW5kRmV0Y2gBFkxBWkYwOGw2U1dPSF94aHZTelFkaWcAAAAAAAADHhZoU05ERFl3WFIycXM3M3JKMmRQVkJB&quot;</span> </span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="from-size分页"><a href="#from-size分页" class="headerlink" title="from + size分页"></a>from + size分页</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">POST goods/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="number">6</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;asc&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h3><h4 id="最大、最小、平均"><a href="#最大、最小、平均" class="headerlink" title="最大、最小、平均"></a>最大、最小、平均</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">POST goods/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;avg_price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;avg&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;price&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">POST goods/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;min_price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;min&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;price&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">POST goods/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;max_price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;max&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;price&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST goods/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;gte&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;lte&quot;</span><span class="punctuation">:</span> <span class="number">20</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="高亮查询"><a href="#高亮查询" class="headerlink" title="高亮查询"></a>高亮查询</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">POST goods/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;跑鞋&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;highlight&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;pre_tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="string">&quot;&lt;font color=&#x27;red&#x27;&gt;&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;post_tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="string">&quot;&lt;/font&gt;&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POST goods/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;brandNameName&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;brandName&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">POST goods/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;brandNameName&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;brandName&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;avgPrice&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;avg&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;price&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="分析分词"><a href="#分析分词" class="headerlink" title="分析分词"></a>分析分词</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;standard&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Linus 在90年代开发出了linux操作系统&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">POST _analyze</span><br><span class="line"><span class="punctuation">&#123;</span>  </span><br><span class="line">    <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Linus 在90年代开发出了linux操作系统&quot;</span>  </span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">POST _analyze</span><br><span class="line"><span class="punctuation">&#123;</span>  </span><br><span class="line">    <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Linus 在90年代开发出了linux操作系统&quot;</span>  </span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">POST _analyze</span><br><span class="line"><span class="punctuation">&#123;</span>  </span><br><span class="line">    <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;中华人民共和国国歌&quot;</span>  </span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">POST _analyze</span><br><span class="line"><span class="punctuation">&#123;</span>  </span><br><span class="line">    <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;中华人民共和国国歌&quot;</span>  </span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="https://i.postimg.cc/htkt8M2m/es-th-2-3.png" alt="es-th-2-3.png"><br>索引流程<br><img src="https://i.postimg.cc/PrHdB8xc/image.png" alt="image.png"></p><ul><li>协调节点默认使用文档ID参与计算（也支持通过routing），以便为路由提供合适的分片。<code>shard = hash(document_id) % (num_of_primary_shards)</code></li><li>当分片所在的节点接收到来自协调节点的请求后，会将请求写入到Memory Buffer，然后定时（<strong>默认是每隔1秒</strong>）写入到Filesystem Cache，这个从Memory Buffer到Filesystem Cache的过程就叫做refresh；</li><li>当然在某些情况下，存在Memory Buffer和Filesystem Cache的数据可能会丢失，ES是通过translog的机制来保证数据的可靠性的。其实现机制是接收到请求后，同时也会写入到translog中，当Filesystem cache中的数据写入到磁盘中时，才会清除掉，这个过程叫做flush。</li><li>在flush过程中，内存中的缓冲将被清除，内容被写入一个新段，段的fsync将创建一个新的提交点，并将内容刷新到磁盘，旧的translog将被删除并开始一个新的translog。 flush触发的时机是定时触发（默认30分钟）或者translog变得太大（默认为512M）时。</li></ul><p>通过分步骤看数据持久化过程：<strong>write(in memory buffer) -&gt; refresh(file system cache segment) -&gt; flush(disk) -&gt; merge(segment)</strong></p><p>文档读取流程<br><img src="https://i.postimg.cc/Pr38cYDM/image.png" alt="image.png"></p><blockquote><p>所有的搜索系统一般都是两阶段查询，第一阶段查询到匹配的DocID，第二阶段再查询DocID对应的完整文档，这种在Elasticsearch中称为query_then_fetch</p></blockquote><ol><li>在初始查询阶段时，查询会广播到索引中每一个分片拷贝（主分片或者副本分片）。 每个分片在本地执行搜索并构建一个匹配文档的大小为 from + size 的优先队列。PS：在2. 搜索的时候是会查询Filesystem Cache的，但是有部分数据还在Memory Buffer，所以搜索是近实时的。</li><li>每个分片返回各自优先队列中 所有文档的 ID 和排序值 给协调节点，它合并这些值到自己的优先队列中来产生一个全局排序后的结果列表。</li><li>接下来就是 取回阶段，协调节点辨别出哪些文档需要被取回并向相关的分片提交多个 GET 请求。每个分片加载并丰富文档，如果有需要的话，接着返回文档给协调节点。一旦所有的文档都被取回了，协调节点返回结果给客户端。</li></ol><h2 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h2><h3 id="硬件配置优化"><a href="#硬件配置优化" class="headerlink" title="硬件配置优化"></a>硬件配置优化</h3><ol><li>cpu频率不重要，多核更好</li><li>内存：理想64G，16，32G也可以，小于8G不行，一半给luecen，一半给jvm</li><li>禁用swap</li><li>使用g1 gc</li><li>使用ssd磁盘，不要使用cfq调度算法，可以使用noop，deadline</li></ol><h3 id="索引设置优化"><a href="#索引设置优化" class="headerlink" title="索引设置优化"></a>索引设置优化</h3><ol><li>当有大量数据提交的时候，建议采用批量提交</li><li>增加refresh的时间间隔，可以减少segment合并的压力</li><li>增加Translog sync_interval， flush_threshold_size</li><li>合理设置是否分词：analyzed 和 not_analyzed</li><li>减少默认副本的数量，默认是3个</li></ol><h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><ol><li>带routing查询</li><li>尽量用filter代替query，filter不需要算分且有缓存</li><li>避免深度翻页 -&gt; scroll查询</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 八股 </tag>
            
            <tag> elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="/2024/04/13/leetcode/%E6%8E%92%E5%BA%8F/"/>
      <url>/2024/04/13/leetcode/%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://pic2.zhimg.com/v2-f718f6b01ad35a60b9d4f02330f81439_r.jpg"></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”到数列的顶端。<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(arr)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">flag := <span class="literal">true</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n-i<span class="number">-1</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>] &#123;</span><br><span class="line">arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j]</span><br><span class="line">flag = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> flag &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>开启一个循环，每轮从未排序区间选择最小的元素，将其放到已排序区间的末尾。<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(arr)</span><br><span class="line"><span class="comment">// 每次选一个最小的，放在已排好序的末尾</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">min := i</span><br><span class="line"><span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> arr[j] &lt; arr[min] &#123;</span><br><span class="line">min = j</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[i], arr[min] = arr[min], arr[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>具体来说，我们在未排序区间选择一个基准元素，将该元素与其左侧已排序区间的元素逐一比较大小，并将该元素插入到正确的位置。<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(arr)</span><br><span class="line"><span class="comment">// 左侧是已排好序的，右侧的元素逐渐和左侧的元素比较</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">current := arr[i]</span><br><span class="line">j := i - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> ; j &gt;= <span class="number">0</span>; j-- &#123;</span><br><span class="line"><span class="keyword">if</span> current &lt; arr[j] &#123;</span><br><span class="line">arr[j+<span class="number">1</span>] = arr[j]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最后的时候j--了，所以需要j+1</span></span><br><span class="line">arr[j+<span class="number">1</span>] = current</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序（merge sort）是一种基于分治策略的排序算法，包含图 11-10 所示的“划分”和“合并”阶段。</p><ol><li><strong>划分阶段</strong>：通过递归不断地将数组从中点处分开，将长数组的排序问题转换为短数组的排序问题。</li><li><strong>合并阶段</strong>：当子数组长度为 1 时终止划分，开始合并，持续地将左右两个较短的有序数组合并为一个较长的有序数组，直至结束。<br><img src="https://www.hello-algo.com/chapter_sorting/merge_sort.assets/merge_sort_overview.png"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sort</span><span class="params">(arr []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(arr)</span><br><span class="line"><span class="keyword">if</span> n &lt;= <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line">mid := n &gt;&gt; <span class="number">1</span></span><br><span class="line">left := sort(arr[:mid])</span><br><span class="line">right := sort(arr[mid:])</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> merge(left, right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(left, right []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">n1 := <span class="built_in">len</span>(left)</span><br><span class="line">n2 := <span class="built_in">len</span>(right)</span><br><span class="line">res := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">i, j := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &lt; n1 &amp;&amp; j &lt; n2 &#123;</span><br><span class="line"><span class="keyword">if</span> left[i] &lt;= right[j] &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, left[i])</span><br><span class="line">i++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, right[j])</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 未比较完的元素</span></span><br><span class="line"><span class="keyword">if</span> i != n1 &#123;</span><br><span class="line"><span class="keyword">for</span> ; i &lt; n1; i++ &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, left[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> j != n2 &#123;</span><br><span class="line"><span class="keyword">for</span> ; j &lt; n2; j++ &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, right[j])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><p>快速排序（quick sort）是一种基于分治策略的排序算法，运行高效，应用广泛。<br>快速排序的核心操作是“哨兵划分”，其目标是：选择数组中的某个元素作为“基准数”，将所有小于基准数的元素移到其左侧，而大于基准数的元素移到其右侧。具体来说，哨兵划分的流程如图 11-8 所示。</p><ol><li>选取数组最左端元素作为基准数，初始化两个指针 <code>i</code> 和 <code>j</code> 分别指向数组的两端。</li><li>设置一个循环，在每轮中使用 <code>i</code>（<code>j</code>）分别寻找第一个比基准数大（小）的元素，然后交换这两个元素。</li><li>循环执行步骤 <code>2.</code> ，直到 <code>i</code> 和 <code>j</code> 相遇时停止，最后将基准数交换至两个子数组的分界线。</li></ol><p><img src="https://www.hello-algo.com/chapter_sorting/quick_sort.assets/pivot_division_step1.png"><br>与归并的区别<br>归并是先分区成子问题，再将子问题合并<br>快排是分区，再处理子问题</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(arr)</span><br><span class="line"><span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">pivot := partition(arr)</span><br><span class="line">sort(arr[:pivot])</span><br><span class="line">sort(arr[pivot+<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(arr []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">pivot := arr[<span class="number">0</span>]</span><br><span class="line"><span class="comment">//l 为1，不然会出现r--为-1</span></span><br><span class="line">l, r := <span class="number">1</span>, <span class="built_in">len</span>(arr)<span class="number">-1</span></span><br><span class="line"><span class="comment">//这里是 &lt;= </span></span><br><span class="line"><span class="keyword">for</span> l &lt;= r &#123;</span><br><span class="line"><span class="keyword">for</span> l &lt;= r &amp;&amp; arr[l] &lt;= pivot &#123;</span><br><span class="line">l++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> l &lt;= r &amp;&amp; arr[r] &gt;= pivot &#123;</span><br><span class="line">r--</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需要加这个判断，应该l可能&gt;=r</span></span><br><span class="line"><span class="keyword">if</span> l &lt; r &#123;</span><br><span class="line">arr[l], arr[r] = arr[r], arr[l]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回的是r， 不是l</span></span><br><span class="line">arr[<span class="number">0</span>], arr[r] = arr[r], arr[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p> 算法步骤</p><ol><li>创建一个堆 H[0……n-1]；</li><li>把堆首（最大值）和堆尾互换；</li><li>把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；</li><li>重复步骤 2，直到堆的尺寸为 1。<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/heapSort.gif"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(arr)</span><br><span class="line"><span class="comment">// 构建大顶堆</span></span><br><span class="line"><span class="keyword">for</span> i := n/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">shiftdown(arr, i, n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一个个交换元素</span></span><br><span class="line"><span class="keyword">for</span> j := n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j-- &#123;</span><br><span class="line">arr[<span class="number">0</span>], arr[j] = arr[j], arr[<span class="number">0</span>]</span><br><span class="line">shiftdown(arr, <span class="number">0</span>, j) <span class="comment">// 注意这里传入的是j</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大顶堆</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shiftdown</span><span class="params">(arr []<span class="type">int</span>, i, n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i &lt; n &#123;</span><br><span class="line">l, r := <span class="number">2</span>*i+<span class="number">1</span>, <span class="number">2</span>*i+<span class="number">2</span></span><br><span class="line">max := i</span><br><span class="line"><span class="keyword">if</span> l &lt; n &amp;&amp; arr[l] &gt; arr[max] &#123;</span><br><span class="line">max = l</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> r &lt; n &amp;&amp; arr[r] &gt; arr[max] &#123;</span><br><span class="line">max = r</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> max != i &#123;</span><br><span class="line">arr[i], arr[max] = arr[max], arr[i]</span><br><span class="line">i = max</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码设计</title>
      <link href="/2024/04/12/leetcode/%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1/"/>
      <url>/2024/04/12/leetcode/%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="146-LRU缓存机制"><a href="#146-LRU缓存机制" class="headerlink" title="146 LRU缓存机制"></a>146 LRU缓存机制</h2><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制 。实现 <code>LRUCache</code> 类：</p><ul><li><code>LRUCache(int capacity)</code> 以正整数作为容量<code>capacity</code>初始化 LRU 缓存</li><li><code>int get(int key)</code> 如果关键字<code>key</code>存在于缓存中，则返回关键字的值，否则返回<code>-1</code>。</li><li><code>void put(int key, int value)</code> 如果关键字<code>key</code>已经存在，则变更其数据值<code>value</code>；如果不存在，则插入该组<code>key-value</code>。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</li></ul><h3 id="【解题思路】"><a href="#【解题思路】" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>LRU缓存机制可以通过哈希表配合双向链表实现。哈希表负责快速定位节点，双向链表负责按照使用顺序组织节点。</p><ol><li><strong>双向链表</strong>：其元素称为节点，每个节点包含<code>key</code>、<code>value</code>、指向前一个节点的指针<code>prev</code>和指向后一个节点的指针<code>next</code>。双向链表可以让我们以O(1)的时间复杂度添加和删除节点，尤其是在头部和尾部操作。</li><li><strong>哈希表</strong>：以<code>key</code>作为键，节点地址作为值。这样可以快速查找到每个<code>key</code>对应的节点，进而以O(1)的时间复杂度获取节点值和更新节点位置。</li></ol><p>操作流程如下：</p><ul><li><strong>get操作</strong>：如果<code>key</code>存在于哈希表中，则哈希表返回对应的节点。将该节点移动到双向链表的头部（表示最近使用过）。如果<code>key</code>不存在，则返回<code>-1</code>。</li><li><strong>put操作</strong>：如果<code>key</code>存在，更新对应节点的值，并将该节点移动到双向链表头部。如果<code>key</code>不存在，创建一个新的节点，添加到双向链表头部，并在哈希表中添加<code>key</code>和节点的映射。如果超出容量，删除双向链表尾部的节点，并移除哈希表中对应的<code>key</code>。</li></ul><h3 id="【实现代码】"><a href="#【实现代码】" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    size       <span class="type">int</span></span><br><span class="line">    capacity   <span class="type">int</span></span><br><span class="line">    cache      <span class="keyword">map</span>[<span class="type">int</span>]*DLinkedNode</span><br><span class="line">    head, tail *DLinkedNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双端循环链表 + hashmap</span></span><br><span class="line"><span class="comment">// 查，改， 增都需要将节点移动到头部</span></span><br><span class="line"><span class="comment">// head, tail加入dummy节点</span></span><br><span class="line"><span class="comment">// MoveToHead 将节点移动到头部 </span></span><br><span class="line"><span class="comment">// AddToHead 将节点加入到头部</span></span><br><span class="line"><span class="comment">// RemoveNode 移出指定节点 </span></span><br><span class="line"><span class="comment">// RemoveTail 移出尾部节点 </span></span><br><span class="line"><span class="keyword">type</span> DLinkedNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    key, value <span class="type">int</span></span><br><span class="line">    prev, next *DLinkedNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initDLinkedNode</span><span class="params">(key, value <span class="type">int</span>)</span></span> *DLinkedNode &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;DLinkedNode&#123;</span><br><span class="line">        key:   key,</span><br><span class="line">        value: value,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="type">int</span>)</span></span> LRUCache &#123;</span><br><span class="line">    l := LRUCache&#123;</span><br><span class="line">        cache:    <span class="keyword">map</span>[<span class="type">int</span>]*DLinkedNode&#123;&#125;,</span><br><span class="line">        head:     initDLinkedNode(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        tail:     initDLinkedNode(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        capacity: capacity,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//首位相连</span></span><br><span class="line">    l.head.next = l.tail</span><br><span class="line">    l.tail.prev = l.head</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LRUCache)</span></span> get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> node, exists := l.cache[key]; exists &#123;</span><br><span class="line">        l.moveToHead(node)</span><br><span class="line">        <span class="keyword">return</span> node.value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LRUCache)</span></span> put(key <span class="type">int</span>, value <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> node, exists := l.cache[key]; exists &#123;</span><br><span class="line">        node.value = value</span><br><span class="line">        l.moveToHead(node)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node := initDLinkedNode(key, value)</span><br><span class="line">        l.cache[key] = node</span><br><span class="line">        l.addToHead(node)</span><br><span class="line">        l.size++</span><br><span class="line">        <span class="keyword">if</span> l.size &gt; l.capacity &#123;</span><br><span class="line">            removed := l.removeTail()</span><br><span class="line">            <span class="built_in">delete</span>(l.cache, removed.key)</span><br><span class="line">            l.size--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LRUCache)</span></span> addToHead(node *DLinkedNode) &#123;</span><br><span class="line">    node.prev = l.head</span><br><span class="line">    node.next = l.head.next</span><br><span class="line">    l.head.next.prev = node</span><br><span class="line">    l.head.next = node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LRUCache)</span></span> removeNode(node *DLinkedNode) &#123;</span><br><span class="line">    node.prev.next = node.next</span><br><span class="line">    node.next.prev = node.prev</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LRUCache)</span></span> moveToHead(node *DLinkedNode) &#123;</span><br><span class="line">    l.removeNode(node)</span><br><span class="line">    l.addToHead(node)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LRUCache)</span></span> removeTail() *DLinkedNode &#123;</span><br><span class="line">    node := l.tail.prev</span><br><span class="line">    l.removeNode(node)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707 设计链表"></a>707 设计链表</h2><h3 id="【题目描述】-1"><a href="#【题目描述】-1" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：<code>val</code> 和 <code>next</code>。<code>val</code> 是当前节点的值，<code>next</code> 是指向下一个节点的指针&#x2F;引用。如果要使用双向链表，则还需要一个属性 <code>prev</code> 以指示链表中的上一个节点。在链表类中实现这些功能：</p><ul><li>get(index)：获取链表中第 <code>index</code> 个节点的值。如果索引无效，则返回-1。</li><li>addAtHead(val)：在链表的第一个元素之前添加一个值为 <code>val</code> 的节点。插入后，新节点将成为链表的第一个节点。</li><li>addAtTail(val)：将值为 <code>val</code> 的节点追加到链表的最后一个元素。</li><li>addAtIndex(index, val)：在链表中的第 <code>index</code> 个节点之前添加值为 <code>val</code> 的节点。如果 <code>index</code> 等于链表的长度，则该节点将附加到链表的末尾。如果 <code>index</code> 大于链表长度，则不会插入节点。如果 <code>index</code> 小于0，则在头部插入节点。</li><li>deleteAtIndex(index)：如果索引 <code>index</code> 有效，则删除链表中的第 <code>index</code> 个节点。</li></ul><h3 id="【解题思路】-1"><a href="#【解题思路】-1" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>在这个问题中，我们将实现一个单链表，其中包含一个哑节点（dummy node）作为辅助节点，以简化在链表头部添加和删除节点的操作。</p><ol><li><strong>初始化</strong>：链表初始化时，创建一个哑节点，哑节点的 <code>next</code> 属性指向 <code>null</code>。维护一个 <code>size</code> 变量来跟踪链表的长度。</li><li><strong>获取节点值</strong>：在获取第 <code>index</code> 个节点的值时，首先检查 <code>index</code> 是否有效（即 <code>0 &lt;= index &lt; size</code>），然后从哑节点开始遍历到第 <code>index</code> 个节点，返回其值。</li><li><strong>在头部添加节点</strong>：创建新节点，将新节点的 <code>next</code> 指向原头节点，哑节点的 <code>next</code> 指向新节点，链表长度 <code>size</code> 加1。</li><li><strong>在尾部添加节点</strong>：遍历到链表的最后一个节点，将其 <code>next</code> 指向新节点，链表长度 <code>size</code> 加1。</li><li><strong>在指定位置添加节点</strong>：首先检查 <code>index</code> 是否有效，如果有效（包括在头部添加和尾部添加的特殊情况），则遍历到指定位置的前一个节点，按照插入逻辑添加新节点。</li><li><strong>删除节点</strong>：如果 <code>index</code> 有效，遍历到指定位置的前一个节点，改变前一个节点的 <code>next</code>，以跳过需要删除的节点。</li></ol><h3 id="【实现代码】-1"><a href="#【实现代码】-1" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val  <span class="type">int</span></span><br><span class="line">    Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyLinkedList <span class="keyword">struct</span> &#123;</span><br><span class="line">    size <span class="type">int</span></span><br><span class="line">    head *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> MyLinkedList &#123;</span><br><span class="line"><span class="comment">//head为dummy节点，方便遍历</span></span><br><span class="line">    <span class="keyword">return</span> MyLinkedList&#123;<span class="number">0</span>, &amp;ListNode&#123;<span class="number">0</span>, <span class="literal">nil</span>&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyLinkedList)</span></span> Get(index <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> index &lt; <span class="number">0</span> || index &gt;= this.size &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    current := this.head</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= index; i++ &#123;</span><br><span class="line">        current = current.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current.Val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyLinkedList)</span></span> AddAtHead(val <span class="type">int</span>) &#123;</span><br><span class="line">    this.AddAtIndex(<span class="number">0</span>, val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyLinkedList)</span></span> AddAtTail(val <span class="type">int</span>) &#123;</span><br><span class="line">    this.AddAtIndex(this.size, val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyLinkedList)</span></span> AddAtIndex(index <span class="type">int</span>, val <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> index &gt; this.size &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> index &lt; <span class="number">0</span> &#123;</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    this.size++</span><br><span class="line">    pred := this.head</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; index; i++ &#123;</span><br><span class="line">        pred = pred.Next</span><br><span class="line">    &#125;</span><br><span class="line">    newNode := &amp;ListNode&#123;val, pred.Next&#125;</span><br><span class="line">    pred.Next = newNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyLinkedList)</span></span> DeleteAtIndex(index <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> index &lt; <span class="number">0</span> || index &gt;= this.size &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    this.size--</span><br><span class="line">    pred := this.head</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; index; i++ &#123;</span><br><span class="line">        pred = pred.Next</span><br><span class="line">    &#125;</span><br><span class="line">    pred.Next = pred.Next.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 代码设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口</title>
      <link href="/2024/04/12/leetcode/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
      <url>/2024/04/12/leetcode/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>滑动窗口算法技巧主要用来解决子数组问题，比如让你寻找符合某个条件的最长/最短子数组</p></blockquote><p>模板代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//window is left close right open [0, 0)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; right &lt; nums.size()) {</span><br><span class="line">    <span class="comment">// 增大窗口</span></span><br><span class="line">    window.add(nums[right]);</span><br><span class="line">    right++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (window needs shrink) {</span><br><span class="line">        <span class="comment">// 缩小窗口</span></span><br><span class="line">        window.remove(nums[left]);</span><br><span class="line">        left++;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3 无重复字符的最长子串"></a>3 无重复字符的最长子串</h2><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。</p><h3 id="【解题思路】"><a href="#【解题思路】" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这次我们使用一个固定大小的整数数组（假设输入字符串只包含ASCII字符，则大小为128或256足够用）来代替<code>HashMap</code>，用于跟踪每个字符最后一次出现的位置。数组的索引对应字符的ASCII码，值对应该字符最后出现的索引位置。我们同样使用两个指针表示子串的左右边界，右指针向右移动扩展窗口，左指针根据需要向右移动以去除重复字符。通过这种方式，我们可以在每次迭代中以常数时间更新窗口的位置，因此整体解法仍然是线性时间复杂度。</p><h3 id="【实现代码】"><a href="#【实现代码】" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> {</span><br><span class="line">l, r, n := <span class="number">0</span>,<span class="number">0</span>,<span class="built_in">len</span>(s)</span><br><span class="line">mp := <span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>{}</span><br><span class="line">res := <span class="number">0</span></span><br><span class="line"><span class="comment">//move to the end</span></span><br><span class="line"><span class="keyword">for</span> r &lt; n {</span><br><span class="line"><span class="comment">// d add to map</span></span><br><span class="line">d := s[r]</span><br><span class="line">mp[d]++</span><br><span class="line"><span class="comment">//right window move</span></span><br><span class="line">r++</span><br><span class="line"><span class="comment">//has repeat char, move left window,until no repeat char</span></span><br><span class="line"><span class="keyword">for</span> mp[d] &gt; <span class="number">1</span> {</span><br><span class="line">f := s[l]</span><br><span class="line">mp[f]--</span><br><span class="line">l++</span><br><span class="line">}</span><br><span class="line">res = max(res, r-l)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76 最小覆盖子串"></a>76 最小覆盖子串</h2><h3 id="【题目描述】-1"><a href="#【题目描述】-1" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你一个字符串<code>s</code>和一个字符集合<code>t</code>，请你返回<code>s</code>中涵盖<code>t</code>所有字符的最小子串。如果<code>s</code>中不存在涵盖<code>t</code>所有字符的子串，则返回空字符串<code>""</code>。</p><p><strong>注意：</strong></p><ul><li>对于<code>t</code>中重复的字符，我们需要在<code>s</code>的子串中找到它们所有的出现。</li><li>如果<code>s</code>中存在这样的子串，我们保证它是唯一的答案。</li></ul><h3 id="【解题思路】-1"><a href="#【解题思路】-1" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题可以通过”滑动窗口”技术来解决。整个过程可以分为”扩展”和”收缩”两个阶段：</p><ol><li><strong>扩展窗口</strong>：移动右指针以扩大窗口，直到窗口包含了<code>t</code>中的所有字符。</li><li><strong>收缩窗口</strong>：当窗口包含了所有<code>t</code>中的字符后，尝试移动左指针以缩小窗口大小，但仍保持窗口包含<code>t</code>中所有字符的前提下，找到最小的覆盖子串。</li><li>在这个过程中，我们记录下每个字符在<code>t</code>中的出现次数，以及当前窗口中的这些字符的出现次数。只有当窗口中的某个字符数量等于或多于<code>t</code>中的数量时，我们才认为该字符被完全覆盖。</li><li>我们还需要记录窗口中已经完全覆盖了<code>t</code>中字符的数量，一旦这个数量等于<code>t</code>的长度，就意味着当前窗口已经完全覆盖了<code>t</code>。</li><li>在整个过程中，我们记录最小覆盖子串的起始位置和长度，以便最后返回结果。</li></ol><h3 id="【实现代码】-1"><a href="#【实现代码】-1" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minWindow</span><span class="params">(s <span class="type">string</span>, t <span class="type">string</span>)</span></span> <span class="type">string</span> {</span><br><span class="line">need := <span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>{}</span><br><span class="line">window := <span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>{}</span><br><span class="line">n := <span class="built_in">len</span>(s)</span><br><span class="line">l, r, minLen, start := <span class="number">0</span>, <span class="number">0</span>, n+<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">valid := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(t); i++ {</span><br><span class="line">need[t[i]]++</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> r &lt; n {</span><br><span class="line"><span class="comment">// move right window</span></span><br><span class="line">c := s[r]</span><br><span class="line">window[c]++</span><br><span class="line">r++</span><br><span class="line"><span class="keyword">if</span> window[c] == need[c] {</span><br><span class="line">valid++</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> valid == <span class="built_in">len</span>(need) {</span><br><span class="line"><span class="comment">// cal minLen, reset start</span></span><br><span class="line"><span class="keyword">if</span> minLen &gt; r-l {</span><br><span class="line">minLen = r - l</span><br><span class="line">start = l</span><br><span class="line">}</span><br><span class="line"><span class="comment">// move left window</span></span><br><span class="line">d := s[l]</span><br><span class="line"><span class="keyword">if</span> window[d] == need[d] {</span><br><span class="line">valid--</span><br><span class="line">}</span><br><span class="line">window[d]--</span><br><span class="line">l++</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> minLen == n+<span class="number">1</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> s[start : start+minLen]</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239 滑动窗口最大值"></a>239 滑动窗口最大值</h2><h3 id="【题目描述】-2"><a href="#【题目描述】-2" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左端移动到数组的最右端。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。返回滑动窗口中的最大值。</p><h3 id="【解题思路】-2"><a href="#【解题思路】-2" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>解决这个问题的关键是如何在每次窗口移动时，有效地找到当前窗口的最大值。一个直观的方法是每次窗口移动时，遍历窗口中的所有元素来找最大值，但这种方法的时间复杂度较高。</p><p>一个更高效的方法是使用双端队列（Deque）来维护窗口内的最大值，使得时间复杂度降低。双端队列能够从两端以常数时间插入或删除元素。</p><p>具体步骤如下：</p><ol><li>使用一个双端队列存储元素的索引，队列中的第一个元素是当前窗口的最大值的索引。</li><li>遍历数组 <code>nums</code>，对于每个元素，做以下操作：<ul><li>首先，移除所有小于当前元素 <code>nums[i]</code> 的元素的索引，因为它们不可能是窗口的最大值。</li><li>然后，如果队列的头部元素（当前最大值的索引）已经不在窗口内（索引小于 <code>i-k+1</code>），就将其从队列中移除。</li><li>将当前元素的索引添加到队列的末尾。</li><li>如果已经遍历到第 <code>k</code> 个元素（<code>i ≥ k-1</code>），将当前窗口的最大值（队列头部元素对应的值）添加到结果数组中。</li></ul></li><li>返回结果数组。<br><img src="https://code-thinking.cdn.bcebos.com/gifs/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-2.gif"></li></ol><h3 id="【实现代码】-2"><a href="#【实现代码】-2" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先，我们需要定义一个双端队列（deque）来存储窗口内的元素下标。队列中的元素按照从大到小的顺序排列，保证队头元素是当前窗口中的最大值。</span></span><br><span class="line"><span class="comment">// 然后，我们遍历整个数组。在遍历过程中，我们需要维护以下规则：</span></span><br><span class="line"><span class="comment">// 如果队列不为空且当前元素大于等于队尾元素，我们将队尾元素出队，直到队列为空或者当前元素小于队尾元素。</span></span><br><span class="line"><span class="comment">// 将当前元素的下标入队。</span></span><br><span class="line"><span class="comment">// 在遍历过程中，我们需要判断当前窗口是否已经形成。如果窗口的左边界大于等于k-1，我们可以将队头元素加入结果数组中。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSlidingWindow</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> []<span class="type">int</span> {</span><br><span class="line">res := []<span class="type">int</span>{}</span><br><span class="line">deque := []<span class="type">int</span>{}</span><br><span class="line"><span class="comment">//找出前卡个元素</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ {</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(deque) &gt; <span class="number">0</span> &amp;&amp; deque[<span class="built_in">len</span>(deque)<span class="number">-1</span>] &lt; nums[i] {</span><br><span class="line">deque = deque[:<span class="built_in">len</span>(deque)<span class="number">-1</span>]</span><br><span class="line">}</span><br><span class="line">deque = <span class="built_in">append</span>(deque, nums[i])</span><br><span class="line">}</span><br><span class="line">res = <span class="built_in">append</span>(res, deque[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j := k; j &lt; <span class="built_in">len</span>(nums); j++ {</span><br><span class="line"><span class="comment">//如果队列的头部元素（当前最大值的索引）已经不在窗口内（索引小于 `i-k+1`），就将其从队列中移除。</span></span><br><span class="line"><span class="keyword">if</span> nums[j-k] == deque[<span class="number">0</span>] {</span><br><span class="line">deque = deque[<span class="number">1</span>:]</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(deque) &gt; <span class="number">0</span> &amp;&amp; deque[<span class="built_in">len</span>(deque)<span class="number">-1</span>] &lt; nums[j] {</span><br><span class="line">deque = deque[:<span class="built_in">len</span>(deque)<span class="number">-1</span>]</span><br><span class="line">}</span><br><span class="line">deque = <span class="built_in">append</span>(deque, nums[j])</span><br><span class="line">res = <span class="built_in">append</span>(res, deque[<span class="number">0</span>])</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209 长度最小的子数组"></a>209 长度最小的子数组</h2><h3 id="【题目描述】-3"><a href="#【题目描述】-3" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>s</code> ，找出该数组中满足其和 ≥ <code>s</code> 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的连续子数组，返回 0。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的连续子数组。</span><br></pre></td></tr></table></figure><h3 id="【解题思路】-3"><a href="#【解题思路】-3" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题可以用双指针或滑动窗口的方法来解决。基本思路是，维护一个窗口的左右指针，开始时都指向数组的起始位置。然后，逐渐扩大窗口（即移动右指针）直到窗口内元素的总和大于等于 <code>s</code> 。此时，尝试缩小窗口（即移动左指针），以找到更小的满足条件的窗口。记录过程中窗口的最小长度。重复这个过程直到右指针到达数组末尾。</p><h3 id="【实现代码】-3"><a href="#【实现代码】-3" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minSubArrayLen</span><span class="params">(target <span class="type">int</span>, nums []<span class="type">int</span>)</span></span> <span class="type">int</span> {</span><br><span class="line">res := math.MaxInt</span><br><span class="line">n := <span class="built_in">len</span>(nums)</span><br><span class="line">l,r := <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> r &lt; n {</span><br><span class="line">sum += nums[r]</span><br><span class="line">r++</span><br><span class="line"><span class="comment">//满足要求后，维护最小值，并左移左窗口</span></span><br><span class="line"><span class="keyword">for</span> sum &gt;= target {</span><br><span class="line">res = min(r-l,res)</span><br><span class="line">sum-=nums[l]</span><br><span class="line">l++</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> res == math.MaxInt {</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a,b <span class="type">int</span>)</span></span><span class="type">int</span> {</span><br><span class="line"><span class="keyword">if</span> a&gt;b {</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567 字符串的排列"></a>567 字符串的排列</h2><h3 id="【题目描述】-4"><a href="#【题目描述】-4" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你两个字符串<code>s1</code>和<code>s2</code>，写一个函数来判断<code>s2</code>是否包含<code>s1</code>的排列。换句话说，第一个字符串的排列之一是第二个字符串的子串。</p><h3 id="【解题思路】-4"><a href="#【解题思路】-4" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题可以通过滑动窗口的方法来解决。整个思路是这样的：</p><ol><li>首先，我们需要统计<code>s1</code>中每个字符出现的次数，因为排列的意思是<code>s1</code>的所有字符在<code>s2</code>的某个子串中都要出现，而且出现的次数相同。</li><li>然后，我们在<code>s2</code>中滑动一个和<code>s1</code>长度相同的窗口，统计窗口内每个字符的出现次数。</li><li>在每次移动窗口时，我们比较窗口内的字符统计与<code>s1</code>的字符统计。如果两者完全相同，那么就意味着当前窗口是<code>s1</code>的一个排列。</li><li>我们继续滑动窗口，直到找到一个符合条件的窗口或者遍历完<code>s2</code>。</li></ol><p>这个方法的关键在于如何高效地比较两个字符统计是否相同，以及如何高效地更新窗口内的字符统计。</p><h3 id="【实现代码】-4"><a href="#【实现代码】-4" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkInclusion</span><span class="params">(s1 <span class="type">string</span>, s2 <span class="type">string</span>)</span></span> <span class="type">bool</span> {</span><br><span class="line">need := <span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>{}</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s1); i++ {</span><br><span class="line">need[s1[i]]++</span><br><span class="line">}</span><br><span class="line">window := <span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>{}</span><br><span class="line">valid := <span class="number">0</span></span><br><span class="line">n := <span class="built_in">len</span>(s2)</span><br><span class="line">l, r := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> r &lt; n {</span><br><span class="line">c := s2[r]</span><br><span class="line">r++</span><br><span class="line">window[c]++</span><br><span class="line"><span class="keyword">if</span> window[c] == need[c] {</span><br><span class="line">valid++</span><br><span class="line">}</span><br><span class="line"><span class="comment">//r-l &gt;= len(s1)的时候收缩窗口</span></span><br><span class="line"><span class="keyword">for</span> r-l &gt;= <span class="built_in">len</span>(s1) {</span><br><span class="line"><span class="keyword">if</span> valid == <span class="built_in">len</span>(need) {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line">d := s2[l]</span><br><span class="line"><span class="keyword">if</span> need[d] == window[d] {</span><br><span class="line">valid--</span><br><span class="line">}</span><br><span class="line">window[d]--</span><br><span class="line">l++</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/2024/04/11/read/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/04/11/read/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="硬件结构"><a href="#硬件结构" class="headerlink" title="硬件结构"></a><a href="https://xiaolincoding.com/os/1_hardware/how_cpu_run.html">硬件结构</a></h1><h2 id="冯洛伊曼模型"><a href="#冯洛伊曼模型" class="headerlink" title="冯洛伊曼模型"></a>冯洛伊曼模型</h2><blockquote><p>运算器、控制器、存储器、输入设备、输出设备</p></blockquote><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Von_Neumann_architecture.svg"></p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>CPU内的寄存器和三级缓存使用的是SRAM(static)，内存条使用的是DRAM(dynamic)<br><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB%E5%9B%BE.png"></p><h3 id="缓存一致性问题"><a href="#缓存一致性问题" class="headerlink" title="缓存一致性问题"></a>缓存一致性问题</h3><p>产生原因：A 号核心和 B 号核心的缓存数据在写入内存时的不一致，会导致执行结果的错误。<br>要解决这个问题，要保证两点：</p><ol><li>某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的 Cache，这个称为<strong>写传播（_Write Propagation_）</strong>；</li><li>某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的，这个称为<strong>事务的串行化（_Transaction Serialization_）</strong>。</li></ol><p>实现方式</p><ol><li><p>总线嗅探（Bus Snooping）<br>我还是以前面的 i 变量例子来说明总线嗅探的工作机制，当 A 号 CPU 核心修改了 L1 Cache 中 i 变量的值，通过总线把这个事件广播通知给其他所有的核心，然后每个 CPU 核心都会监听总线上的广播事件，并检查是否有相同的数据在自己的 L1 Cache 里面，如果 B 号 CPU 核心的 L1 Cache 中有该数据，那么也需要把该数据更新到自己的 L1 Cache。<br>缺点：总线消息繁忙，无法保证事物串行化</p></li><li><p>MESI协议<br>mesi：Modified，exclusive，shared，invalidated<br>我们举个具体的例子来看看这四个状态的转换：</p></li><li><p>当 A 号 CPU 核心从内存读取变量 i 的值，数据被缓存在 A 号 CPU 核心自己的 Cache 里面，此时其他 CPU 核心的 Cache 没有缓存该数据，于是标记 Cache Line 状态为「独占」，此时其 Cache 中的数据与内存是一致的；</p></li><li><p>然后 B 号 CPU 核心也从内存读取了变量 i 的值，此时会发送消息给其他 CPU 核心，由于 A 号 CPU 核心已经缓存了该数据，所以会把数据返回给 B 号 CPU 核心。在这个时候， A 和 B 核心缓存了相同的数据，Cache Line 的状态就会变成「共享」，并且其 Cache 中的数据与内存也是一致的；</p></li><li><p>当 A 号 CPU 核心要修改 Cache 中 i 变量的值，发现数据对应的 Cache Line 的状态是共享状态，则要向所有的其他 CPU 核心广播一个请求，要求先把其他核心的 Cache 中对应的 Cache Line 标记为「无效」状态，然后 A 号 CPU 核心才更新 Cache 里面的数据，同时标记 Cache Line 为「已修改」状态，此时 Cache 中的数据就与内存不一致了。</p></li><li><p>如果 A 号 CPU 核心「继续」修改 Cache 中 i 变量的值，由于此时的 Cache Line 是「已修改」状态，因此不需要给其他 CPU 核心发送消息，直接更新数据即可。</p></li><li><p>如果 A 号 CPU 核心的 Cache 里的 i 变量对应的 Cache Line 要被「替换」，发现 Cache Line 状态是「已修改」状态，就会在替换前先把数据同步到内存。</p></li></ol><h2 id="cpu调度"><a href="#cpu调度" class="headerlink" title="cpu调度"></a>cpu调度</h2><p>在linux中，进程和线程都是用 <code>task_struct</code> 结构体表示的，区别在于线程的 task_struct 结构体里部分资源是共享了进程已创建的资源，比如内存地址空间、代码段、文件描述符等，所以 Linux 中的线程也被称为轻量级进程，因为线程的 task_struct 相比进程的 task_struct 承载的 资源比较少，因此以「轻」得名。<br>CPU调度的是task_struct。也就是所谓的线程是CPU调度的基本单位。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%E4%BC%AA%E5%85%B1%E4%BA%AB/%E8%B0%83%E5%BA%A6%E7%B1%BB.png"></p><ul><li>SCHED_DEADLINE：是按照 deadline 进行调度的，距离当前时间点最近的 deadline 的任务会被优先调度；</li><li>SCHED_FIFO：对于相同优先级的任务，按先来先服务的原则，但是优先级更高的任务，可以抢占低优先级的任务，也就是优先级高的可以「插队」；</li><li>SCHED_RR：对于相同优先级的任务，轮流着运行，每个任务都有一定的时间片，当用完时间片的任务会被放到队列尾部，以保证相同优先级任务的公平性，但是高优先级的任务依然可以抢占低优先级的任务；</li><li>SCHED_NORMAL：普通任务使用的调度策略；</li><li>SCHED_BATCH：后台任务的调度策略，不和终端进行交互，因此在不影响其他需要交互的任务，可以适当降低它的优先级。</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%E4%BC%AA%E5%85%B1%E4%BA%AB/CPU%E9%98%9F%E5%88%97.png"></p><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>在计算机中，中断是系统用来响应硬件设备请求的一种机制，操作系统收到硬件的中断请求，会打断正在执行的进程，然后调用内核中的中断处理程序来响应请求。<br>为了避免由于中断处理程序执行时间过长，而影响正常进程的调度，Linux 将中断处理程序分为上半部和下半部：</p><ul><li>上半部，对应硬中断，由硬件触发中断，用来快速处理中断；</li><li>下半部，对应软中断，由内核触发中断，用来异步处理上半部未完成的工作；</li></ul><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/float.png"></p><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a><a href="https://xiaolincoding.com/os/3_memory/vmem.html">内存管理</a></h1><p>操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来<br>操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存，如下图所示：<br><img src="https://cdn.xiaolincoding.com//mysql/other/72ab76ba697e470b8ceb14d5fc5688d9.png"></p><h2 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h2><p>程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。<br>虚拟地址是通过<strong>段表</strong>与物理地址进行映射的，分段机制会把程序的虚拟地址分成 4 个段，每个段在段表中有一个项，在这一项找到段的基地址，再加上偏移量，于是就能找到物理内存中的地址，如下图：<br><img src="https://cdn.xiaolincoding.com//mysql/other/c5e2ab63e6ee4c8db575f3c7c9c85962.png"></p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li><strong>内存外部碎片</strong>的问题：程序的段被回收后可能会存在外部碎片</li><li><strong>内存交换的效率低</strong>的问题：对外部随便进行整理需要使用物理内存做交换，效率低</li></ol><h2 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h2><p>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫<strong>页</strong>（_Page_）。在 Linux 下，每一页的大小为 <code>4KB</code>。<br>虚拟地址与物理地址之间通过<strong>页表</strong>来映射，如下图：<br><img src="https://cdn.xiaolincoding.com//mysql/other/08a8e315fedc4a858060db5cb4a654af.png"><br>而当进程访问的虚拟地址在页表中查不到时，系统会产生一个<strong>缺页异常</strong>，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。<br><img src="https://cdn.xiaolincoding.com//mysql/other/7884f4d8db4949f7a5bb4bbd0f452609.png"><br>总结一下，对于一个内存地址转换，其实就是这样三个步骤：</p><ul><li>把虚拟内存地址，切分成页号和偏移量；</li><li>根据页号，从页表里面，查询对应的物理页号；</li><li>直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。</li></ul><p>在 32 位的环境下，虚拟地址空间共有 4GB，假设一个页的大小是 4KB（2^12），那么就需要大约 100 万 （2^20） 个页，每个「页表项」需要 4 个字节大小来存储，那么整个 4GB 空间的映射就需要有 <code>4MB</code> 的内存来存储页表。<br>这 4MB 大小的页表，看起来也不是很大。但是要知道每个进程都是有自己的虚拟地址空间的，也就说都有自己的页表。那么，<code>100</code> 个进程的话，就需要 <code>400MB</code> 的内存来存储页表，这是非常大的内存了，更别说 64 位的环境了。为了解决这个问题，使用<strong>多级页表</strong>方案。</p><h3 id="TLB（translation-lookaside-buffer）"><a href="#TLB（translation-lookaside-buffer）" class="headerlink" title="TLB（translation lookaside buffer）"></a>TLB（translation lookaside buffer）</h3><p>mmu的缓存</p><h2 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h2><p>段页式内存管理实现的方式：</p><ul><li>先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；</li><li>接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；<br>这样，地址结构就由<strong>段号、段内页号和页内位移</strong>三部分组成。<br><img src="https://cdn.xiaolincoding.com//mysql/other/8904fb89ae0c49c4b0f2f7b5a0a7b099.png"></li></ul><h2 id="linux内存布局"><a href="#linux内存布局" class="headerlink" title="linux内存布局"></a>linux内存布局</h2><p>虽然每个进程都各自有独立的虚拟内存，但是<strong>每个虚拟内存中的内核地址，其实关联的都是相同的物理内存</strong>。这样，进程切换到内核态后，就可以很方便地访问内核空间内存。<br><img src="https://cdn.xiaolincoding.com//mysql/other/48403193b7354e618bf336892886bcff.png"><br><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/32%E4%BD%8D%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png"></p><p>通过这张图你可以看到，用户空间内存，从<strong>低到高</strong>分别是 6 种不同的内存段：</p><ul><li>代码段，包括二进制可执行代码；</li><li>数据段，包括已初始化的静态常量和全局变量；</li><li>BSS 段，包括未初始化的静态变量和全局变量；</li><li>堆段，包括动态分配的内存，从低地址开始向上增长；</li><li>文件映射段，包括动态库、共享内存等，从低地址开始向上增长（<a href="http://lishiwen4.github.io/linux/linux-process-memory-location">跟硬件和内核版本有关 (opens new window)</a>）；</li><li>栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 <code>8 MB</code>。当然系统也提供了参数，以便我们自定义大小；</li></ul><h2 id="在4G的物理内存下申请8G的内存会有什么后果"><a href="#在4G的物理内存下申请8G的内存会有什么后果" class="headerlink" title="在4G的物理内存下申请8G的内存会有什么后果"></a>在4G的物理内存下申请8G的内存会有什么后果</h2><ol><li>如果是32位的操作系统，最大只能索引4G的内存，所以超过4G会报错</li><li>如果是64位的操作系统，如果overcommit_memory配置的是1，进程可以使用128T的虚拟内存，申请了如果使用超过了物理内存，如果没有开始swap，可能会出现oom报错，如果开启了swap则使用也没问题。</li></ol><h2 id="预读失效"><a href="#预读失效" class="headerlink" title="预读失效"></a><a href="https://xiaolincoding.com/os/3_memory/cache_lru.html#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E9%A2%84%E8%AF%BB%E5%A4%B1%E6%95%88%E9%80%A0%E6%88%90%E7%9A%84%E5%BD%B1%E5%93%8D">预读失效</a></h2><p>Linux 操作系统为基于 Page Cache 的读缓存机制提供<strong>预读机制</strong>，如果<strong>这些被提前加载进来的页，并没有被访问</strong>，相当于这个预读工作是白做了，这个就是<strong>预读失效</strong>。<br>解决方法： <strong>都是将数据分为了冷数据和热数据，然后分别进行 LRU 算法</strong></p><h3 id="linux解决预读失效问题"><a href="#linux解决预读失效问题" class="headerlink" title="linux解决预读失效问题"></a>linux解决预读失效问题</h3><p>Linux 操作系统实现两个了 LRU 链表：<strong>活跃 LRU 链表（active_list）和非活跃 LRU 链表（inactive_list）</strong>。</p><ul><li><strong>active list</strong> 活跃内存页链表，这里存放的是最近被访问过（活跃）的内存页；</li><li><strong>inactive list</strong> 不活跃内存页链表，这里存放的是很少被访问（非活跃）的内存页；<br>有了这两个 LRU 链表后，<strong>预读页就只需要加入到 inactive list 区域的头部，当页被真正访问的时候，才将页插入 active list 的头部</strong>。如果预读的页一直没有被访问，就会从 inactive list 移除，这样就不会影响 active list 中的热点数据。</li></ul><h3 id="mysql解决预读失效问题"><a href="#mysql解决预读失效问题" class="headerlink" title="mysql解决预读失效问题"></a>mysql解决预读失效问题</h3><p>MySQL 的 Innodb 存储引擎是在一个 LRU 链表上划分来 2 个区域，<strong>young 区域 和 old 区域</strong>。比例大概是70：30<br>young 区域在 LRU 链表的前半部分，old 区域则是在后半部分，这两个区域都有各自的头和尾节点，如下图：<br><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/young%2Bold.png"><br><strong>划分这两个区域后，预读的页就只需要加入到 old 区域的头部，当页被真正访问的时候，才将页插入 young 区域的头部</strong>。如果预读的页一直没有被访问，就会从 old 区域移除，这样就不会影响 young 区域中的热点数据。</p><h2 id="缓存污染"><a href="#缓存污染" class="headerlink" title="缓存污染"></a>缓存污染</h2><p>即使存在缓存两个lru链表能解决预读的问题，但是如果缓存被访问了还是会放倒activlist，造成缓存污染。<br>为了解决这个问题，需要加大进入到activelist的门槛。<br>mysql和linux的解决方案是一样的，只要在第二次被访问时才会加入到activelist，且时间间隔要大于1s。</p><h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><p>通常会说进程是操作系统资源分配的基本单位，线程是cpu调度的基本单位。<br>进程和线程在操作系统里都是task_struct，他是PCB（process control block）的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">        <span class="comment">// 进程id</span></span><br><span class="line">    <span class="type">pid_t</span>pid;</span><br><span class="line">        <span class="comment">// 用于标识线程所属的进程 pid</span></span><br><span class="line">    <span class="type">pid_t</span>tgid;</span><br><span class="line">        <span class="comment">// 进程打开的文件信息</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span>*<span class="title">files</span>;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 内存描述符表示进程虚拟地址空间</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span>*<span class="title">mm</span>;</span></span><br><span class="line"></span><br><span class="line">        .......... 省略 .......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> task_size;    <span class="comment">/* size of task vm space */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_code, end_code, start_data, end_data;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_brk, brk, start_stack;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> arg_start, arg_end, env_start, env_end;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> mmap_base;  <span class="comment">/* base of mmap area */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> total_vm;    <span class="comment">/* Total pages mapped */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> locked_vm;  <span class="comment">/* Pages that have PG_mlocked set */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> pinned_vm;  <span class="comment">/* Refcount permanently increased */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> data_vm;    <span class="comment">/* VM_WRITE &amp; ~VM_SHARED &amp; ~VM_STACK */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> exec_vm;    <span class="comment">/* VM_EXEC &amp; ~VM_WRITE &amp; ~VM_STACK */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_vm;    <span class="comment">/* VM_STACK */</span></span><br><span class="line">       ...... 省略 ........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子进程共享了父进程的虚拟内存空间，这样子进程就变成了我们熟悉的线程，<strong>是否共享地址空间</strong>几乎是进程和线程之间的本质区别。Linux 内核并不区别对待它们，线程对于内核来说仅仅是一个共享特定资源的进程而已。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/2b2dbb2b6ea19871152a3bf6566df205.png"><br><img src="https://cdn.xiaolincoding.com//mysql/other/d1e65b91b67422c2cc08a04549c5f3ba.png"></p><h2 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h2><p>通过就绪队列和阻塞队列管理<br><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/12-PCB%E7%8A%B6%E6%80%81%E9%93%BE%E8%A1%A8%E7%BB%84%E7%BB%87.jpg"></p><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><h4 id="CPU上下文切换"><a href="#CPU上下文切换" class="headerlink" title="CPU上下文切换"></a>CPU上下文切换</h4><p>将CPU寄存器的内容和程序计数器保存在task_struct中</p><h4 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h4><p>进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。</p><h4 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h4><p>同一进程的线程上下文切换只需要切换线程的基本信息（栈和寄存器等私有数据）</p><h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><h3 id="调度原则"><a href="#调度原则" class="headerlink" title="调度原则"></a>调度原则</h3><ul><li><strong>CPU 利用率</strong>：调度程序应确保 CPU 是始终匆忙的状态，这可提高 CPU 的利用率；</li><li><strong>系统吞吐量</strong>：吞吐量表示的是单位时间内 CPU 完成进程的数量，长作业的进程会占用较长的 CPU 资源，因此会降低吞吐量，相反，短作业的进程会提升系统吞吐量；</li><li><strong>周转时间</strong>：周转时间是进程运行+阻塞时间+等待时间的总和，一个进程的周转时间越小越好；</li><li><strong>等待时间</strong>：这个等待时间不是阻塞状态的时间，而是进程处于就绪队列的时间，等待的时间越长，用户越不满意；</li><li><strong>响应时间</strong>：用户提交请求到系统第一次产生响应所花费的时间，在交互式系统中，响应时间是衡量调度算法好坏的主要标准。</li></ul><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><ul><li>先来先服务调度算法 FCFS</li><li>最短作业优先调度算法 short job first SJF</li><li> 高响应比优先调度算法 Highest Response Ratio Next, HRRN ：要是权衡了短作业和长作业，实现不了</li><li>时间片轮转调度算法 Round Robin, RR</li><li> 最高优先级调度算法 Highest Priority First，HPF</li><li>多级反馈队列调度算法 Multilevel Feedback Queue </li><li>「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。</li><li>「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列；</li></ul><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>所谓的管道，就是内核里面的一串缓存。管道工作在半双工模式下，数据只能单向流动。同时通信数据都遵循<strong>先进先出</strong>原则。管道效率低，不适合频繁的交换数据。</p><table><thead><tr><th>特性</th><th>匿名管道</th><th>命名管道</th></tr></thead><tbody><tr><td>创建方式</td><td>通过<code>pipe()</code>系统调用创建<code>ps aux |grep mysql</code></td><td>通过<code>mkfifo()</code>系统调用或<code>mknod()</code>命令创建</td></tr><tr><td>生命周期</td><td>仅在创建它的进程及其子进程中可见，结束时自动销毁</td><td>存在于文件系统中，必须显式删除，否则会一直存在</td></tr><tr><td>使用场景</td><td>通常用于有父子或兄弟关系的进程之间的通信</td><td>可用于任意两个希望通信的进程之间，即使它们没有父子或兄弟关系</td></tr><tr><td>地址空间</td><td>匿名管道不需要一个文件名，因此不在文件系统中有一个可见的入口</td><td>命名管道在文件系统中有一个路径名，可以像普通文件那样通过路径名访问</td></tr><tr><td>连接方式</td><td>通常通过进程创建时继承的文件描述符进行连接</td><td>通过打开文件系统中的特定路径名进行连接</td></tr><tr><td>数据传输方向</td><td>单向传输</td><td>单向传输</td></tr><tr><td>同步&#x2F;阻塞</td><td>支持同步和阻塞机制</td><td>支持同步和阻塞机制</td></tr></tbody></table><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p><strong>消息队列是保存在内核中的消息链表</strong>，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块。<br>缺点：</p><ol><li>不适合大数据量的数据传输，有单个消息大小限制MSGMAX，总消息大小限制MSGMNB</li><li>消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销</li></ol><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中。<br>没有从内核态到用户态数据拷贝的开销<br><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/9-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98.jpg"></p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>用了共享内存通信方式，带来新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。<br>为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，<strong>信号量</strong>就实现了这一保护机制。<br>信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据。<br>信号量表示资源的数量，控制信号量的方式有两种原子操作：</p><ul><li>一个是 <strong>P 操作</strong>，这个操作会把信号量减去 1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 &gt;&#x3D; 0，则表明还有资源可使用，进程可正常继续执行。</li><li>另一个是 <strong>V 操作</strong>，这个操作会把信号量加上 1，相加后如果信号量 &lt;&#x3D; 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</li></ul><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>上面说的进程间通信，都是常规状态下的工作模式。<strong>对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[work@bddwd-ps-beehive-agent189619.bddwd.baidu.com ads]$kill -l</span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL</span><br><span class="line"> 5) SIGTRAP      6) SIGABRT      7) SIGBUS       8) SIGFPE</span><br><span class="line"> 9) SIGKILL     10) SIGUSR1     11) SIGSEGV     12) SIGUSR2</span><br><span class="line">13) SIGPIPE     14) SIGALRM     15) SIGTERM     17) SIGCHLD</span><br><span class="line">18) SIGCONT     19) SIGSTOP     20) SIGTSTP     21) SIGTTIN</span><br><span class="line">22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO</span><br><span class="line">30) SIGPWR      31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1</span><br><span class="line">36) SIGRTMIN+2  37) SIGRTMIN+3  38) SIGRTMIN+4  39) SIGRTMIN+5</span><br><span class="line">40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8  43) SIGRTMIN+9</span><br><span class="line">44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13</span><br><span class="line">52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9</span><br><span class="line">56) SIGRTMAX-8  57) SIGRTMAX-7  58) SIGRTMAX-6  59) SIGRTMAX-5</span><br><span class="line">60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2  63) SIGRTMAX-1</span><br><span class="line">64) SIGRTMAX</span><br></pre></td></tr></table></figure><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想<strong>跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。</strong></p><h2 id="竞争与协作"><a href="#竞争与协作" class="headerlink" title="竞争与协作"></a>竞争与协作</h2><p>同步：并发进程&#x2F;线程在一些关键点上可能需要互相等待与互通消息，这种相互制约的等待与互通信息称为进程&#x2F;线程同步<br>互斥：保证一个线程在临界区执行时，其他线程应该被阻止进入临界区。<br>实现方式：锁，信号量</p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>锁的实现不同，可以分为「忙等待锁」和「无忙等待锁」</p><h4 id="忙等待锁-自旋锁"><a href="#忙等待锁-自旋锁" class="headerlink" title="忙等待锁(自旋锁)"></a>忙等待锁(自旋锁)</h4><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/13-TestAndSet.jpg"></p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/14-%E8%87%AA%E6%97%8B%E9%94%81.jpg"></p><h4 id="无等待锁"><a href="#无等待锁" class="headerlink" title="无等待锁"></a>无等待锁</h4><p>为了防止等待，将线程挂起<br><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/15-%E6%97%A0%E7%AD%89%E5%BE%85%E9%94%81.jpg"></p><h3 id="信号量-1"><a href="#信号量-1" class="headerlink" title="信号量"></a>信号量</h3><p>信号量是操作系统提供的一种协调共享资源访问的方法。<br>通常<strong>信号量表示资源的数量</strong>，对应的变量是一个整型（<code>sem</code>）变量。<br>另外，还有<strong>两个原子操作的系统调用函数来控制信号量的</strong>，分别是：</p><ul><li>_P 操作_：将 <code>sem</code> 减 <code>1</code>，相减后，如果 <code>sem &lt; 0</code>，则进程&#x2F;线程进入阻塞等待，否则继续，表明 P 操作可能会阻塞；</li><li>_V 操作_：将 <code>sem</code> 加 <code>1</code>，相加后，如果 <code>sem &lt;= 0</code>，唤醒一个等待中的进程&#x2F;线程，表明 V 操作不会阻塞；<br><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/17-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FPV%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0.jpg"></li></ul><h3 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h3><p>解决方案一：加锁，每次只能有一个人进餐<br><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/26-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90-%E6%96%B9%E6%A1%88%E4%BA%8C%E7%A4%BA%E4%BE%8B.jpg"><br>解决方案二：改变哲学家拿筷子的顺序，即让偶数编号的哲学家「先拿左边的叉子后拿右边的叉子」，奇数编号的哲学家「先拿右边的叉子后拿左边的叉子」。每次只能有一个人进餐。<br><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/28-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90-%E6%96%B9%E6%A1%88%E4%B8%89%E7%A4%BA%E4%BE%8B.jpg"></p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>当<strong>两个</strong>线程为了保护<strong>两个</strong>不同的共享资源而使用了两个互斥锁，那么这两个互斥锁应用不当的时候，可能会造成两个线程都在等待对方释放锁，在没有外力的作用下，这些线程会一直相互等待，就没办法继续运行，这种情况就是发生了<strong>死锁</strong><br>死锁只有<strong>同时满足</strong>以下四个条件才会发生：</p><ul><li>互斥条件：多个线程不能同时使用同一资源；</li><li>持有并等待条件：持有A，想持有B，而B由于互斥不可持有，则等待；</li><li>不可剥夺条件：已获得的资源在使用完前不能被其他线程剥夺；</li><li>环路等待条件：两个线程获取资源的顺序构成了环形链；</li></ul><p>避免死锁<br>那么避免死锁问题就只需要破环其中一个条件就可以，最常见的并且可行的就是<strong>使用资源有序分配法，来破环环路等待条件</strong>。<br>线程 A 和 线程 B 获取资源的顺序要一样，当线程 A 是先尝试获取资源 A，然后尝试获取资源 B 的时候，线程 B 同样也是先尝试获取资源 A，然后尝试获取资源 B。也就是说，线程 A 和 线程 B 总是以相同的顺序申请自己想要的资源。</p><h1 id="内存页面置换算法"><a href="#内存页面置换算法" class="headerlink" title="内存页面置换算法"></a><a href="https://xiaolincoding.com/os/5_schedule/schedule.html#%E5%86%85%E5%AD%98%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95">内存页面置换算法</a></h1><ul><li>最佳页面置换算法：置换在「未来」最长时间不访问的页面，实现不了</li><li>FIFO</li><li>LRU</li><li>LFU</li><li>时钟页面置换算法<ul><li>当发生缺页中断时，算法首先检查表针指向的页面</li><li>如果它的访问位位是 0 就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置；</li><li>如果访问位是 1 就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0 的页面为止；</li></ul></li></ul><h1 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a><a href="https://xiaolincoding.com/os/5_schedule/schedule.html#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">磁盘调度算法</a></h1><ul><li>FCFS（first come first service）</li><li>最短寻道优先(may hungry)</li><li>scan : 磁头在一个方向上移动，访问所有未完成的请求，直到磁头到达该方向上的最后的磁道，才调换方向，这就是扫描（_Scan_）算法</li><li>cscan : 只有磁头朝某个特定方向移动时，才处理磁道访问请求，而返回时直接快速移动至最靠边缘的磁道，也就是复位磁头，这个过程是很快的，并且<strong>返回中途不处理任何请求</strong>，该算法的特点，就是<strong>磁道只响应一个方向上的请求</strong></li><li>look clook: 我们前面说到的扫描算法和循环扫描算法，都是磁头移动到磁盘「最始端或最末端」才开始调换方向。那这其实是可以优化的，优化的思路就是<strong>磁头在移动到「最远的请求」位置，然后立即反向移动。</strong></li></ul><h1 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h1><p>传统的读写流程<br><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/%E4%BC%A0%E7%BB%9F%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93.png"><br>一次读+写总共有四次用户态与内核态上下文切换，四次内存拷贝<br>为了减少切换和拷贝开销，有两种零拷贝技术</p><ul><li>mmap + write</li><li>sendfile</li></ul><h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><p><code>mmap()</code> 系统调用函数会直接把内核缓冲区里的数据「<strong>映射</strong>」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。<br><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/mmap%20%2B%20write%20%E9%9B%B6%E6%8B%B7%E8%B4%9D.png"></p><h2 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h2><p>该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendfile</span><span class="params">(<span class="type">int</span> out_fd, <span class="type">int</span> in_fd, <span class="type">off_t</span> *offset, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/senfile-3%E6%AC%A1%E6%8B%B7%E8%B4%9D.png"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 八股 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka</title>
      <link href="/2024/04/10/read/kafka/"/>
      <url>/2024/04/10/read/kafka/</url>
      
        <content type="html"><![CDATA[<h4>kafka是消息引擎系统, 也是一个分布式流处理平台</h4><h5>kafka的消息是二进制的字节序列</h5><h5>传输模型</h5>- 点对点型- 发布订阅模型##### 意义: 流量削峰<h4 id="发布订阅的对象是主题-Topic-生产者和消费者交互的介质"><a href="#发布订阅的对象是主题-Topic-生产者和消费者交互的介质" class="headerlink" title="发布订阅的对象是主题(Topic), 生产者和消费者交互的介质"></a>发布订阅的对象是主题(Topic), 生产者和消费者交互的介质</h4><h4 id="服务端-Broker"><a href="#服务端-Broker" class="headerlink" title="服务端(Broker)"></a>服务端(Broker)</h4><p>[生产者] -&gt; [broker [topic]] &lt;- [消费者]</p><h3 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h3><ul><li>主题层: 每个主题可以配置M个分区, 每个分区可以配置N个副本</li><li>分区层: 每个分区的N个副本只有一个leader, 其他的都是follower(分区的作用是负载均衡, 副本是用作冗余)</li><li>消息层: 分区中的若干条消息, 位移从0开始, 一次递增</li><li>最后, 客户端只鞥与分区的领导者交互</li></ul><h3 id="工作流程和存储机制"><a href="#工作流程和存储机制" class="headerlink" title="工作流程和存储机制"></a>工作流程和存储机制</h3><ul><li>消息是面向topic的, topic是逻辑上的概念, partion(每个partition分为多个segment, 每个segment包含.index和.log文件)对应的是物理上的概念, 对应一个log文件, 生产的数据追加到log文件的末端, 每条消息都要自己的offset, 消费者消费时会记录自己消费到哪个offset, 以便出错时能从该位置恢复</li></ul><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p>同一主题下的message可能会分到多个不同的分区, 多个消费者在消费的时候对于有先后消费顺序的message可能会出问题(区内有序), 需要自定义分区策略</p><h3 id="消息压缩"><a href="#消息压缩" class="headerlink" title="消息压缩"></a>消息压缩</h3><p>通常做法是 producer端压缩, broker端保存, consumer端解压缩</p><h3 id="数据丢失-ISR-备选举的同步副本"><a href="#数据丢失-ISR-备选举的同步副本" class="headerlink" title="数据丢失 (ISR 备选举的同步副本)"></a>数据丢失 (ISR 备选举的同步副本)</h3><ul><li>producer端, 只调用send, 没有指定callback, 这种情况可能会网络抖动等各种特殊的因素导致数据丢失而不自知</li><li>consumer端, 先更新offset再去消费可能会导致消费数据丢失</li></ul><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li>不要使用producer.send(msg)，而要使用producer.send(msg, callback)</li><li>设置acks &#x3D; all。acks是Producer的一个参数，代表了你对“已提交”消息的定义。如果设置成all，则表明所有副本Broker都要接收到消息，该消息才算是“已提交”。这是最高等级的“已提交”定义(0:不需要broker去人，1：收到broker确认)</li><li>设置retries为一个较大的值。这里的retries同样是Producer的参数，对应前面提到Producer自动重试</li><li>in-sync-replica set (ISR) 和leader保持同步的follower集合, 当Isr中的follower完成数据同步后, leader就会给follower发送ack, 如果follower长时间未向leader同步数据, 就会被踢出isr</li><li>设置min.insync.replicas &gt; 1。这依然是Broker端参数，控制的是消息至少要被写入到多少个副本才算是“已提交”</li><li>设置unclean.leader.election.enable &#x3D; false 防止自动选举</li><li>设置replication.factor &gt;&#x3D; 3 这也是Broker端的参数。其实这里想表述的是，最好将消息多保存几份，毕竟目前防止消息丢失的主要机制就是冗余</li><li>确保replication.factor &gt; min.insync.replicas</li><li>确保消息消费完成再提交。Consumer端有个参数enable.auto.commit，最好把它设置成false，并采用手<br>动提交位移的方式</li></ul><h3 id="消息幂等"><a href="#消息幂等" class="headerlink" title="消息幂等"></a>消息幂等</h3><blockquote><p>props.put(“enable.idempotence”, ture)， r只能保证单分区、单会话上的消息幂等性</p></blockquote><blockquote><p>而事务<br>能够保证跨分区、跨会话间的幂等性</p></blockquote><h3 id="消费者组"><a href="#消费者组" class="headerlink" title="消费者组"></a>消费者组</h3><blockquote><p>消费者组有一个或多个消费者组成, 有一个相同的group_id, group_id全局唯一</p></blockquote><blockquote><p>组里的每个消费者只能消费者只能消费固定的分区</p></blockquote><h4 id="reblance"><a href="#reblance" class="headerlink" title="reblance"></a>reblance</h4><blockquote><p>reblance是让消费者组里的消费者就如何消费分区数据达成共识, 里面有个coordinator作为协调者, 消费者的消费数据放在coordinator所在broker主题的分区中, rebance期间, consumer会停止消费</p></blockquote><h5 id="减少不必要的reblance"><a href="#减少不必要的reblance" class="headerlink" title="减少不必要的reblance"></a>减少不必要的reblance</h5><p>reblance发生的时机</p><ul><li>组成员数发生变化</li><li>订阅主题数发生变化</li><li>主题的分区数发生变化</li></ul><p>可以减少的时机</p><ul><li>被动退出(未及时发送心跳, 导致coordinator以为消费者已下线)<ol><li>session.timeout.ms 与coordinator交互间隔的最长时间</li><li>heartbeat.interval.ms心跳间隔时间</li><li>max.poll.interval.ms consumer两次poll的最大时间间隔</li></ol></li></ul><p>kafka高效原因</p><ol><li>顺序写磁盘</li><li>领拷贝技术</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 八股 </tag>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx</title>
      <link href="/2024/04/10/read/Nginx/"/>
      <url>/2024/04/10/read/Nginx/</url>
      
        <content type="html"><![CDATA[<h3 id="Nginx应用场景？"><a href="#Nginx应用场景？" class="headerlink" title="Nginx应用场景？"></a>Nginx应用场景？</h3><ol><li>http服务器。Nginx是一个http服务可以独立提供http服务。可以做网页静态服务器。</li><li>虚拟主机。可以实现在一台服务器虚拟出多个网站，例如个人网站使用的虚拟机。</li><li>反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会应为某台服务器负载高宕机而某台服务器闲置的情况。</li></ol><h3 id="Nginx配置文件nginx-conf有哪些属性模块"><a href="#Nginx配置文件nginx-conf有哪些属性模块" class="headerlink" title="Nginx配置文件nginx.conf有哪些属性模块?"></a>Nginx配置文件nginx.conf有哪些属性模块?</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>；                <span class="comment"># worker进程的数量</span></span><br><span class="line">events &#123;                              <span class="comment"># 事件区块开始</span></span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>；          <span class="comment"># 每个worker进程支持的最大连接数</span></span><br><span class="line">&#125;                               <span class="comment"># 事件区块结束</span></span><br><span class="line">http &#123;                           <span class="comment"># HTTP区块开始</span></span><br><span class="line">    <span class="attribute">include</span>       mime.types；         <span class="comment"># Nginx支持的媒体类型库文件</span></span><br><span class="line">    default_type  application/octet-stream；            <span class="comment"># 默认的媒体类型</span></span><br><span class="line">    sendfile        <span class="literal">on</span>；       <span class="comment"># 开启高效传输模式</span></span><br><span class="line">    keepalive_timeout  <span class="number">65</span>；       <span class="comment"># 连接超时</span></span><br><span class="line">    server &#123;                            <span class="comment"># 第一个Server区块开始，表示一个独立的虚拟主机站点</span></span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>；              <span class="comment"># 提供服务的端口，默认80</span></span><br><span class="line">        server_name  localhost；    <span class="comment"># 提供服务的域名主机名</span></span><br><span class="line">        location / &#123;                    <span class="comment"># 第一个location区块开始</span></span><br><span class="line">            <span class="attribute">root</span>   html；       <span class="comment"># 站点的根目录，相当于Nginx的安装目录</span></span><br><span class="line">            index  index.html index.htm；       <span class="comment"># 默认的首页文件，多个用空格分开</span></span><br><span class="line">        &#125;                  <span class="comment"># 第一个location区块结果</span></span><br><span class="line">        error_page   <span class="number">500502503504</span>  /50x.html；          <span class="comment"># 出现对应的http状态码时，使用50x.html回应客户</span></span><br><span class="line">        location = /50x.html &#123;                  <span class="comment"># location区块开始，访问50x.html</span></span><br><span class="line">            <span class="attribute">root</span>   html；                    <span class="comment"># 指定对应的站点目录为html</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><h3 id="location的作用是什么？"><a href="#location的作用是什么？" class="headerlink" title="location的作用是什么？"></a>location的作用是什么？</h3><ul><li>location指令的作用是根据用户请求的URI来执行不同的应用，也就是根据用户请求的网站URL进行匹配，匹配成功即进行相关的操作。</li></ul><table><thead><tr><th>匹配符</th><th>匹配规则</th><th>优先级</th></tr></thead><tbody><tr><td>&#x3D;</td><td>精确匹配</td><td>1</td></tr><tr><td>^~</td><td>以某个字符串开头</td><td>2</td></tr><tr><td>~</td><td>区分大小写的正则匹配</td><td>3</td></tr><tr><td>~*</td><td>不区分大小写的正则匹配</td><td>4</td></tr><tr><td>!~</td><td>区分大小写不匹配的正则</td><td>5</td></tr><tr><td>!~*</td><td>不区分大小写不匹配的正则</td><td>6</td></tr><tr><td>&#x2F;</td><td>通用匹配，任何请求都会匹配到</td><td>7</td></tr></tbody></table><h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><p>限流有3种<br>正常限制访问频率（正常流量）</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义限流维度，一个用户一分钟一个请求进来，多余的全部漏掉</span></span><br><span class="line"><span class="comment">#zone=one 限流名称</span></span><br><span class="line"><span class="comment"># 10m 分配的内存</span></span><br><span class="line"><span class="comment"># rete 速率</span></span><br><span class="line"><span class="attribute">limit_req_zone</span> <span class="variable">$binary_remote_addr</span> zone=one:<span class="number">10m</span> rate=1r/m;</span><br><span class="line"></span><br><span class="line"><span class="comment">#绑定限流维度</span></span><br><span class="line">server&#123;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span>/seckill.html&#123;</span><br><span class="line"><span class="attribute">limit_req</span> zone=zone;</span><br><span class="line"><span class="attribute">proxy_pass</span> http://lj_seckill;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>突发限制访问频率（突发流量）</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义限流维度，一个用户一分钟一个请求进来，多余的全部漏掉</span></span><br><span class="line"><span class="attribute">limit_req_zone</span> <span class="variable">$binary_remote_addr</span> zone=one:<span class="number">10m</span> rate=1r/m;</span><br><span class="line"></span><br><span class="line"><span class="comment">#绑定限流维度</span></span><br><span class="line">server&#123;</span><br><span class="line"><span class="section">location</span>/seckill.html&#123;</span><br><span class="line"><span class="comment">#burst 参数定义了一个“突发”队列的大小。当请求的处理速率超过定义的限制时，多余的请求会被放入这个队列中等待处理。在这个例子中，队列的大小是 5，这意味着在达到限制速率后，还可以额外处理 5 个请求，但这些请求会被“突发”处理，而不是按照正常的速率处理。</span></span><br><span class="line"><span class="comment">#nodelay: 如果没有设置 nodelay，当请求达到限制速率并且突发队列已满时，新的请求会被延迟处理，直到队列中有空间。但是，当设置了 nodelay 参数后，Nginx 会立即返回 503 Service Temporarily Unavailable 错误</span></span><br><span class="line"><span class="attribute">limit_req</span> zone=zone burst=<span class="number">5</span> nodelay;</span><br><span class="line"><span class="attribute">proxy_pass</span> http://lj_seckill;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>限制并发连接数</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line"><span class="attribute">limit_conn_zone</span> <span class="variable">$binary_remote_addr</span> zone=myip:<span class="number">10m</span>;</span><br><span class="line"><span class="attribute">limit_conn_zone</span> <span class="variable">$server_name</span> zone=myServerName:<span class="number">10m</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line"><span class="comment"># 单ip限制10并发，单虚拟server100并发</span></span><br><span class="line"><span class="attribute">limit_conn</span> myip <span class="number">10</span>;</span><br><span class="line"><span class="attribute">limit_conn</span> myServerName <span class="number">100</span>;</span><br><span class="line"><span class="attribute">rewrite</span> / http://www.lijie.net <span class="literal">permanent</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Nginx负载均衡的算法怎么实现的-策略有哪些"><a href="#Nginx负载均衡的算法怎么实现的-策略有哪些" class="headerlink" title="Nginx负载均衡的算法怎么实现的?策略有哪些?"></a>Nginx负载均衡的算法怎么实现的?策略有哪些?</h3><ul><li>轮训</li><li>加权轮询</li><li>ip_hash</li><li>least_conn</li></ul><h2 id="reload的真相-热部署"><a href="#reload的真相-热部署" class="headerlink" title="reload的真相(热部署)"></a>reload的真相(热部署)</h2><p>reload -&gt; SIGHUP</p><ol><li>test config</li><li>master 打开新的监听端口</li><li>用新的config启动新的主进程</li><li>向老的work进程发送QUIT信号</li><li>老的work关闭监听句柄<br>为什么在新启动主进程时不会报端口冲突，是由于操作系统的端口共享支持，设置SO_REUSEPORT，SO_REUSEADDR</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 八股 </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2024/04/09/leetcode/%E6%95%B0%E7%BB%84/"/>
      <url>/2024/04/09/leetcode/%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>如果定义的区间是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="11.054ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4885.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(278,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(576,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(1042,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mi" transform="translate(1592,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="mo" transform="translate(1953,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(2397.7,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(2848.7,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(3193.7,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(3670.7,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mi" transform="translate(4246.7,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="mo" transform="translate(4607.7,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g></svg></mjx-container>， 则终止条件是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="13.567ex" height="2.059ex" role="img" focusable="false" viewbox="0 -705 5996.6 910"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(298,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(764,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mi" transform="translate(1314,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="mo" transform="translate(1952.8,0)"><g data-mml-node="text"><path data-c="3C" d="M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z"/></g><g data-mml-node="text" transform="translate(778,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g></g><g data-mml-node="mi" transform="translate(3786.6,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(4237.6,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(4582.6,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(5059.6,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mi" transform="translate(5635.6,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g></g></g></svg></mjx-container><br>如果定义的区间是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="11.305ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4996.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(278,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(576,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(1042,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mi" transform="translate(1592,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="mo" transform="translate(1953,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(2397.7,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(2848.7,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(3193.7,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(3670.7,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mi" transform="translate(4246.7,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="mo" transform="translate(4607.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>， 则终止条件是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="11.807ex" height="2.059ex" role="img" focusable="false" viewbox="0 -705 5218.6 910"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(298,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(764,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mi" transform="translate(1314,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="mo" transform="translate(1952.8,0)"><path data-c="3C" d="M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z"/></g><g data-mml-node="mi" transform="translate(3008.6,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(3459.6,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(3804.6,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(4281.6,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mi" transform="translate(4857.6,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g></g></g></svg></mjx-container>，因为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="13.567ex" height="2.059ex" role="img" focusable="false" viewbox="0 -705 5996.6 910"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(298,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(764,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mi" transform="translate(1314,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="mo" transform="translate(1952.8,0)"><g data-mml-node="text"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="text" transform="translate(778,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g></g><g data-mml-node="mi" transform="translate(3786.6,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(4237.6,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(4582.6,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(5059.6,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mi" transform="translate(5635.6,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g></g></g></svg></mjx-container>是没有意义的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> {</span><br><span class="line">n := <span class="built_in">len</span>(nums)</span><br><span class="line">l,r := <span class="number">0</span>,n<span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> l&lt;=r {</span><br><span class="line">m := l + (r-l)&gt;&gt;<span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> nums[m] == target {</span><br><span class="line"><span class="keyword">return</span> m</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> nums[m] &gt; target {</span><br><span class="line">r = m<span class="number">-1</span></span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">l = m+<span class="number">1</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41 缺失的第一个正数"></a>41 缺失的第一个正数</h2><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你一个未排序的整数数组 <code>nums</code>，请你找出其中没有出现的最小的正整数。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,0]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,4,-1,1]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [7,8,9,11,12]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5 * 10^5</code></li><li><code>-2^31 &lt;= nums[i] &lt;= 2^31 - 1</code></li></ul><h3 id="【解题思路】"><a href="#【解题思路】" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>为了找到缺失的最小正数，我们可以采用原地哈希的方法。这个思路基于这样一个事实：长度为 <code>n</code> 的数组最多只能包含 <code>1</code> 到 <code>n</code> 的整数。如果所有这些数字都出现了，那么答案就是 <code>n+1</code>，否则答案是缺失的最小正数。</p><p>具体步骤如下：</p><ol><li><strong>忽略负数和零</strong>：因为我们只关心正数。</li><li><strong>原地哈希映射</strong>：遍历数组，每遇到一个正数 <code>x</code>（且 <code>x</code> 小于等于数组长度 <code>n</code>），就把它交换到索引 <code>x-1</code> 的位置上。</li><li><strong>检查交换后的数组</strong>：第一个数值不等于索引+1的位置，该位置的索引+1即为缺失的最小正数。</li><li><strong>边界情况处理</strong>：如果所有位置都正确，那么缺失的最小正数就是 <code>n+1</code>。</li></ol><h3 id="【实现代码】"><a href="#【实现代码】" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">firstMissingPositive</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> {</span><br><span class="line"><span class="comment">//将所有不在【1，n】间的负数标为n+1</span></span><br><span class="line">n := <span class="built_in">len</span>(nums)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;n;i++ {</span><br><span class="line"><span class="keyword">if</span> nums[i] &lt;= <span class="number">0</span> {</span><br><span class="line">nums[i] = n +<span class="number">1</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//将所有在【1，n】的数标为key=&gt;负数</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;n;i++ {</span><br><span class="line">num := abs(nums[i])</span><br><span class="line">        <span class="keyword">if</span> num &lt;= n {</span><br><span class="line">            nums[num - <span class="number">1</span>] = -abs(nums[num - <span class="number">1</span>])</span><br><span class="line">        }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;n;i++ {</span><br><span class="line"><span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>  {</span><br><span class="line"><span class="keyword">return</span> i+<span class="number">1</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> n+<span class="number">1</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">abs</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> {</span><br><span class="line"><span class="keyword">if</span> n &lt; <span class="number">0</span> {</span><br><span class="line"><span class="keyword">return</span> -n</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31 下一个排列"></a>31 下一个排列</h2><h3 id="【题目描述】-1"><a href="#【题目描述】-1" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>具体步骤如下：</p><ul><li>从右向左查找第一个相邻数对 (i, j)，满足 <code>a[i] &lt; a[j]</code>。此步是为了找到需要进行调整的边界。</li><li>如果找到了这样的数对，再从右向左查找第一个大于 <code>a[i]</code> 的数 <code>a[k]</code>，然后交换 <code>a[i]</code> 和 <code>a[k]</code>。</li><li>最后，将从 <code>a[j]</code> 到数组末尾的部分进行反转，确保这部分是最小的升序排列，以形成下一个排列。</li></ul><p>如果整个数组都是降序排列的，说明它已经是最大的排列，此时直接将整个数组反转成升序排列。</p><h3 id="【解题思路】-1"><a href="#【解题思路】-1" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>首先从数组末尾开始查找两个连续的数，它们满足前一个数小于后一个数，找到这样的一对数后，再从数组末尾开始找到第一个比前一个数大的数，交换这两个数。然后将后一个数之后（包括它自己）的所有数反转，使其成为升序。这样就得到了字典序的下一个排列。</p><p>如果遍历完都没有找到这样的数对，说明当前排列是最大的，直接反转整个数组即可。</p><h3 id="【实现代码】-1"><a href="#【实现代码】-1" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextPermutation</span><span class="params">(nums []<span class="type">int</span>)</span></span> {</span><br><span class="line">length := <span class="built_in">len</span>(nums)</span><br><span class="line">i := length - <span class="number">2</span></span><br><span class="line"><span class="comment">// 找到第一个升序的相邻元素对</span></span><br><span class="line"><span class="keyword">for</span> i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i+<span class="number">1</span>] {</span><br><span class="line">i--</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> i &gt;= <span class="number">0</span> { <span class="comment">// 如果存在这样的元素对</span></span><br><span class="line">j := length - <span class="number">1</span></span><br><span class="line"><span class="comment">// 从后向前查找第一个大于nums[i]的数</span></span><br><span class="line"><span class="keyword">for</span> j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &lt;= nums[i] {</span><br><span class="line">j--</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 交换这两个数</span></span><br><span class="line">nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 反转i之后的所有元素，使其升序排列</span></span><br><span class="line">reverse(nums, i+<span class="number">1</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(nums []<span class="type">int</span>, start <span class="type">int</span>)</span></span> {</span><br><span class="line">i := start</span><br><span class="line">j := <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i &lt; j {</span><br><span class="line">nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">i++</span><br><span class="line">j--</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56 合并区间"></a>56 合并区间</h2><h3 id="【题目描述】-2"><a href="#【题目描述】-2" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给出一个区间的集合，请合并所有重叠的区间。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: intervals = [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出: [[1,6],[8,10],[15,18]]</span><br><span class="line">解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: intervals = [[1,4],[4,5]]</span><br><span class="line">输出: [[1,5]]</span><br><span class="line">解释: 区间 [1,4] 和 [4,5] 可以被视为重叠区间。</span><br></pre></td></tr></table></figure><h3 id="【解题思路】-2"><a href="#【解题思路】-2" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>合并区间的问题可以通过以下步骤解决：</p><ol><li><strong>排序</strong>：首先按照区间的起始位置对区间进行排序。</li><li><strong>合并</strong>：遍历排序后的区间列表，对于每个区间，如果它与结果列表中最后一个区间重叠（即它的起始位置小于或等于最后一个区间的结束位置），则将它们合并（更新最后一个区间的结束位置为两者的最大值）。如果不重叠，直接将当前区间添加到结果列表中。</li></ol><p>这种方法的核心在于，一旦列表按起始位置排序，就只需要一次遍历就能完成合并。</p><h3 id="【实现代码】-2"><a href="#【实现代码】-2" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(intervals [][]<span class="type">int</span>)</span></span> [][]<span class="type">int</span> {</span><br><span class="line">sort.Slice(intervals, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> {</span><br><span class="line"><span class="keyword">return</span> intervals[i][<span class="number">0</span>] &lt; intervals[j][<span class="number">0</span>]</span><br><span class="line">})</span><br><span class="line">res := [][]<span class="type">int</span>{intervals[<span class="number">0</span>]}</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(intervals); i++ {</span><br><span class="line"><span class="keyword">if</span> res[<span class="built_in">len</span>(res)<span class="number">-1</span>][<span class="number">1</span>] &gt;= intervals[i][<span class="number">0</span>] {</span><br><span class="line">res[<span class="built_in">len</span>(res)<span class="number">-1</span>][<span class="number">1</span>] = max(intervals[i][<span class="number">1</span>], res[<span class="built_in">len</span>(res)<span class="number">-1</span>][<span class="number">1</span>])</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">res = <span class="built_in">append</span>(res, intervals[i])</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> {</span><br><span class="line"><span class="keyword">if</span> a &gt; b {</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33 搜索旋转排序数组"></a>33 搜索旋转排序数组</h2><h3 id="【题目描述】-3"><a href="#【题目描述】-3" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>整数数组 <code>nums</code> 按升序排列，数组中的值 互不相同 。在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 旋转，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 从 0 开始 计数）。例如，<code>[0,1,2,4,5,6,7]</code> 在下标 3 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code>。</p><p>给你 旋转后 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code>。</p><h3 id="【解题思路】-3"><a href="#【解题思路】-3" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><ol><li><p><strong>二分查找</strong>：由于数组原本是排序的，尽管它被旋转了，仍然可以利用二分查找的思想。关键在于判断哪一半是有序的，并在有序的半边进行二分查找。</p></li><li><p><strong>判断有序的一半</strong>：在每次循环中，我们可以通过比较中间元素和端点元素的大小，来判断左半部分或右半部分哪一部分是完全有序的。</p></li><li><p><strong>确定搜索范围</strong>：一旦我们知道哪一半是有序的，我们可以检查 <code>target</code> 是否在这个范围内：</p><ul><li>如果 <code>target</code> 在有序的一半内，我们将搜索范围缩小到这一半。</li><li>如果 <code>target</code> 不在有序的一半内，我们将搜索范围缩小到另一半。</li></ul></li><li><p><strong>重复上述过程</strong>，直到找到 <code>target</code> 或者搜索范围为空。</p></li></ol><h3 id="【实现代码】-3"><a href="#【实现代码】-3" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> {</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> left &lt;= right {</span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target {</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断左半部分是否是有序的</span></span><br><span class="line">        <span class="keyword">if</span> nums[left] &lt;= nums[mid] {</span><br><span class="line">            <span class="comment">// 如果target在左半部分的有序区间内</span></span><br><span class="line">            <span class="comment">// target &gt;= nums[left]</span></span><br><span class="line">            <span class="keyword">if</span> target &gt;= nums[left] &amp;&amp; target &lt; nums[mid] {</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 右半部分是有序的</span></span><br><span class="line">            <span class="comment">// 如果target在右半部分的有序区间内</span></span><br><span class="line">            <span class="comment">// target &lt;= nums[right]</span></span><br><span class="line">            <span class="keyword">if</span> target &gt; nums[mid] &amp;&amp; target &lt;= nums[right] {</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977 有序数组的平方"></a>977 有序数组的平方</h2><h3 id="【题目描述】-4"><a href="#【题目描述】-4" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你一个按非递减顺序排序的整数数组 <code>nums</code>，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-4,-1,0,3,10]</span><br><span class="line">输出：[0,1,9,16,100]</span><br><span class="line">解释：平方后，数组变为 [16,1,0,9,100]</span><br><span class="line">排序后，数组变为 [0,1,9,16,100]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-7,-3,2,3,11]</span><br><span class="line">输出：[4,9,9,49,121]</span><br></pre></td></tr></table></figure><h3 id="【解题思路】-4"><a href="#【解题思路】-4" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>对于这个问题，一个直观的解法是先将数组中的每个元素平方，然后对数组进行排序。但是，这种方法的时间复杂度较高，因为排序操作是昂贵的。</p><p>一个更高效的方法是利用输入数组已经是有序的这一特性。我们可以使用两个指针分别从数组的最左端和最右端开始，比较两端元素的绝对值大小，将较大的元素的平方放入结果数组的末尾，并移动指针。这样做的原因是，由于数组已经是有序的，那么最大的平方值只可能出现在数组的两端。通过这种方式，我们可以在不进行额外排序的情况下完成任务。</p><h3 id="【实现代码】-4"><a href="#【实现代码】-4" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortedSquares</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> {</span><br><span class="line">n := <span class="built_in">len</span>(nums)</span><br><span class="line">res := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">l,r := <span class="number">0</span>, n<span class="number">-1</span></span><br><span class="line">index := n<span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> l&lt;=r {</span><br><span class="line"><span class="comment">//左右两端的数据一定是最大的</span></span><br><span class="line"><span class="keyword">if</span> nums[l] * nums[l] &gt; nums[r] * nums[r] {</span><br><span class="line">res[index] = nums[l] * nums[l]</span><br><span class="line">l++</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">res[index] =  nums[r] * nums[r]</span><br><span class="line">r--</span><br><span class="line">}</span><br><span class="line">index--</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209 长度最小的子数组"></a>209 长度最小的子数组</h2><h3 id="【题目描述】-5"><a href="#【题目描述】-5" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>s</code> ，找出该数组中满足其和 ≥ <code>s</code> 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的连续子数组，返回 0。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的连续子数组。</span><br></pre></td></tr></table></figure><h3 id="【解题思路】-5"><a href="#【解题思路】-5" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题可以用双指针或滑动窗口的方法来解决。基本思路是，维护一个窗口的左右指针，开始时都指向数组的起始位置。然后，逐渐扩大窗口（即移动右指针）直到窗口内元素的总和大于等于 <code>s</code> 。此时，尝试缩小窗口（即移动左指针），以找到更小的满足条件的窗口。记录过程中窗口的最小长度。重复这个过程直到右指针到达数组末尾。</p><h3 id="【实现代码】-5"><a href="#【实现代码】-5" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minSubArrayLen</span><span class="params">(target <span class="type">int</span>, nums []<span class="type">int</span>)</span></span> <span class="type">int</span> {</span><br><span class="line">res := math.MaxInt</span><br><span class="line">n := <span class="built_in">len</span>(nums)</span><br><span class="line">l,r := <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> r &lt; n {</span><br><span class="line">sum += nums[r]</span><br><span class="line">r++</span><br><span class="line"><span class="comment">//满足要求后，维护最小值，并左移左窗口</span></span><br><span class="line"><span class="keyword">for</span> sum &gt;= target {</span><br><span class="line">res = min(r-l,res)</span><br><span class="line">sum-=nums[l]</span><br><span class="line">l++</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> res == math.MaxInt {</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a,b <span class="type">int</span>)</span></span><span class="type">int</span> {</span><br><span class="line"><span class="keyword">if</span> a&gt;b {</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59 螺旋矩阵 II"></a>59 螺旋矩阵 II</h2><h3 id="【题目描述】-6"><a href="#【题目描述】-6" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你一个正整数 <code>n</code>，生成一个包含 <code>1</code> 到 <code>n^2</code> 所有元素，且元素按顺时针螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code>。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[[1,2,3],[8,9,4],[7,6,5]]</span><br></pre></td></tr></table></figure><h3 id="【解题思路】-6"><a href="#【解题思路】-6" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>生成螺旋矩阵的关键是按照螺旋的顺序填充矩阵。我们可以将矩阵看成是一层一层的环。每一次填充外层的环，然后是内层的环，直到填充完成。</p><p>我们可以定义四个变量，<code>top</code>, <code>bottom</code>, <code>left</code>, <code>right</code>，分别表示当前环的上下左右边界。初始时，<code>top = 0</code>, <code>bottom = n-1</code>, <code>left = 0</code>, <code>right = n-1</code>。我们按照从左到右、从上到下、从右到左、从下到上的顺序填充矩阵，每填充完一圈，就将对应的边界向内缩一层，即 <code>top++</code>, <code>bottom--</code>, <code>left++</code>, <code>right--</code>，直到填充完成。</p><h3 id="【实现代码】-6"><a href="#【实现代码】-6" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateMatrix</span><span class="params">(n <span class="type">int</span>)</span></span> [][]<span class="type">int</span> {</span><br><span class="line">    matrix := <span class="built_in">make</span>([][]<span class="type">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> matrix {</span><br><span class="line">        matrix[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    num := <span class="number">1</span></span><br><span class="line">    top, bottom, left, right := <span class="number">0</span>, n<span class="number">-1</span>, <span class="number">0</span>, n<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> num &lt;= n*n {</span><br><span class="line">        <span class="comment">// 从左到右填充上层</span></span><br><span class="line">        <span class="keyword">for</span> i := left; i &lt;= right; i++ {</span><br><span class="line">            matrix[top][i] = num</span><br><span class="line">            num++</span><br><span class="line">        }</span><br><span class="line">        top++</span><br><span class="line">        <span class="comment">// 从上到下填充右层</span></span><br><span class="line">        <span class="keyword">for</span> i := top; i &lt;= bottom; i++ {</span><br><span class="line">            matrix[i][right] = num</span><br><span class="line">            num++</span><br><span class="line">        }</span><br><span class="line">        right--</span><br><span class="line">        <span class="comment">// 从右到左填充下层</span></span><br><span class="line">        <span class="keyword">for</span> i := right; i &gt;= left; i-- {</span><br><span class="line">            matrix[bottom][i] = num</span><br><span class="line">            num++</span><br><span class="line">        }</span><br><span class="line">        bottom--</span><br><span class="line">        <span class="comment">// 从下到上填充左层</span></span><br><span class="line">        <span class="keyword">for</span> i := bottom; i &gt;= top; i-- {</span><br><span class="line">            matrix[i][left] = num</span><br><span class="line">            num++</span><br><span class="line">        }</span><br><span class="line">        left++</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> matrix</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200 岛屿数量"></a>200 岛屿数量</h2><h3 id="【题目描述】-7"><a href="#【题目描述】-7" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四个边均被水包围。</p><h3 id="【解题思路】-7"><a href="#【解题思路】-7" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>要求出岛屿的数量，可以通过深度优先搜索（DFS）来实现。遍历整个网格，当遇到一个为 ‘1’ 的单元格时，我们将其视为一个岛屿的起始点。从这个点开始，使用 DFS 遍历所有相邻的、值为 ‘1’ 的单元格，将它们标记为已访问，这样可以防止它们被重复计算。在这个过程中，每当进行一次完整的 DFS 遍历，就意味着找到了一个完整的岛屿，岛屿数量加一。遍历完成后，就可以得到岛屿的总数量。</p><h3 id="【实现代码】-7"><a href="#【实现代码】-7" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numIslands</span><span class="params">(grid [][]<span class="type">byte</span>)</span></span> <span class="type">int</span> {</span><br><span class="line">row,col := <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(i,j <span class="type">int</span>)</span></span></span><br><span class="line">dfs = <span class="function"><span class="keyword">func</span><span class="params">(i,j <span class="type">int</span>)</span></span> {</span><br><span class="line"><span class="keyword">if</span> i &lt;<span class="number">0</span> || i &gt;= row || j &lt; <span class="number">0</span> || j&gt;=col {</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> grid[i][j] == <span class="string">'1'</span> {</span><br><span class="line">grid[i][j] = <span class="string">'0'</span></span><br><span class="line">dfs(i+<span class="number">1</span>,j)</span><br><span class="line">dfs(i<span class="number">-1</span>,j)</span><br><span class="line">dfs(i,j+<span class="number">1</span>)</span><br><span class="line">dfs(i,j<span class="number">-1</span>)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">res := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;row;i++ {</span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;col;j++ {</span><br><span class="line"><span class="keyword">if</span> grid[i][j] == <span class="string">'1'</span> {</span><br><span class="line">res++</span><br><span class="line">dfs(i,j)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numIslands</span><span class="params">(grid [][]<span class="type">byte</span>)</span></span> <span class="type">int</span> {</span><br><span class="line">res := <span class="number">0</span></span><br><span class="line">m, n := <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">var</span> bfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span></span><br><span class="line">direction := [][]<span class="type">int</span>{{<span class="number">-1</span>, <span class="number">0</span>}, {<span class="number">1</span>, <span class="number">0</span>}, {<span class="number">0</span>, <span class="number">1</span>}, {<span class="number">0</span>, <span class="number">-1</span>}}</span><br><span class="line">bfs = <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> {</span><br><span class="line">grid[i][j] = <span class="string">'#'</span></span><br><span class="line">queue := [][]<span class="type">int</span>{{i, j}}</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> {</span><br><span class="line">cur := queue[<span class="number">0</span>]</span><br><span class="line">queue = queue[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">for</span> _, move := <span class="keyword">range</span> direction {</span><br><span class="line">nextI, nextJ := cur[<span class="number">0</span>]+move[<span class="number">0</span>], cur[<span class="number">1</span>]+move[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> nextI &lt; <span class="number">0</span> || nextJ &lt; <span class="number">0</span> || nextI &gt;= m || nextJ &gt;= n {</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> grid[nextI][nextJ] == <span class="string">'1'</span> {</span><br><span class="line">grid[nextI][nextJ] = <span class="string">'#'</span></span><br><span class="line">queue = <span class="built_in">append</span>(queue, []<span class="type">int</span>{nextI, nextJ})</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ {</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ {</span><br><span class="line"><span class="keyword">if</span> grid[i][j] == <span class="string">'1'</span> {</span><br><span class="line">res++</span><br><span class="line">bfs(i, j)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">}</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web攻击</title>
      <link href="/2024/04/09/read/web%E6%94%BB%E5%87%BB/"/>
      <url>/2024/04/09/read/web%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="浏览器同源策略"><a href="#浏览器同源策略" class="headerlink" title="浏览器同源策略"></a>浏览器同源策略</h3><p>同协议，域名，端口被视同源<br>使用xhr发起ajax请求受同源策略的影响，但img，script，iframe等不受影响</p><h2 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h2><h3 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h3><p>我们都知道 TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 <code>SYN</code> 报文，服务端每接收到一个 <code>SYN</code> 报文，就进入<code>SYN_RCVD</code> 状态，但服务端发送出去的 <code>ACK + SYN</code> 报文，无法得到未知 IP 主机的 <code>ACK</code> 应答，久而久之就会<strong>占满服务端的半连接队列</strong>，使得服务端不能为正常用户服务。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li>调大 netdev_max_backlog；</li><li>增大 TCP 半连接队列；</li><li>开启 tcp_syncookies；<ul><li>当tcp的半连接队列满了之后，不会丢弃，会在ack的响应包了加上cookie放在序列号里，最终在ACK的时候做校验</li></ul></li><li>减少 SYN+ACK 重传次数</li></ul><h3 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h3><p>Cross Site Script，通常指黑客通过“HTML注入”篡改了网页，插入了恶意的脚本，从而在用户浏览网页时，控制用户浏览器的一种攻击。</p><ul><li>反射型</li><li>存储型</li><li>DOM BASED(修改dom节点)<br>破坏案例</li><li>cookie劫持（HttpOnly可避免）</li><li>构造GET，POST请求<br>解决方法</li><li>输入检查</li><li>输出检查（字符转义）</li></ul><h3 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h3><p>用户在登录某个网站的情况下访问某个恶意网站，在可以网站可发起对登录网站的请求从而造成攻击<br>解决方案</p><ul><li>验证码（有时候不友好）</li><li>服务端生成csrf token，在提交时服务端对比csrf token的值</li></ul><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>对sql做预处理</p><h3 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h3><ul><li>上传文件的目录设置为不可执行</li><li>判断文件的MIME和文件名</li><li>使用随机数修改文件名</li></ul><h3 id="DDOS"><a href="#DDOS" class="headerlink" title="DDOS"></a>DDOS</h3><ul><li>网络层的 syn flood</li><li>业务层</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 八股 </tag>
            
            <tag> web攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2024/04/08/leetcode/%E9%93%BE%E8%A1%A8/"/>
      <url>/2024/04/08/leetcode/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>为了方便链表的处理，通常需要加一个dummy节点</p></blockquote><h2 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148 排序链表"></a>148 排序链表</h2><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p><h3 id="【解题思路】"><a href="#【解题思路】" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>排序链表的题目要求在 O(n log n) 的时间复杂度和常数级的空间复杂度下完成。这提示我们使用归并排序，因为归并排序恰好满足这些条件。归并排序的核心思想是分而治之：将问题分解成一些小问题然后递归求解，而治的阶段则将分的阶段得到的各个答案”修补”在一起，即分割然后合并。</p><ol><li><strong>分割</strong>：使用快慢指针技术找到链表的中点，然后将链表从中点分为两部分。</li><li><strong>递归排序</strong>：递归地对两个子链表进行排序，直到子链表长度为1或0。</li><li><strong>合并</strong>：将两个已排序的子链表合并成一个排序后的链表。</li></ol><p>这种方法的空间复杂度较低，因为它只使用几个额外的指针，所以是常数级的。</p><h3 id="【实现代码】"><a href="#【实现代码】" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数：对链表进行排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortList</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用快慢指针找到中间节点 </span></span><br><span class="line">    <span class="comment">// 注意 fast的初始值是head.Next，而不是head，否则会包内存超限</span></span><br><span class="line">    slow, fast := head, head.Next</span><br><span class="line">    <span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分割链表</span></span><br><span class="line">    mid := slow.Next</span><br><span class="line">    slow.Next = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归排序两个子链表</span></span><br><span class="line">    leftSorted := sortList(head)</span><br><span class="line">    rightSorted := sortList(mid)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两个已排序的链表</span></span><br><span class="line">    <span class="keyword">return</span> mergeTwoLists(leftSorted, rightSorted)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并两个排序链表的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(l1 *ListNode, l2 *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    dummy := &amp;ListNode&#123;&#125;</span><br><span class="line">    current := dummy</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两个链表</span></span><br><span class="line">    <span class="keyword">for</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> l1.Val &lt; l2.Val &#123;</span><br><span class="line">            current.Next = l1</span><br><span class="line">            l1 = l1.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current.Next = l2</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        current = current.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接剩余部分</span></span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        current.Next = l1</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        current.Next = l2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83 删除排序链表中的重复元素"></a>83 删除排序链表中的重复元素</h2><h3 id="【题目描述】-1"><a href="#【题目描述】-1" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p><h3 id="【解题思路】-1"><a href="#【解题思路】-1" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题要求我们移除排序链表中的重复元素，这意味着重复的元素都是相邻的。我们可以通过直接遍历链表来解决这个问题，过程中检查当前节点与下一个节点是否相同。</p><p>解题步骤如下：</p><ol><li>使用一个指针 <code>current</code> 来遍历链表。</li><li>检查 <code>current</code> 节点和 <code>current.next</code> 节点的值是否相同。</li><li>如果相同，将 <code>current.next</code> 指向 <code>current.next.next</code>，从而跳过重复的节点。</li><li>如果不同，将 <code>current</code> 指针移动到下一个节点。</li><li>重复步骤 2 至 4，直至链表结束。</li><li>返回链表的头部。</li></ol><p>这个方法只需要一次遍历，所以时间复杂度是 O(n)，其中 n 是链表的长度。因为我们只是改变了链表的链接而没有使用额外的存储空间，空间复杂度是 O(1)。</p><h3 id="【实现代码】-1"><a href="#【实现代码】-1" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteDuplicates</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">dummy := &amp;ListNode&#123;<span class="number">0</span>, head&#125;</span><br><span class="line">cur := dummy</span><br><span class="line"><span class="keyword">for</span> cur.Next != <span class="literal">nil</span> &amp;&amp; cur.Next.Next != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> cur.Next.Val == cur.Next.Next.Val &#123;</span><br><span class="line">cur.Next = cur.Next.Next</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cur = cur.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82 删除排序链表中的重复元素 II"></a>82 删除排序链表中的重复元素 II</h2><h3 id="【题目描述】-2"><a href="#【题目描述】-2" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个已排序的链表的头 <code>head</code>，删除原始链表中所有重复数字的节点，只留下不同的数字。返回已排序的链表。</p><h3 id="【解题思路】-2"><a href="#【解题思路】-2" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题主要考察链表的操作和细节处理。由于链表是排序的，重复元素必然相邻。我们可以使用两个指针来解决这个问题：一个是当前节点的指针 <code>current</code>，另一个是前驱节点的指针 <code>prev</code>。这样我们可以通过比较 <code>current</code> 节点和其下一个节点 <code>current.next</code> 来判断是否有重复。<br>具体步骤如下：</p><ol><li>创建一个哑节点 <code>dummy</code>，它的 <code>next</code> 指向 <code>head</code>。这是为了方便处理头节点可能被删除的情况。</li><li>初始化 <code>prev</code> 为 <code>dummy</code>。</li><li>遍历链表，对每个节点，检查其后续节点是否与当前节点值相同。</li><li>如果发现重复，用一个内循环跳过这些重复节点，找到第一个不同的节点。然后让 <code>prev.next</code> 指向这个节点。</li><li>如果没有发现重复，则简单地将 <code>prev</code> 移动到 <code>current</code>。</li><li>遍历完成后，<code>dummy.next</code> 将是新链表的头节点。</li></ol><h3 id="【实现代码】-2"><a href="#【实现代码】-2" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteDuplicates</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">dummy := &amp;ListNode&#123;<span class="number">0</span>,head&#125;</span><br><span class="line">cur := dummy</span><br><span class="line"><span class="keyword">for</span> cur.Next != <span class="literal">nil</span> &amp;&amp; cur.Next.Next != <span class="literal">nil</span>&#123;</span><br><span class="line">val := cur.Next.Val</span><br><span class="line"><span class="keyword">if</span> val == cur.Next.Next.Val &#123;</span><br><span class="line"><span class="keyword">for</span> cur.Next != <span class="literal">nil</span> &amp;&amp; cur.Next.Val == val &#123;</span><br><span class="line">cur.Next = cur.Next.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cur = cur.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143 重排链表"></a>143 重排链表</h2><h3 id="【题目描述】-3"><a href="#【题目描述】-3" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个单链表 <code>L: L0→L1→…→Ln-1→Ln</code>，将其重新排列后变为：<code>L0→Ln→L1→Ln-1→L2→Ln-2→…</code></p><p>你不能只是单纯地改变节点内部的值，而是需要实际的进行节点交换。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure><h3 id="【解题思路】-3"><a href="#【解题思路】-3" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>解题步骤如下：</p><ol><li><strong>找到中点</strong>：使用快慢指针技巧找到链表的中点。快指针每次移动两步，慢指针每次移动一步，当快指针到达链表末尾时，慢指针将处于中间位置。</li><li><strong>反转后半部分</strong>：从慢指针开始的后半部分链表进行反转。</li><li><strong>合并链表</strong>：将原链表的前半部和反转后的后半部交替合并。</li></ol><p>这种方法只需要线性的时间和常数的空间复杂度。</p><h3 id="【实现代码】-3"><a href="#【实现代码】-3" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val  <span class="type">int</span></span><br><span class="line">    Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reorderList</span><span class="params">(head *ListNode)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> || head.Next.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 1: Find the middle of the linked list</span></span><br><span class="line">    slow, fast := head, head</span><br><span class="line">    <span class="comment">//fast != nil &amp;&amp; fast.Next != nil</span></span><br><span class="line">    <span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2: Reverse the second half</span></span><br><span class="line">    <span class="keyword">var</span> prev *ListNode</span><br><span class="line">    curr := slow</span><br><span class="line">    <span class="comment">//curr != nil </span></span><br><span class="line">    <span class="keyword">for</span> curr != <span class="literal">nil</span> &#123;</span><br><span class="line">        next := curr.Next</span><br><span class="line">        curr.Next = prev</span><br><span class="line">        prev = curr</span><br><span class="line">        curr = next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 3: Merge two halves</span></span><br><span class="line">    first, second := head, prev</span><br><span class="line">    <span class="comment">//second.Next != nil</span></span><br><span class="line">    <span class="keyword">for</span> second.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        temp1 := first.Next</span><br><span class="line">        temp2 := second.Next</span><br><span class="line">        first.Next = second</span><br><span class="line">        second.Next = temp1</span><br><span class="line">        first = temp1</span><br><span class="line">        second = temp2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203 移除链表元素"></a>203 移除链表元素</h2><h3 id="【题目描述】-4"><a href="#【题目描述】-4" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>删除链表中等于给定值 <code>val</code> 的所有节点，并返回新的头节点。</p><h3 id="【解题思路】-4"><a href="#【解题思路】-4" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>解决这个问题的关键是要注意我们可能需要删除头节点，因为头节点也可能等于给定的值 <code>val</code>。因此，一个常见的方法是添加一个哑节点（dummy node）作为新的头节点，这样可以统一处理头节点和其他节点的删除操作。</p><ol><li><strong>添加哑节点</strong>：在原链表的头节点之前添加一个哑节点，哑节点的 <code>next</code> 指向原链表的头节点。</li><li><strong>遍历链表</strong>：遍历链表，比较当前节点的下一个节点的值是否等于给定值 <code>val</code>。如果等于，就需要删除这个节点。这可以通过改变当前节点的 <code>next</code> 指针来实现，让它指向下下个节点。</li><li><strong>返回结果</strong>：遍历完成后，返回哑节点的 <code>next</code> 节点，即新的头节点。</li></ol><h3 id="【实现代码】-4"><a href="#【实现代码】-4" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeElements</span><span class="params">(head *ListNode, val <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">    dummy := &amp;ListNode&#123;Next: head&#125;</span><br><span class="line">    current := dummy</span><br><span class="line">    <span class="keyword">for</span> current.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> current.Next.Val == val &#123;</span><br><span class="line">            current.Next = current.Next.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = current.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707 设计链表"></a>707 设计链表</h2><h3 id="【题目描述】-5"><a href="#【题目描述】-5" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：<code>val</code> 和 <code>next</code>。<code>val</code> 是当前节点的值，<code>next</code> 是指向下一个节点的指针&#x2F;引用。如果要使用双向链表，则还需要一个属性 <code>prev</code> 以指示链表中的上一个节点。在链表类中实现这些功能：</p><ul><li>get(index)：获取链表中第 <code>index</code> 个节点的值。如果索引无效，则返回-1。</li><li>addAtHead(val)：在链表的第一个元素之前添加一个值为 <code>val</code> 的节点。插入后，新节点将成为链表的第一个节点。</li><li>addAtTail(val)：将值为 <code>val</code> 的节点追加到链表的最后一个元素。</li><li>addAtIndex(index, val)：在链表中的第 <code>index</code> 个节点之前添加值为 <code>val</code> 的节点。如果 <code>index</code> 等于链表的长度，则该节点将附加到链表的末尾。如果 <code>index</code> 大于链表长度，则不会插入节点。如果 <code>index</code> 小于0，则在头部插入节点。</li><li>deleteAtIndex(index)：如果索引 <code>index</code> 有效，则删除链表中的第 <code>index</code> 个节点。</li></ul><h3 id="【解题思路】-5"><a href="#【解题思路】-5" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>在这个问题中，我们将实现一个单链表，其中包含一个哑节点（dummy node）作为辅助节点，以简化在链表头部添加和删除节点的操作。</p><ol><li><strong>初始化</strong>：链表初始化时，创建一个哑节点，哑节点的 <code>next</code> 属性指向 <code>null</code>。维护一个 <code>size</code> 变量来跟踪链表的长度。</li><li><strong>获取节点值</strong>：在获取第 <code>index</code> 个节点的值时，首先检查 <code>index</code> 是否有效（即 <code>0 &lt;= index &lt; size</code>），然后从哑节点开始遍历到第 <code>index</code> 个节点，返回其值。</li><li><strong>在头部添加节点</strong>：创建新节点，将新节点的 <code>next</code> 指向原头节点，哑节点的 <code>next</code> 指向新节点，链表长度 <code>size</code> 加1。</li><li><strong>在尾部添加节点</strong>：遍历到链表的最后一个节点，将其 <code>next</code> 指向新节点，链表长度 <code>size</code> 加1。</li><li><strong>在指定位置添加节点</strong>：首先检查 <code>index</code> 是否有效，如果有效（包括在头部添加和尾部添加的特殊情况），则遍历到指定位置的前一个节点，按照插入逻辑添加新节点。</li><li><strong>删除节点</strong>：如果 <code>index</code> 有效，遍历到指定位置的前一个节点，改变前一个节点的 <code>next</code>，以跳过需要删除的节点。</li></ol><h3 id="【实现代码】-5"><a href="#【实现代码】-5" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val  <span class="type">int</span></span><br><span class="line">    Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyLinkedList <span class="keyword">struct</span> &#123;</span><br><span class="line">    size <span class="type">int</span></span><br><span class="line">    head *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> MyLinkedList &#123;</span><br><span class="line"><span class="comment">//head为dummy节点，方便遍历</span></span><br><span class="line">    <span class="keyword">return</span> MyLinkedList&#123;<span class="number">0</span>, &amp;ListNode&#123;<span class="number">0</span>, <span class="literal">nil</span>&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyLinkedList)</span></span> Get(index <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> index &lt; <span class="number">0</span> || index &gt;= this.size &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    current := this.head</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= index; i++ &#123;</span><br><span class="line">        current = current.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current.Val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyLinkedList)</span></span> AddAtHead(val <span class="type">int</span>) &#123;</span><br><span class="line">    this.AddAtIndex(<span class="number">0</span>, val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyLinkedList)</span></span> AddAtTail(val <span class="type">int</span>) &#123;</span><br><span class="line">    this.AddAtIndex(this.size, val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyLinkedList)</span></span> AddAtIndex(index <span class="type">int</span>, val <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> index &gt; this.size &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> index &lt; <span class="number">0</span> &#123;</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    this.size++</span><br><span class="line">    pred := this.head</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; index; i++ &#123;</span><br><span class="line">        pred = pred.Next</span><br><span class="line">    &#125;</span><br><span class="line">    newNode := &amp;ListNode&#123;val, pred.Next&#125;</span><br><span class="line">    pred.Next = newNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyLinkedList)</span></span> DeleteAtIndex(index <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> index &lt; <span class="number">0</span> || index &gt;= this.size &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    this.size--</span><br><span class="line">    pred := this.head</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; index; i++ &#123;</span><br><span class="line">        pred = pred.Next</span><br><span class="line">    &#125;</span><br><span class="line">    pred.Next = pred.Next.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24 两两交换链表中的节点"></a>24 两两交换链表中的节点</h2><h3 id="【题目描述】-6"><a href="#【题目描述】-6" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure><h3 id="【解题思路】-6"><a href="#【解题思路】-6" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>解决这个问题的关键是理解两两交换链表中节点的过程。我们可以使用迭代的方式来完成这个任务。对于链表中的两个相邻节点，我们可以通过更新节点指针的指向来交换这两个节点。</p><p>具体步骤如下：</p><ol><li>**初始化一个哨兵节点(dummy node)**，这个节点的下一个指向链表的头节点。这样做的目的是为了简化在链表头部进行操作的逻辑，使得头节点和中间的节点可以用同一套逻辑来处理。</li><li><strong>遍历链表</strong>：使用一个指针（我们称之为<code>prev</code>）从哨兵节点开始遍历，每次处理一对节点。<code>prev</code>的下一个节点就是这对节点中的第一个，而<code>prev</code>的下一个节点的下一个就是这对节点中的第二个。</li><li><strong>交换两个节点</strong>：改变<code>prev</code>和这对节点的指针关系，使得第二个节点指向第一个节点，第一个节点指向第二个节点的下一个节点，最后<code>prev</code>指向新的第一个节点（即原来的第二个节点）。</li><li>**移动<code>prev</code>**：将<code>prev</code>移动到下一对需要交换的节点的前一个位置。</li><li>当链表的长度是奇数时，最后一个节点不需要交换，直接保持即可。</li></ol><p>这样，通过一次遍历，我们就可以完成整个链表的两两节点交换。</p><h3 id="【实现代码】-6"><a href="#【实现代码】-6" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapPairs</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">dummy := &amp;ListNode&#123;<span class="number">0</span>, head&#125;</span><br><span class="line">prev := dummy</span><br><span class="line">cur := dummy.Next</span><br><span class="line"><span class="keyword">for</span> cur != <span class="literal">nil</span> &amp;&amp; cur.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">next := cur.Next</span><br><span class="line">cur.Next = next.Next</span><br><span class="line">next.Next = cur</span><br><span class="line">prev.Next = next</span><br><span class="line"></span><br><span class="line">prev = cur</span><br><span class="line">cur = cur.Next</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92 反转链表 II"></a>92 反转链表 II</h2><h3 id="【题目描述】-7"><a href="#【题目描述】-7" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code>，其中 <code>left &lt;= right</code>。请你反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点，返回反转后的链表。</p><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: head = [1,2,3,4,5], left = 2, right = 4</span><br><span class="line">输出: [1,4,3,2,5]</span><br></pre></td></tr></table></figure><h3 id="【解题思路】-7"><a href="#【解题思路】-7" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>本题的关键是要理解如何在链表中仅反转一部分节点。我们可以分解为以下几个步骤：</p><ol><li><p><strong>定位到<code>left</code>和<code>right</code>：</strong> 首先，我们需要遍历链表找到<code>left</code>和<code>right</code>对应的节点，同时记录<code>left</code>节点的前一个节点，因为反转后需要重新连接。</p></li><li><p><strong>反转部分链表：</strong> 从<code>left</code>位置开始，进行常规的链表反转直到<code>right</code>位置。在反转过程中，记录反转部分的新头节点和新尾节点。</p></li><li><p><strong>重新连接：</strong> 反转完成后，确保<code>left</code>前一个节点链接到新的头节点，同时新的尾节点需要连接到<code>right</code>位置之后的节点。</p></li></ol><p>通过这个方法，我们能在一次遍历中完成链表的部分反转。</p><h3 id="【实现代码】-7"><a href="#【实现代码】-7" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseBetween</span><span class="params">(head *ListNode, left <span class="type">int</span>, right <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">if</span> left == right &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dummyHead := &amp;ListNode&#123;<span class="number">0</span>, head&#125;</span><br><span class="line">    prev := dummyHead</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动到 left 的前一个位置</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; left<span class="number">-1</span>; i++ &#123;</span><br><span class="line">        prev = prev.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始反转</span></span><br><span class="line">    <span class="comment">//cur节点一直不会变</span></span><br><span class="line">    current := prev.Next</span><br><span class="line">    <span class="keyword">var</span> next *ListNode</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; right-left; i++ &#123;</span><br><span class="line">        next = current.Next</span><br><span class="line">        current.Next = next.Next</span><br><span class="line">        next.Next = prev.Next</span><br><span class="line">        prev.Next = next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummyHead.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="25-K个一组翻转链表"><a href="#25-K个一组翻转链表" class="headerlink" title="25 K个一组翻转链表"></a>25 K个一组翻转链表</h2><h3 id="【题目描述】-8"><a href="#【题目描述】-8" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>进阶：</p><ul><li>你可以设计一个只使用常数额外空间的算法来解决此问题吗？</li><li>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</li></ul><h3 id="【解题思路】-8"><a href="#【解题思路】-8" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>解决这个问题的关键是分两步走：首先，我们需要能够翻转链表中指定部分的节点；其次，我们要按照题目要求，每k个节点为一组进行翻转。</p><ol><li><p><strong>翻转链表的一部分</strong>：<br>我们需要一个辅助函数来实现这一点。这个函数将接收两个参数：需要翻转的链表的头节点和尾节点。通过迭代或递归的方式，我们可以翻转这部分链表，并返回新的头尾节点。</p></li><li><p><strong>按组翻转</strong>：<br>我们遍历整个链表，每次移动k个节点，然后使用上述的翻转函数翻转这k个节点。为了方便操作，我们可以使用一个哑节点（dummy node）指向链表的头部。这样，无论如何翻转，哑节点都会指向新的头节点。同时，我们需要跟踪每一组的前一个节点和后一个节点，以便翻转完成后，能够正确地连接链表。</p></li><li><p><strong>处理剩余节点</strong>：<br>如果链表的长度不是k的整数倍，最后剩余的节点不需要翻转，保持原样即可。</p></li></ol><h3 id="【实现代码】-8"><a href="#【实现代码】-8" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseKGroup</span><span class="params">(head *ListNode, k <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">dummy := &amp;ListNode&#123;<span class="number">0</span>, head&#125;</span><br><span class="line"><span class="comment">// 为保证tail是最后一个节点，则需要tail指向prev才能满足遍历到k次</span></span><br><span class="line">prev, tail := dummy, dummy</span><br><span class="line"><span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">tail = tail.Next</span><br><span class="line"><span class="keyword">if</span> tail == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">next := tail.Next</span><br><span class="line"><span class="comment">// 区间[head, tail]</span></span><br><span class="line">newHead, newTail := reverse(head, tail)</span><br><span class="line"><span class="comment">// 将翻转后的链接接回原链表</span></span><br><span class="line">newTail.Next = next</span><br><span class="line">prev.Next = newHead</span><br><span class="line"><span class="comment">// 重置节点</span></span><br><span class="line">prev = newTail</span><br><span class="line">tail = newTail</span><br><span class="line">head = next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间是[head, tial], 所以返回的是tail,head,reverse只改变指针指向</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(head, tail *ListNode)</span></span> (*ListNode, *ListNode) &#123;</span><br><span class="line"><span class="keyword">var</span> prev *ListNode</span><br><span class="line">cur := head</span><br><span class="line"><span class="keyword">for</span> prev != tail &#123;</span><br><span class="line">next := cur.Next</span><br><span class="line">cur.Next = prev</span><br><span class="line">prev = cur</span><br><span class="line">cur = next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tail, head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141 环形链表"></a>141 环形链表</h2><h3 id="【题目描述】-9"><a href="#【题目描述】-9" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个链表，判断链表中是否有环。如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 true 。否则，返回 false 。</p><h3 id="【解题思路】-9"><a href="#【解题思路】-9" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>判断链表中是否有环可以使用“快慢指针”方法。这个方法包括两个指针：一个快指针（每次移动两步）和一个慢指针（每次移动一步）。算法从头节点开始，快指针和慢指针同时出发。如果链表中有环，那么快指针最终会追上慢指针，即两者会在环内的某个点相遇，这时可以判断链表有环。如果链表没有环，那么快指针会到达链表的末尾（即快指针遇到 null），这时可以判断链表没有环。</p><h3 id="【实现代码】-9"><a href="#【实现代码】-9" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//首先都在起点</span></span><br><span class="line">slow, fast := head, head</span><br><span class="line"></span><br><span class="line"><span class="comment">//慢指针走一步，快指针走两步</span></span><br><span class="line"><span class="comment">// 只需要判断快指针就行，不用关慢指针</span></span><br><span class="line"><span class="keyword">for</span> fast.Next != <span class="literal">nil</span> &amp;&amp; fast.Next.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">slow = slow.Next </span><br><span class="line">fast = fast.Next.Next</span><br><span class="line"><span class="keyword">if</span> slow == fast &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142 环形链表 II"></a>142 环形链表 II</h2><h3 id="【题目描述】-10"><a href="#【题目描述】-10" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p><p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。注意，<code>pos</code> 仅仅是用于标识环的参数，你并不需要对链表进行修改。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><h3 id="【解题思路】-10"><a href="#【解题思路】-10" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>解决这个问题的关键是使用<strong>快慢指针</strong>的方法。快指针每次移动两步，慢指针每次移动一步。如果链表中存在环，则快慢指针最终会在环内相遇。之后，我们可以用以下步骤找到环的入口：</p><ol><li>当快慢指针首次相遇时，将快指针重新定位到链表的头部，并将其移动速度改为每次一步。</li><li>然后，快慢指针再次同时出发，每次都移动一步。</li><li>当它们再次相遇时，相遇点就是环的入口。</li></ol><p>这个方法的正确性基于数学证明，关键在于理解，当快慢指针首次在环内相遇时，慢指针没有遍历完整个链表，而此时快指针已经在环内多转了若干圈。无论环的大小，将快指针重置并改为每次移动一步，它们都会在环的入口相遇。</p><h3 id="【实现代码】-10"><a href="#【实现代码】-10" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">detectCycle</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">slow, fast := head,head</span><br><span class="line">hasCycle := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">fast=fast.Next.Next</span><br><span class="line">slow = slow.Next</span><br><span class="line"><span class="keyword">if</span> fast == slow &#123;</span><br><span class="line">hasCycle = <span class="literal">true</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !hasCycle &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">slow = head</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> slow == fast &#123;</span><br><span class="line"><span class="keyword">return</span> slow</span><br><span class="line">&#125;</span><br><span class="line">slow = slow.Next</span><br><span class="line">fast = fast.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希表</title>
      <link href="/2024/04/07/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>/2024/04/07/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>散列函数是哈希表的核心，好的散列函数应该满足下面几点:</p><ol><li>设计不能太复杂</li><li>生成的值要尽可能的随机且均匀</li></ol><h2 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242 有效的字母异位词"></a>242 有效的字母异位词</h2><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定两个字符串 <em>s</em> 和 <em>t</em> ，编写一个函数来判断 <em>t</em> 是否是 <em>s</em> 的字母异位词。</p><p>注意：字母异位词指的是由相同字母按照不同的顺序组成的单词，例如，“anagram”和“nagaram”互为字母异位词。</p><h3 id="【解题思路】"><a href="#【解题思路】" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题可以通过统计两个字符串中每个字母出现的次数来解决。具体的方法是：</p><ol><li>首先判断两个字符串的长度，如果长度不相等，那么它们不可能是字母异位词。</li><li>创建一个长度为26的整型数组来统计每个字符出现的次数，因为英文字母一共有26个。遍历字符串 <em>s</em> ，对于遇到的每个字符，将其对应的数组元素加1；然后遍历字符串 <em>t</em> ，对于遇到的每个字符，将其对应的数组元素减1。</li><li>最后，检查这个整型数组，如果所有元素都为0，则说明两个字符串互为字母异位词；如果有任何一个元素不为0，则两个字符串不是字母异位词。</li></ol><h3 id="【实现代码】"><a href="#【实现代码】" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isAnagram</span><span class="params">(s <span class="type">string</span>, t <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 如果字符串长度不相等，直接返回false</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) != <span class="built_in">len</span>(t) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个长度为26的数组来统计每个字符出现的次数</span></span><br><span class="line">    count := [<span class="number">26</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历字符串s，对应字符的计数加1</span></span><br><span class="line">    <span class="keyword">for</span> _, char := <span class="keyword">range</span> s &#123;</span><br><span class="line">        count[char-<span class="string">&#x27;a&#x27;</span>]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历字符串t，对应字符的计数减1</span></span><br><span class="line">    <span class="keyword">for</span> _, char := <span class="keyword">range</span> t &#123;</span><br><span class="line">        count[char-<span class="string">&#x27;a&#x27;</span>]--</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查计数数组，如果所有元素都为0，则说明是字母异位词</span></span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> count &#123;</span><br><span class="line">        <span class="keyword">if</span> c != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349 两个数组的交集"></a>349 两个数组的交集</h2><h3 id="【题目描述】-1"><a href="#【题目描述】-1" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定两个数组 <code>nums1</code> 和 <code>nums2</code>，返回它们的交集。输出结果中的每个元素一定是唯一的。我们可以不考虑输出结果的顺序。</p><h3 id="【解题思路】-1"><a href="#【解题思路】-1" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>要解决这个问题，我们可以使用集合（在Go中称为map）来帮助我们快速查找和剔除重复元素。具体步骤如下：</p><ol><li><strong>创建集合</strong>：首先，遍历第一个数组 <code>nums1</code>，并使用集合 <code>set1</code> 来存储其元素，以此确保元素的唯一性。</li><li><strong>查找交集</strong>：然后，遍历第二个数组 <code>nums2</code>，对于每个元素，检查它是否已经存在于 <code>set1</code> 中。如果存在，说明该元素是两个数组的交集之一，将其添加到结果集合 <code>resultSet</code> 中。</li><li><strong>结果转换</strong>：由于结果要求是数组形式，最后我们需要将 <code>resultSet</code> 集合转换成数组形式返回。</li></ol><p>这样，我们就可以得到两个数组的交集，同时保证了结果中元素的唯一性。</p><h3 id="【实现代码】-1"><a href="#【实现代码】-1" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intersection</span><span class="params">(nums1 []<span class="type">int</span>, nums2 []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    set1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;) <span class="comment">// 使用map作为集合存储nums1中的元素</span></span><br><span class="line">    resultSet := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;) <span class="comment">// 存储结果的集合</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充set1</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums1 &#123;</span><br><span class="line">        set1[num] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历nums2，查找交集</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums2 &#123;</span><br><span class="line">        <span class="keyword">if</span> _, found := set1[num]; found &#123;</span><br><span class="line">            resultSet[num] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将resultSet转换为切片</span></span><br><span class="line">    result := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="built_in">len</span>(resultSet))</span><br><span class="line">    <span class="keyword">for</span> num := <span class="keyword">range</span> resultSet &#123;</span><br><span class="line">        result = <span class="built_in">append</span>(result, num)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202 快乐数"></a>202 快乐数</h2><h3 id="【题目描述】-2"><a href="#【题目描述】-2" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>编写一个算法来判断一个数 <em>n</em> 是不是快乐数。</p><p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为1，也可能是无限循环但始终变不到1。如果可以变为1，那么这个数就是快乐数。</p><p>如果 <em>n</em> 是快乐数就返回 <code>True</code> ；不是，则返回 <code>False</code> 。</p><h3 id="【解题思路】-2"><a href="#【解题思路】-2" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>快乐数的解法可以用「快慢指针」思想来解决，这个方法也被用来检测链表中的循环。思路如下：</p><ol><li><strong>快慢指针</strong>：创建两个变量，一个移动速度是另一个的两倍。这里，慢指针每次计算一次平方和，快指针计算两次。</li><li><strong>循环或结束</strong>：如果这个数不是快乐数，快指针最终会进入循环，而慢指针最终会追上快指针；如果这个数是快乐数，那么快指针或慢指针最终会等于1。</li><li><strong>检测</strong>：基于上述逻辑，我们只需要在循环中检测快指针是否等于1，或者快慢指针是否相遇即可。</li></ol><h3 id="【实现代码】-2"><a href="#【实现代码】-2" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快慢指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isHappy</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    slow, fast := n, getNext(n)</span><br><span class="line">    <span class="keyword">for</span> fast != <span class="number">1</span> &amp;&amp; slow != fast &#123;</span><br><span class="line">        slow = getNext(slow)</span><br><span class="line">        fast = getNext(getNext(fast))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fast == <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//map</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isHappy</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">mp := <span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">n = next(n)</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> _, ok := mp[n]; ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">mp[n] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">n = next(n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getNext</span><span class="params">(num <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        sum := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num &gt; <span class="number">0</span> &#123;</span><br><span class="line">            digit := num % <span class="number">10</span></span><br><span class="line">            sum += digit * digit</span><br><span class="line">            num /= <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1 两数之和"></a>1 两数之和</h2><h3 id="【题目描述】-3"><a href="#【题目描述】-3" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><h3 id="【解题思路】-3"><a href="#【解题思路】-3" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题可以通过哈希表来高效解决。具体步骤如下：</p><ol><li><strong>创建哈希表</strong>：遍历整个数组，对于每个元素，我们检查哈希表中是否存在一个键，该键的值等于 <code>target - 当前元素值</code>。如果这个键存在，那么我们已经找到了目标元素，直接返回这两个元素的下标。</li><li><strong>存储和查找</strong>：如果我们没有在哈希表中找到对应的键，那么我们将当前元素的值作为键，当前元素的下标作为值存入哈希表中。这样做的目的是为了在接下来的遍历中，可以快速检查 <code>target - 当前元素值</code> 是否存在。</li><li><strong>返回结果</strong>：一旦在遍历过程中找到满足条件的两个数，即可返回它们的下标作为答案。</li></ol><h3 id="【实现代码】-3"><a href="#【实现代码】-3" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    hashTable := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> j, ok := hashTable[target-num]; ok &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="type">int</span>&#123;j, i&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        hashTable[num] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="454-四数相加-II"><a href="#454-四数相加-II" class="headerlink" title="454 四数相加 II"></a>454 四数相加 II</h2><h3 id="【题目描述】-4"><a href="#【题目描述】-4" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定四个包含整数的数组列表 <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>，计算有多少个元组 <code>(i, j, k, l)</code>，使得 <code>A[i] + B[j] + C[k] + D[l] = 0</code>。为了使问题简单化，所有的 <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> 具有相同的长度 <code>N</code>，且 <code>0 ≤ N ≤ 500</code>。所有整数的范围在 <code>-2^28</code> 到 <code>2^28 - 1</code> 之间，最终结果不会超过 <code>2^31 - 1</code>。</p><h3 id="【解题思路】-4"><a href="#【解题思路】-4" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题可以通过分组和哈希表来解决，具体步骤如下：</p><ol><li><strong>分组</strong>：首先将四个数组分成两组，<code>(A, B)</code> 和 <code>(C, D)</code>。</li><li><strong>哈希表存储</strong>：对于组 <code>(A, B)</code>，计算两个数组中任意两数之和，将这些和放入哈希表中，键为和，值为这个和出现的次数。</li><li><strong>查找和为0的组合</strong>：然后，对于组 <code>(C, D)</code>，计算任意两数之和的负数，然后查找这个负数是否已经在哈希表中。如果存在，说明我们找到了一些组合，其总和为0。将哈希表中对应的值（即出现的次数）加到结果中。</li><li><strong>返回结果</strong>：最终，结果即为所有满足条件的组合数。</li></ol><h3 id="【实现代码】-4"><a href="#【实现代码】-4" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fourSumCount</span><span class="params">(A []<span class="type">int</span>, B []<span class="type">int</span>, C []<span class="type">int</span>, D []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    countAB := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算A和B中任意两数之和，以及这个和出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> _, a := <span class="keyword">range</span> A &#123;</span><br><span class="line">        <span class="keyword">for</span> _, b := <span class="keyword">range</span> B &#123;</span><br><span class="line">            countAB[a+b]++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找C和D中任意两数之和的负数是否在上面的哈希表中</span></span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> C &#123;</span><br><span class="line">        <span class="keyword">for</span> _, d := <span class="keyword">range</span> D &#123;</span><br><span class="line">            ans += countAB[-(c + d)]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串</title>
      <link href="/2024/04/07/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2024/04/07/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43 字符串相乘"></a>43 字符串相乘</h3><h4 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h4><p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也用字符串表示。</p><p>注意：</p><ul><li><code>num1</code> 和 <code>num2</code> 的长度小于110。</li><li><code>num1</code> 和 <code>num2</code> 只包含数字 <code>0-9</code>。</li><li><code>num1</code> 和 <code>num2</code> 均不包含任何前导零，除了数字0本身。</li></ul><h4 id="【解题思路】"><a href="#【解题思路】" class="headerlink" title="【解题思路】"></a>【解题思路】</h4><ol><li><strong>初始化结果数组</strong>：我们可以使用一个长度为 <code>num1.length + num2.length</code> 的数组来存储结果，这个数组的每个元素初始化为0。这样做是因为两个长度为 <code>m</code> 和 <code>n</code> 的数相乘，其结果长度最多为 <code>m + n</code> 位。</li><li><strong>模拟手工乘法的过程</strong>：<ul><li>我们对 <code>num1</code> 和 <code>num2</code> 的每个数字进行相乘，并把结果累加到对应的结果数组位置上。</li><li>具体来说，<code>num1[i] * num2[j]</code> 会影响到结果数组中的两个位置：<code>i+j</code> 和 <code>i+j+1</code>。<code>i+j</code> 位置存储当前位的结果，<code>i+j+1</code> 位置存储进位。</li></ul></li><li><strong>处理进位</strong>：遍历结果数组，从低位到高位处理进位。</li><li><strong>跳过前导零</strong>：从结果数组中找到第一个非零数字开始，跳过所有前导零，并构造最终的结果字符串。</li></ol><h4 id="【实现代码】"><a href="#【实现代码】" class="headerlink" title="【实现代码】"></a>【实现代码】</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multiply</span><span class="params">(num1 <span class="type">string</span>, num2 <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="comment">// 特殊情况处理</span></span><br><span class="line">    <span class="keyword">if</span> num1 == <span class="string">&quot;0&quot;</span> || num2 == <span class="string">&quot;0&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m, n := <span class="built_in">len</span>(num1), <span class="built_in">len</span>(num2)</span><br><span class="line">    result := <span class="built_in">make</span>([]<span class="type">int</span>, m+n)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟手工乘法</span></span><br><span class="line">    <span class="keyword">for</span> i := m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="keyword">for</span> j := n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j-- &#123;</span><br><span class="line">            mul := <span class="type">int</span>(num1[i]-<span class="string">&#x27;0&#x27;</span>) * <span class="type">int</span>(num2[j]-<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            p1, p2 := i+j, i+j+<span class="number">1</span></span><br><span class="line">            sum := mul + result[p2]</span><br><span class="line"></span><br><span class="line">            result[p1] += sum / <span class="number">10</span></span><br><span class="line">            result[p2] = sum % <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳过前导零</span></span><br><span class="line">    start := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> start &lt; <span class="built_in">len</span>(result) &amp;&amp; result[start] == <span class="number">0</span> &#123;</span><br><span class="line">        start++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造结果字符串</span></span><br><span class="line">    resStr := <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> ; start &lt; <span class="built_in">len</span>(result); start++ &#123;</span><br><span class="line">        resStr += <span class="type">string</span>(result[start] + <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resStr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    num1 := <span class="string">&quot;123&quot;</span></span><br><span class="line">    num2 := <span class="string">&quot;456&quot;</span></span><br><span class="line">    fmt.Println(multiply(num1, num2)) <span class="comment">// Output: &quot;56088&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8 字符串转换整数 (atoi)"></a>8 字符串转换整数 (atoi)</h2><h3 id="【题目描述】-1"><a href="#【题目描述】-1" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>实现一个 <code>atoi</code> 函数，使其能将字符串转换成整数。函数首先根据需要丢弃无用的空白字符，直到找到第一个非空白的字符。然后，从这个字符开始，取一个可选的初始正号或负号，紧接着是尽可能多的数字，并将它们解释为数值。</p><p>该字符串可以包含额外的字符后面跟着些数字，这些字符将被忽略，这意味着它们对于数值的解析没有影响。如果字符串中的第一个非空白字符序列不是有效的整数，或者如果因字符串为空或只包含空白字符，那么不进行转换。</p><p>如果不能执行有效的转换，则返回零值。如果正确的值超出了可表示的值范围，则返回 <code>INT_MAX</code> (2147483647) 或 <code>INT_MIN</code> (-2147483648)。</p><h3 id="【解题思路】-1"><a href="#【解题思路】-1" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><ol><li><strong>处理空白字符</strong>：从字符串开始遍历，跳过所有的空白字符。</li><li><strong>处理正负号</strong>：检查非空白字符后的第一个字符是否为正号或负号，并记录这一状态。</li><li><strong>数字转换</strong>：继续遍历字符，如果字符是数字，则将其转换为整数，并加到结果中。如果遇到非数字字符，则停止解析。</li><li><strong>边界处理</strong>：在将数字字符转换为整数的过程中，实时检查是否超出32位整数的范围，如果超出则返回相应的边界值。</li><li><strong>返回结果</strong>：根据正负号返回最终的整数结果。</li></ol><h3 id="【实现代码】-1"><a href="#【实现代码】-1" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myAtoi</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 跳过前导空白</span></span><br><span class="line">    index := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> index &lt; <span class="built_in">len</span>(s) &amp;&amp; s[index] == <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">        index++</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> index == <span class="built_in">len</span>(s) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断正负号</span></span><br><span class="line">    sign := <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> s[index] == <span class="string">&#x27;+&#x27;</span> &#123;</span><br><span class="line">        index++</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> s[index] == <span class="string">&#x27;-&#x27;</span> &#123;</span><br><span class="line">        sign = <span class="number">-1</span></span><br><span class="line">        index++</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析数字</span></span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> index &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">        ch := s[index]</span><br><span class="line">        <span class="keyword">if</span> ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        digit := <span class="type">int</span>(ch - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        <span class="comment">// 检查溢出</span></span><br><span class="line">        <span class="keyword">if</span> result &gt; (math.MaxInt32-digit)/<span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> sign == <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> math.MaxInt32</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> math.MinInt32</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        result = result * <span class="number">10</span> + digit</span><br><span class="line">        index++</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sign * result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="541-反转字符串-II"><a href="#541-反转字符串-II" class="headerlink" title="541 反转字符串 II"></a>541 反转字符串 II</h2><h3 id="【题目描述】-2"><a href="#【题目描述】-2" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个字符串 <code>s</code> 和一个整数 <code>k</code>，你需要对从字符串开头算起的每隔 <code>2k</code> 个字符的前 <code>k</code> 个字符进行反转。如果剩余字符少于 <code>k</code> 个，则将剩余字符全部反转。如果剩余字符小于 <code>2k</code> 但大于或等于 <code>k</code> 个，则反转前 <code>k</code> 个字符，其余字符保持原样。</p><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出: &quot;bacdfeg&quot;</span><br></pre></td></tr></table></figure><h3 id="【解题思路】-2"><a href="#【解题思路】-2" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这道题的核心思路是按照题目要求在每个 <code>2k</code> 长度的段内进行操作。具体步骤如下：</p><ol><li>遍历字符串，步长为 <code>2k</code>，这样可以保证每次处理都是按照题目要求的段落来进行。</li><li>对于每个段落，先判断剩余字符的数量，以决定具体的操作：<ul><li>如果剩余字符少于 <code>k</code> 个，则将这些字符全部反转。</li><li>如果剩余字符大于或等于 <code>k</code> 个，但少于 <code>2k</code> 个，则只反转前 <code>k</code> 个字符。</li></ul></li><li>反转字符串的具体操作可以通过两个指针实现：一个指向段落的开始，一个指向需要反转的部分的末尾，然后交换这两个指针所指向的字符，并向中间移动，直到两个指针相遇或者交错。</li></ol><h3 id="【实现代码】-2"><a href="#【实现代码】-2" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reverseStringPart 反转字符串中指定区间 [start, end] 的字符</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseStringPart</span><span class="params">(s []<span class="type">byte</span>, start, end <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> start &lt; end &#123;</span><br><span class="line">        s[start], s[end] = s[end], s[start]</span><br><span class="line">        start++</span><br><span class="line">        end--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reverseStr 按题目要求反转字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseStr</span><span class="params">(s <span class="type">string</span>, k <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    str := []<span class="type">byte</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i += <span class="number">2</span> * k &#123;</span><br><span class="line">        <span class="comment">// 判断剩余字符的数量，决定反转的范围</span></span><br><span class="line">        <span class="keyword">if</span> i+k &lt;= <span class="built_in">len</span>(s) &#123;</span><br><span class="line">            reverseStringPart(str, i, i+k<span class="number">-1</span>) <span class="comment">// 反转前k个字符</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reverseStringPart(str, i, <span class="built_in">len</span>(s)<span class="number">-1</span>) <span class="comment">// 反转所有剩余字符</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="28-实现-strStr"><a href="#28-实现-strStr" class="headerlink" title="28 实现 strStr()"></a>28 实现 strStr()</h2><h3 id="【题目描述】-3"><a href="#【题目描述】-3" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>实现 <code>strStr()</code> 函数。</p><p>给你两个字符串 <code>haystack</code> 和 <code>needle</code>，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  <code>-1</code> 。</p><p>说明：</p><p>当 <code>needle</code> 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p><p>对于本题而言，当 <code>needle</code> 是空字符串时我们应当返回 <code>0</code>。这与 C 语言的 <code>strstr()</code> 以及 Java 的 <code>indexOf()</code> 定义相符。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：haystack = &quot;hello&quot;, needle = &quot;ll&quot;</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><h3 id="【解题思路】-3"><a href="#【解题思路】-3" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>实现 <code>strStr()</code> 函数的关键是遍历 <code>haystack</code> 字符串，对于每个位置，检查从这个位置开始的子字符串是否与 <code>needle</code> 字符串匹配。</p><ol><li><strong>特殊情况处理</strong>：如果 <code>needle</code> 是空字符串，则根据题目要求返回 <code>0</code>。</li><li>**遍历 <code>haystack</code>**：从头到尾遍历 <code>haystack</code> 字符串，对于每个位置，尝试匹配 <code>needle</code> 字符串。</li><li>**匹配 <code>needle</code>**：对于 <code>haystack</code> 中的每个位置，检查从该位置开始的子字符串是否与 <code>needle</code> 完全匹配。如果匹配，则返回当前位置作为答案。</li><li><strong>返回结果</strong>：如果遍历了整个 <code>haystack</code> 都没有找到匹配的位置，则返回 <code>-1</code>。</li></ol><h3 id="【实现代码】-3"><a href="#【实现代码】-3" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// strStr 实现查找子字符串的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">strStr</span><span class="params">(haystack <span class="type">string</span>, needle <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">n1,n2 := <span class="built_in">len</span>(haystack), <span class="built_in">len</span>(needle)</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i+n2 &lt;= n1 &#123;</span><br><span class="line">j:= <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j &lt; n2 &amp;&amp; haystack[i+j] == needle[j] &#123;</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> j == n2 &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459 重复的子字符串"></a>459 重复的子字符串</h2><h3 id="【题目描述】-4"><a href="#【题目描述】-4" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个非空的字符串 <code>s</code>，检查是否可以通过由它的一个子串重复多次构成。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abab&quot;</span><br><span class="line">输出: True</span><br><span class="line">解释: 可由子字符串 &quot;ab&quot; 重复两次构成。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;aba&quot;</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcabcabc&quot;</span><br><span class="line">输出: True</span><br><span class="line">解释: 可由子字符串 &quot;abc&quot; 重复四次构成。 (或子字符串 &quot;abcabc&quot; 重复两次构成。)</span><br></pre></td></tr></table></figure><h3 id="【解题思路】-4"><a href="#【解题思路】-4" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>要判断一个字符串是否由它的一个子串重复多次构成，我们可以考虑以下思路：</p><ol><li><strong>字符串拼接</strong>：将原字符串 <code>s</code> 复制一遍并拼接到自身的后面，并移除掉首尾各一个字符，形成新字符串 <code>s2</code>。原因是如果 <code>s</code> 是由重复的子串构成的，那么 <code>s2</code> 中必定包含至少两个 <code>s</code>（因为 <code>s</code> 至少重复了一次），而移除首尾字符是为了防止 <code>s</code> 本身就是重复的子串而导致的误判。</li><li><strong>查找原字符串</strong>：然后在新字符串 <code>s2</code> 中查找原字符串 <code>s</code> 是否出现。如果 <code>s</code> 出现在 <code>s2</code> 中（并且不是在起始位置），那么 <code>s</code> 就是由重复的子串构成的。</li></ol><h3 id="【实现代码】-4"><a href="#【实现代码】-4" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="comment">// repeatedSubstringPattern 检查字符串是否由重复的子串构成</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">repeatedSubstringPattern</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">d := s +s </span><br><span class="line">d = d[<span class="number">1</span>:<span class="built_in">len</span>(d)<span class="number">-1</span>]</span><br><span class="line"><span class="comment">//return strings.Contains(d,s)</span></span><br><span class="line"><span class="keyword">return</span> strStr(d,s) != <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">strStr</span><span class="params">(a, b <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">n1,n2 := <span class="built_in">len</span>(a), <span class="built_in">len</span>(b)</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i+n2 &lt;= n1 &#123;</span><br><span class="line">j:=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j&lt;n2 &amp;&amp; a[i+j] == b[j] &#123;</span><br><span class="line">j++</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> j == n2 &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针</title>
      <link href="/2024/04/07/leetcode/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
      <url>/2024/04/07/leetcode/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<blockquote><p>双指针解法通常是使用两个指针同时移动来实现</p></blockquote><p>常见的有：</p><ol><li>快慢指针：移出元素，删除倒数第K个元素，链表环</li><li>首尾指针：反转字符串,N数之和</li></ol><h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415 字符串相加"></a>415 字符串相加</h2><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定两个字符串形式的非负整数 <code>num1</code> 和 <code>num2</code> ，计算它们的和并且也以字符串形式返回。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: num1 = &quot;11&quot;, num2 = &quot;123&quot;</span><br><span class="line">输出: &quot;134&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: num1 = &quot;456&quot;, num2 = &quot;77&quot;</span><br><span class="line">输出: &quot;533&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: num1 = &quot;0&quot;, num2 = &quot;0&quot;</span><br><span class="line">输出: &quot;0&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= num1.length, num2.length &lt;= 104</code></li><li><code>num1</code> 和 <code>num2</code> 由数字组成，除了 ‘0’ 本身以外，不含前导零。</li></ul><h3 id="【解题思路】"><a href="#【解题思路】" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题可以通过模拟手动加法的过程来解决。具体步骤如下：</p><ol><li>从两个字符串的最后一位开始，逐位相加，如果加起来超过10，则记录进位。</li><li>将每一位的计算结果（考虑进位）存储下来。</li><li>如果一方的数字用完了，另一方还有剩余，则继续将剩余的数字加上当前的进位继续计算。</li><li>最终可能还存在一个进位，需要判断并加到最终结果的最前面。</li><li>注意整个过程中，我们需要将字符串转换为整数进行计算，并将计算结果转回字符串。<br>这种方法的时间复杂度为O(max(len(num1), len(num2)))，空间复杂度为O(1)。</li></ol><h3 id="【实现代码】"><a href="#【实现代码】" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addStrings</span><span class="params">(num1 <span class="type">string</span>, num2 <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    i, j := <span class="built_in">len</span>(num1)<span class="number">-1</span>, <span class="built_in">len</span>(num2)<span class="number">-1</span></span><br><span class="line">    carry := <span class="number">0</span></span><br><span class="line">    result := <span class="string">&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> n1, n2 <span class="type">int</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="number">0</span> &#123;</span><br><span class="line">            n1 = <span class="type">int</span>(num1[i] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            i--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> j &gt;= <span class="number">0</span> &#123;</span><br><span class="line">            n2 = <span class="type">int</span>(num2[j] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            j--</span><br><span class="line">        &#125;</span><br><span class="line">        sum := n1 + n2 + carry</span><br><span class="line">        carry = sum / <span class="number">10</span></span><br><span class="line">        result = strconv.Itoa(sum % <span class="number">10</span>) + result</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88 合并两个有序数组"></a>88 合并两个有序数组</h2><h3 id="【题目描述】-1"><a href="#【题目描述】-1" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你两个有序整数数组 <code>nums1</code> 和 <code>nums2</code>，请你将 <code>nums2</code> 合并到 <code>nums1</code> 中，使 <code>nums1</code> 成为一个有序数组。</p><p>初始化 <code>nums1</code> 和 <code>nums2</code> 的元素数量分别为 <code>m</code> 和 <code>n</code>。你可以假设 <code>nums1</code> 有足够的空间（空间大小大于或等于 <code>m + n</code>）来保存 <code>nums2</code> 中的元素。</p><h3 id="【解题思路】-1"><a href="#【解题思路】-1" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>解题的关键在于从后往前填充 <code>nums1</code>，这样就不需要额外的空间来存储合并后的数组了。我们设置两个指针 <code>p1</code> 和 <code>p2</code>，分别指向 <code>nums1</code> 和 <code>nums2</code> 的有元素部分的末尾，同时设置一个指针 <code>p</code> 指向合并后的 <code>nums1</code> 的末尾。比较 <code>p1</code> 和 <code>p2</code> 指向的元素，将较大的元素复制到 <code>p</code> 指向的位置，然后相应的指针向前移动一位，<code>p</code> 也向前移动一位，直到 <code>p1</code> 或 <code>p2</code> 其中一个走完。如果 <code>p2</code> 还没有走完，说明 <code>nums2</code> 中还有元素未被合并，将其余元素直接复制到 <code>nums1</code> 的前面。</p><h3 id="【实现代码】-1"><a href="#【实现代码】-1" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(nums1 []<span class="type">int</span>, m <span class="type">int</span>, nums2 []<span class="type">int</span>, n <span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">    p1, p2, p := m<span class="number">-1</span>, n<span class="number">-1</span>, m+n<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> p1 &gt;= <span class="number">0</span> &amp;&amp; p2 &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> nums1[p1] &gt; nums2[p2] &#123;</span><br><span class="line">            nums1[p] = nums1[p1]</span><br><span class="line">            p1--</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums1[p] = nums2[p2]</span><br><span class="line">            p2--</span><br><span class="line">        &#125;</span><br><span class="line">        p--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 nums2 还有剩余，直接复制到 nums1 的前面</span></span><br><span class="line">    <span class="keyword">for</span> p2 &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        nums1[p] = nums2[p2]</span><br><span class="line">        p2--</span><br><span class="line">        p--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27 移除元素"></a>27 移除元素</h2><h3 id="【题目描述】-2"><a href="#【题目描述】-2" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><h3 id="【解题思路】-2"><a href="#【解题思路】-2" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><ol><li><strong>双指针法</strong>：这个问题可以用双指针法高效地解决。定义两个指针：一个快指针（fast）和一个慢指针（slow）。快指针用于遍历数组，慢指针用于跟踪非val元素的位置。</li><li><strong>遍历数组</strong>：快指针（fast）从头到尾遍历数组。对于每次遍历：<ul><li>如果快指针指向的元素不等于val，就将快指针指向的元素复制到慢指针的位置，然后两个指针都前进一步。</li><li>如果快指针指向的元素等于val，就只移动快指针，慢指针保持不动。</li></ul></li><li><strong>返回结果</strong>：遍历结束后，慢指针的位置就是数组中非val元素的新长度。</li></ol><h3 id="【实现代码】-2"><a href="#【实现代码】-2" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeElement</span><span class="params">(nums []<span class="type">int</span>, val <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">slow := <span class="number">0</span> <span class="comment">// 初始化慢指针</span></span><br><span class="line"><span class="keyword">for</span> fast := <span class="number">0</span>; fast &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line"><span class="comment">// 如果快指针指向的元素不等于val</span></span><br><span class="line"><span class="keyword">if</span> nums[fast] != val &#123;</span><br><span class="line"><span class="comment">// 将快指针的值复制到慢指针的位置，然后移动慢指针</span></span><br><span class="line">nums[slow] = nums[fast]</span><br><span class="line">slow++</span><br><span class="line">&#125;</span><br><span class="line">fast++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 慢指针的位置即为新长度</span></span><br><span class="line"><span class="keyword">return</span> slow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151 翻转字符串里的单词"></a>151 翻转字符串里的单词</h2><h3 id="【题目描述】-3"><a href="#【题目描述】-3" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你一个字符串 s ，逐个翻转字符串中的所有 单词 。</p><p>单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。</p><p>请你返回一个翻转 s 中单词顺序并用单个空格连接的字符串。</p><p>说明：</p><ul><li>输入字符串 s 可以在前面、后面或者单词间包含多余的空格。</li><li>翻转后的字符串中不应包含额外的空格。</li></ul><h3 id="【解题思路】-3"><a href="#【解题思路】-3" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>要在O(1)空间复杂度下翻转字符串里的单词，我们不能使用额外的数组来存储分割或翻转后的结果。因此，需要在原字符串上直接进行操作。解题思路可以分为以下几步：</p><ol><li><strong>去除多余空格</strong>：首先，我们需要在原字符串上去除首尾以及单词间的多余空格。这可以通过双指针技巧在原地完成。</li><li><strong>翻转整个字符串</strong>：接下来，我们翻转整个字符串。这样做是为了让单词的顺序颠倒过来。</li><li><strong>翻转每个单词</strong>：最后，我们再次翻转字符串中的每个单词，这样单词内字符的顺序就恢复正常了，而单词的顺序则是反的。</li></ol><h3 id="【实现代码】-3"><a href="#【实现代码】-3" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(s []<span class="type">byte</span>, start, end <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> start &lt; end &#123;</span><br><span class="line">s[start], s[end] = s[end], s[start]</span><br><span class="line">start++</span><br><span class="line">end--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cleanSpaces 函数去除字符串中的多余空格，只保留单词之间的一个空格，并在原地修改。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cleanSpaces</span><span class="params">(arr []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">slow, fast := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">n := <span class="built_in">len</span>(arr)</span><br><span class="line"><span class="keyword">for</span> fast &lt; n &#123;</span><br><span class="line"><span class="comment">// 跳过单词前的空格</span></span><br><span class="line"><span class="keyword">for</span> fast &lt; n &amp;&amp; arr[fast] == <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">fast++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 复制单词到处理后的位置</span></span><br><span class="line"><span class="keyword">for</span> fast &lt; n &amp;&amp; arr[fast] != <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">arr[slow] = arr[fast]</span><br><span class="line">slow++</span><br><span class="line">fast++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 跳过单词后的空格</span></span><br><span class="line"><span class="keyword">for</span> fast &lt; n &amp;&amp; arr[fast] == <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">fast++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在单词之间添加一个空格</span></span><br><span class="line"><span class="keyword">if</span> fast &lt; n &amp;&amp; arr[fast] != <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">arr[slow] = <span class="string">&#x27; &#x27;</span></span><br><span class="line">slow++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr[:slow]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseWords</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="comment">// 转换成byte slice进行原地操作</span></span><br><span class="line">bs := []<span class="type">byte</span>(s)</span><br><span class="line"><span class="comment">// 去除多余空格</span></span><br><span class="line">bs = cleanSpaces(bs)</span><br><span class="line"><span class="comment">// 翻转整个字符串</span></span><br><span class="line">reverse(bs, <span class="number">0</span>, <span class="built_in">len</span>(bs)<span class="number">-1</span>)</span><br><span class="line"><span class="comment">// 翻转每个单词</span></span><br><span class="line">start := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="built_in">len</span>(bs); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i == <span class="built_in">len</span>(bs) || bs[i] == <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">reverse(bs, start, i<span class="number">-1</span>)</span><br><span class="line">start = i + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="type">string</span>(bs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206 反转链表"></a>206 反转链表</h2><h3 id="【题目描述】-4"><a href="#【题目描述】-4" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><h3 id="【解题思路】-4"><a href="#【解题思路】-4" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>反转链表是一个非常基础且常见的链表操作题。解决这个问题，我们主要可以采用迭代或递归的方式。这里，我将介绍迭代的方法，因为它比较直观且容易理解。</p><p>迭代方法的核心思想是遍历原链表，将每个节点的 <code>next</code> 指针指向其前一个节点。由于节点没有引用其前一个节点，我们需要额外存储前一个节点。同时，为了保持遍历的进行，我们也需要存储当前节点的下一个节点（因为修改 <code>next</code> 指针后，会丢失原本的下一个节点）。</p><p>具体步骤如下：</p><ol><li>初始化两个指针 <code>prev</code> 和 <code>curr</code>。<code>prev</code> 初始化为 <code>nil</code>，<code>curr</code> 初始化为头节点 <code>head</code>，表示当前遍历到的节点。</li><li>遍历链表直到 <code>curr</code> 为 <code>nil</code>。在遍历过程中，先暂存 <code>curr</code> 的下一个节点（因为后面需要修改 <code>curr</code> 的 <code>next</code>），然后将 <code>curr</code> 的 <code>next</code> 指向 <code>prev</code>，以此来反转链表。之后，<code>prev</code> 和 <code>curr</code> 都前进一步，继续遍历和反转。</li><li>当遍历结束时，<code>prev</code> 将会是新的头节点。</li></ol><h3 id="【实现代码】-4"><a href="#【实现代码】-4" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> prev *ListNode</span><br><span class="line">cur := head</span><br><span class="line"><span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">next := cur.Next</span><br><span class="line">cur.Next = prev</span><br><span class="line">prev = cur</span><br><span class="line">cur = next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> prev</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br><span class="line">next := reverseList(head.Next)</span><br><span class="line">head.Next.Next = head</span><br><span class="line">head.Next = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19 删除链表的倒数第N个节点"></a>19 删除链表的倒数第N个节点</h2><h3 id="【题目描述】-5"><a href="#【题目描述】-5" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你一个链表，删除链表的倒数第 <code>n</code> 个节点，并且返回链表的头节点。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure><h3 id="【解题思路】-5"><a href="#【解题思路】-5" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>要删除链表的倒数第 <code>n</code> 个节点，一个直观的思路是先遍历一遍链表以确定链表的总长度 <code>L</code>，然后再次遍历到第 <code>L-n</code> 个节点并进行删除操作。但是，这需要两次遍历，是否有方法只遍历一次就解决呢？</p><p>这里我们可以使用<strong>双指针技术</strong>中的“快慢指针”方法。具体步骤如下：</p><ol><li>创建一个哑结点（dummy node），它的 <code>next</code> 指针指向链表的头节点。这是为了便于处理边界情况，比如链表只有一个节点或需要删除头节点的情况。</li><li>初始化两个指针 <code>fast</code> 和 <code>slow</code>，它们都指向哑结点。</li><li>先移动 <code>fast</code> 指针，使其与 <code>slow</code> 指针之间相隔 <code>n</code> 个节点。</li><li>然后同时移动 <code>fast</code> 和 <code>slow</code> 指针，直到 <code>fast</code> 指向链表的末尾。</li><li>此时 <code>slow</code> 指针的下一个节点就是要删除的节点。将 <code>slow.next</code> 指向 <code>slow.next.next</code>，即可完成删除操作。</li><li>返回哑结点的下一个节点，即为新的头节点。</li></ol><h3 id="【实现代码】-5"><a href="#【实现代码】-5" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// removeNthFromEnd 删除链表的倒数第N个节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeNthFromEnd</span><span class="params">(head *ListNode, n <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">    dummy := &amp;ListNode&#123;<span class="number">0</span>, head&#125; <span class="comment">// 由于删除的可能是头结点，所以需要创建哑结点</span></span><br><span class="line">    fast, slow := dummy, dummy  <span class="comment">// 初始化快慢指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快指针先前进n+1步</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        fast = fast.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 快慢指针同时前进，直到快指针到达末尾</span></span><br><span class="line">    <span class="keyword">for</span> fast != <span class="literal">nil</span> &#123;</span><br><span class="line">        fast = fast.Next</span><br><span class="line">        slow = slow.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除倒数第n个节点</span></span><br><span class="line">    slow.Next = slow.Next.Next</span><br><span class="line">    <span class="keyword">return</span> dummy.Next <span class="comment">// 返回哑结点的下一个节点，即新的头节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160 相交链表"></a>160 相交链表</h2><h3 id="【题目描述】-6"><a href="#【题目描述】-6" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>编写一个程序，找到两个单链表相交的起始节点。如果两个链表没有交点，返回 <code>null</code>。</p><p>为了保证性能，你的代码应满足 <code>O(n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度。链表中节点的数量范围是 <code>[0, 10^9]</code>。链表节点的值的范围是 <code>[-10^9, 10^9]</code>。</p><p><strong>注意</strong>：</p><ul><li>函数返回结果后，链表必须保持其原始结构。</li><li>可假定整个链表结构中没有循环。</li><li>程序尽可能在 <code>O(n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度内运行。</li></ul><h3 id="【解题思路】-6"><a href="#【解题思路】-6" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>要找到两个链表相交的起始节点，一种直观的方法是使用两个指针分别遍历两个链表。当一个指针到达链表末尾时，将它移动到另一个链表的头部继续遍历；同样，另一个指针也这样处理。如果两个链表相交，那么这两个指针最终会在相交节点相遇。</p><p>这个方法之所以有效，是因为两个指针分别遍历两个链表后，路径长度相同（两个链表的长度和再加上它们的公共部分），所以它们会同时到达相交节点。</p><h3 id="【实现代码】-6"><a href="#【实现代码】-6" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntersectionNode</span><span class="params">(headA, headB *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">p1,p2:=headA,headB</span><br><span class="line"><span class="comment">//最终是p1 == nil &amp;&amp; p2==nil</span></span><br><span class="line"><span class="keyword">for</span> p1!= <span class="literal">nil</span> || p2 != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> p1 == p2 &#123;</span><br><span class="line"><span class="keyword">return</span> p1</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//p1走到末尾，走headB</span></span><br><span class="line"><span class="keyword">if</span> p1 == <span class="literal">nil</span> &#123;</span><br><span class="line">p1 = headB</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">p1 = p1.NextA</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//p2走到末尾，走headA</span></span><br><span class="line"><span class="keyword">if</span> p2 == <span class="literal">nil</span> &#123;</span><br><span class="line">p2 = headA</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">p2 = p2.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142 环形链表 II"></a>142 环形链表 II</h2><h3 id="【题目描述】-7"><a href="#【题目描述】-7" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p><p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。注意，<code>pos</code> 仅仅是用于标识环的参数，你并不需要对链表进行修改。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><h3 id="【解题思路】-7"><a href="#【解题思路】-7" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>解决这个问题的关键是使用<strong>快慢指针</strong>的方法。快指针每次移动两步，慢指针每次移动一步。如果链表中存在环，则快慢指针最终会在环内相遇。之后，我们可以用以下步骤找到环的入口：</p><ol><li>当快慢指针首次相遇时，将快指针重新定位到链表的头部，并将其移动速度改为每次一步。</li><li>然后，快慢指针再次同时出发，每次都移动一步。</li><li>当它们再次相遇时，相遇点就是环的入口。</li></ol><p>这个方法的正确性基于数学证明，关键在于理解，当快慢指针首次在环内相遇时，慢指针没有遍历完整个链表，而此时快指针已经在环内多转了若干圈。无论环的大小，将快指针重置并改为每次移动一步，它们都会在环的入口相遇。</p><h3 id="【实现代码】-7"><a href="#【实现代码】-7" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">detectCycle</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">slow, fast := head,head</span><br><span class="line">hasCycle := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">fast=fast.Next.Next</span><br><span class="line">slow = slow.Next</span><br><span class="line"><span class="keyword">if</span> fast == slow &#123;</span><br><span class="line">hasCycle = <span class="literal">true</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !hasCycle &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">slow = head</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> slow == fast &#123;</span><br><span class="line"><span class="keyword">return</span> slow</span><br><span class="line">&#125;</span><br><span class="line">slow = slow.Next</span><br><span class="line">fast = fast.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15 三数之和"></a>15 三数之和</h2><h3 id="【题目描述】-8"><a href="#【题目描述】-8" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你一个包含 <code>n</code> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <code>a</code>，<code>b</code>，<code>c</code>，使得 <code>a + b + c = 0</code>？请你找出所有和为 <code>0</code> 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [-1, 0, 1, 2, -1, -4]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="【解题思路】-8"><a href="#【解题思路】-8" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>解决这个问题的关键是如何有效地处理重复元素和如何将三数之和问题降为两数之和问题。</p><ol><li><strong>排序</strong>：首先对数组进行排序，这一步是为了后续去重和降低问题复杂度做准备。</li><li><strong>遍历+双指针</strong>：遍历排序后的数组，对于每个元素，使用双指针在当前元素之后的范围内寻找两个数使它们的和加上当前元素的和为0。具体做法是：固定一个数 <code>nums[i]</code>，然后使用左右指针（<code>left=i+1</code>，<code>right=len(nums)-1</code>）在 <code>nums[i]</code> 之后寻找 <code>nums[left] + nums[right] = -nums[i]</code>。</li><li><strong>去重</strong>：在遍历和双指针移动过程中，需要小心地去除重复的三元组。这可以通过跳过数组中连续相同的元素来实现。</li></ol><h3 id="【实现代码】-8"><a href="#【实现代码】-8" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// threeSum 寻找所有和为0的三元组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    result := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-2</span>; i++ &#123;</span><br><span class="line">        <span class="comment">// 跳过第一个重复元素</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        left, right := i+<span class="number">1</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">            sum := nums[i] + nums[left] + nums[right]</span><br><span class="line">            <span class="keyword">if</span> sum == <span class="number">0</span> &#123;</span><br><span class="line">                result = <span class="built_in">append</span>(result, []<span class="type">int</span>&#123;nums[i], nums[left], nums[right]&#125;)</span><br><span class="line">                <span class="comment">// 跳过重复元素</span></span><br><span class="line">                <span class="comment">//注意这里是for</span></span><br><span class="line">                <span class="keyword">for</span> left &lt; right &amp;&amp; nums[left] == nums[left+<span class="number">1</span>] &#123;left++&#125;</span><br><span class="line">                <span class="keyword">for</span> left &lt; right &amp;&amp; nums[right] == nums[right<span class="number">-1</span>] &#123;right--&#125;</span><br><span class="line">                left++</span><br><span class="line">                right--</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> sum &lt; <span class="number">0</span> &#123;</span><br><span class="line">                left++</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right--</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18.四数之和"></a>18.四数之和</h2><h3 id="【题目描述】-9"><a href="#【题目描述】-9" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>求数组中所有组成的和为target的可能，数组中可能有重复的值</p><h3 id="【解题思路】-9"><a href="#【解题思路】-9" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>和三数之和的逻辑一样，固定元素变成了两个，滑动最后两个元素</p><h3 id="【实现代码】-9"><a href="#【实现代码】-9" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fourSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">sort.Ints(nums)</span><br><span class="line">n := <span class="built_in">len</span>(nums)</span><br><span class="line">res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n<span class="number">-3</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; n<span class="number">-2</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> j &gt; i+<span class="number">1</span> &amp;&amp; nums[j] == nums[j<span class="number">-1</span>] &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">k, l := j+<span class="number">1</span>, n<span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> k &lt; l &#123;</span><br><span class="line">sum := nums[i] + nums[j] + nums[k] + nums[l]</span><br><span class="line"><span class="keyword">if</span> sum == target &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, []<span class="type">int</span>&#123;nums[i], nums[j], nums[k], nums[l]&#125;)</span><br><span class="line"><span class="keyword">for</span> k &lt; l &amp;&amp; nums[k] == nums[k+<span class="number">1</span>] &#123;</span><br><span class="line">k++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> k &lt; l &amp;&amp; nums[l] == nums[l<span class="number">-1</span>] &#123;</span><br><span class="line">l--</span><br><span class="line">&#125;</span><br><span class="line">k++</span><br><span class="line">l--</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> sum &gt; target &#123;</span><br><span class="line">l--</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">k++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5 最长回文子串"></a>5 最长回文子串</h2><h3 id="【题目描述】-10"><a href="#【题目描述】-10" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你一个字符串 s，找到 s 中最长的回文子串。</p><p>回文子串指的是这个子串读起来在正向和反向都是一样的，例如 “aba” 是回文，而 “abc” 不是。</p><h3 id="【解题思路】-10"><a href="#【解题思路】-10" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>解决这个问题的一个方法是使用动态规划。动态规划的基本想法是，我们定义一个二维数组 <code>dp</code>，其中 <code>dp[i][j]</code> 表示字符串 s 的第 i 到第 j 个字符组成的子串是否是回文子串。这里有两个基本情况：</p><ol><li>如果 <code>i == j</code>，那么 <code>dp[i][j]</code> 一定是回文子串（单个字符总是回文）。</li><li>如果 <code>s[i] == s[j]</code>，那么是否是回文子串取决于 <code>dp[i+1][j-1]</code> 是否是回文子串。</li></ol><p>根据这些规则，我们可以填充 <code>dp</code> 数组，并记录下最长回文子串的长度和起始位置，最后返回这个子串。</p><h3 id="【实现代码】-10"><a href="#【实现代码】-10" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// two pointer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="comment">//从中心向两端扩散的双指针技巧</span></span><br><span class="line">res := <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(s);i++ &#123;</span><br><span class="line"><span class="comment">//奇数的回文串</span></span><br><span class="line">s1 := palindrome(s, i,i)</span><br><span class="line"><span class="comment">//偶数的回文串</span></span><br><span class="line">s2 := palindrome(s,i,i+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(res) &lt; <span class="built_in">len</span>(s1) &#123;</span><br><span class="line">res = s1</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(res) &lt; <span class="built_in">len</span>(s2) &#123;</span><br><span class="line">res = s2</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">palindrome</span><span class="params">(s <span class="type">string</span> ,l ,r <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">for</span> l&gt;=<span class="number">0</span> &amp;&amp; r &lt; <span class="built_in">len</span>(s) &amp;&amp; s[l] == s[r] &#123;</span><br><span class="line">l--</span><br><span class="line">r++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s[l+<span class="number">1</span>:r]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// dp</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line">n := <span class="built_in">len</span>(s)</span><br><span class="line"><span class="comment">// dp[i][j]时是否是回文串</span></span><br><span class="line">dp := <span class="built_in">make</span>([][]<span class="type">bool</span>, n)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">dp[i] = <span class="built_in">make</span>([]<span class="type">bool</span>, n)</span><br><span class="line">&#125;</span><br><span class="line">maxlen := <span class="number">0</span></span><br><span class="line">start := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; j; i++ &#123;</span><br><span class="line"><span class="comment">// aba j-1==2</span></span><br><span class="line"><span class="comment">// i+1 j-1 =&gt; i,j</span></span><br><span class="line"><span class="keyword">if</span> s[i] == s[j] &amp;&amp; (j-i &lt;= <span class="number">2</span> || dp[i+<span class="number">1</span>][j<span class="number">-1</span>]) &#123;</span><br><span class="line">dp[i][j] = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> j-i &gt; maxlen &#123;</span><br><span class="line">maxlen = j - i</span><br><span class="line">start = i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s[start : start+maxlen+<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈与队列与堆</title>
      <link href="/2024/04/03/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%8E%E5%A0%86/"/>
      <url>/2024/04/03/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%8E%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<ol><li>栈：先进后出</li><li>队列：先进先出</li><li>小[大]顶堆，又叫优先队列，最大值用小顶堆，最小值用大顶堆</li></ol><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><h2 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155 最小栈"></a>155 最小栈</h2><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>设计一个支持 <code>push</code>，<code>pop</code>，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p><ul><li><code>push(x)</code> —— 将元素 x 推入栈中。</li><li><code>pop()</code> —— 删除栈顶的元素。</li><li><code>top()</code> —— 获取栈顶元素。</li><li><code>getMin()</code> —— 检索栈中的最小元素。</li></ul><p>你必须在常数时间内完成 <code>getMin</code> 操作。</p><h3 id="【解题思路】"><a href="#【解题思路】" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>为了在常数时间内检索到最小元素，我们可以使用一个辅助栈来同步保存每个元素入栈时的当前最小值。每次元素入栈时，我们比较新元素和当前最小值，将较小值推入辅助栈。这样，主栈的每个元素都对应一个在辅助栈中的当前最小值。</p><ul><li><strong>Push 操作</strong>：将元素推入主栈，并将当前最小值推入辅助栈。</li><li><strong>Pop 操作</strong>：同时从主栈和辅助栈弹出顶部元素。</li><li><strong>Top 操作</strong>：返回主栈顶部元素。</li><li><strong>GetMin 操作</strong>：返回辅助栈顶部元素，因为辅助栈顶部元素始终是当前栈中的最小值。</li></ul><h3 id="【实现代码】"><a href="#【实现代码】" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MinStack <span class="keyword">struct</span> &#123;</span><br><span class="line">    stack    []<span class="type">int</span> <span class="comment">// 主栈</span></span><br><span class="line">    minStack []<span class="type">int</span> <span class="comment">// 辅助栈，用于存储每个状态的最小值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** initialize your data structure here. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> MinStack &#123;</span><br><span class="line">    <span class="keyword">return</span> MinStack&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span></span> Push(x <span class="type">int</span>) &#123;</span><br><span class="line">    this.stack = <span class="built_in">append</span>(this.stack, x)</span><br><span class="line">    min := x</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.minStack) &gt; <span class="number">0</span> &amp;&amp; this.GetMin() &lt; x &#123;</span><br><span class="line">        min = this.GetMin()</span><br><span class="line">    &#125;</span><br><span class="line">    this.minStack = <span class="built_in">append</span>(this.minStack, min)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span></span> Pop() &#123;</span><br><span class="line">    this.stack = this.stack[:<span class="built_in">len</span>(this.stack)<span class="number">-1</span>]</span><br><span class="line">    this.minStack = this.minStack[:<span class="built_in">len</span>(this.minStack)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span></span> Top() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.stack[<span class="built_in">len</span>(this.stack)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span></span> GetMin() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.minStack[<span class="built_in">len</span>(this.minStack)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23 合并K个升序链表"></a>23 合并K个升序链表</h2><h3 id="【题目描述】-1"><a href="#【题目描述】-1" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你一个链表数组，每个链表都已经按升序排列。<br>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><h3 id="【解题思路】-1"><a href="#【解题思路】-1" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>合并K个有序链表的问题可以通过构造一个最小堆来解决。最小堆能够帮助我们维护当前所有链表头部节点中的最小节点。具体步骤如下：</p><ol><li>初始化一个最小堆，并定义堆的基本操作，如插入（push）和删除（pop）。</li><li>遍历所有链表，将每个链表的头节点插入最小堆中。</li><li>创建一个哑节点（dummy head）作为合并后链表的起始节点，这样可以简化代码逻辑。</li><li>当最小堆不为空时，执行以下步骤：<ul><li>从堆中弹出最小节点（即堆顶元素），将其添加到合并链表的末尾。</li><li>如果最小节点有下一个节点，将这个下一个节点插入最小堆中。</li></ul></li><li>当堆为空时，所有链表都已经合并完毕。</li></ol><p>为了不使用Go语言内置的<code>container/heap</code>包，我们将手动实现最小堆的操作。</p><h3 id="【实现代码】-1"><a href="#【实现代码】-1" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeKLists</span><span class="params">(lists []*ListNode)</span></span> *ListNode &#123;</span><br><span class="line"><span class="comment">// 构建堆</span></span><br><span class="line">heap := []*ListNode&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(lists); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> lists[i] != <span class="literal">nil</span> &#123;</span><br><span class="line">heap = <span class="built_in">append</span>(heap, lists[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(heap) &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">n := <span class="built_in">len</span>(heap)</span><br><span class="line">i := n/<span class="number">2</span> - <span class="number">1</span></span><br><span class="line"><span class="comment">// shifdown</span></span><br><span class="line"><span class="keyword">for</span> j := i; j &gt;= <span class="number">0</span>; j-- &#123;</span><br><span class="line">shiftdown(heap, j, n)</span><br><span class="line">&#125;</span><br><span class="line">dummy := &amp;ListNode&#123;<span class="number">0</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">cur := dummy</span><br><span class="line">j := n - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> j &gt;= <span class="number">0</span> &#123;</span><br><span class="line">cur.Next = heap[<span class="number">0</span>]</span><br><span class="line">cur = cur.Next</span><br><span class="line"><span class="comment">// if the lists has next element add to the top</span></span><br><span class="line"><span class="keyword">if</span> heap[<span class="number">0</span>].Next != <span class="literal">nil</span> &#123;</span><br><span class="line">heap[<span class="number">0</span>] = heap[<span class="number">0</span>].Next</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// swap the end with top</span></span><br><span class="line">heap[<span class="number">0</span>], heap[j] = heap[j], heap[<span class="number">0</span>]</span><br><span class="line">j--</span><br><span class="line">&#125;</span><br><span class="line">shiftdown(heap, <span class="number">0</span>, j+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小顶堆</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shiftdown</span><span class="params">(heap []*ListNode, i, n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i &lt; n &#123;</span><br><span class="line">l, r := <span class="number">2</span>*i+<span class="number">1</span>, <span class="number">2</span>*i+<span class="number">2</span></span><br><span class="line">min := i</span><br><span class="line"><span class="keyword">if</span> l &lt; n &amp;&amp; heap[min].Val &gt; heap[l].Val &#123;</span><br><span class="line">min = l</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> r &lt; n &amp;&amp; heap[min].Val &gt; heap[r].Val &#123;</span><br><span class="line">min = r</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> min != i &#123;</span><br><span class="line">heap[i], heap[min] = heap[min], heap[i]</span><br><span class="line">i = min</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232 用栈实现队列"></a>232 用栈实现队列</h2><h3 id="【题目描述】-2"><a href="#【题目描述】-2" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>使用栈实现队列的下列操作：</p><ul><li>push(x) – 将一个元素放入队列的尾部。</li><li>pop() – 从队列首部移除元素。</li><li>peek() – 返回队列首部的元素。</li><li>empty() – 返回队列是否为空。</li></ul><p>注意:</p><ul><li>你只能使用标准的栈操作 – 也就是只有 push to top, peek&#x2F;pop from top, size, 和 is empty 操作是合法的。</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li><li>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</li></ul><h3 id="【解题思路】-2"><a href="#【解题思路】-2" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题的关键在于理解栈和队列的基本差别：栈是后进先出（LIFO），而队列是先进先出（FIFO）。要用栈实现队列，我们需要两个栈：一个用来反转元素顺序（<code>inputStack</code>），另一个用来执行队列操作（<code>outputStack</code>）。</p><p>实现步骤如下：</p><ol><li><strong>Push 操作</strong>：元素总是被推入 <code>inputStack</code>。</li><li><strong>Pop&#x2F;Peek 操作</strong>：当需要执行 pop 或 peek 操作时，如果 <code>outputStack</code> 为空，我们就将 <code>inputStack</code> 中的所有元素弹出并推入 <code>outputStack</code>，这样 <code>outputStack</code> 的顶部元素就是队列的首部元素。如果 <code>outputStack</code> 不为空，我们直接从 <code>outputStack</code> 中弹出或返回顶部元素。</li><li><strong>Empty 操作</strong>：队列为空的条件是 <code>inputStack</code> 和 <code>outputStack</code> 都为空。</li></ol><p>这种方法的巧妙之处在于，它通过两次栈的后进先出操作，实现了元素的顺序反转，从而使得最早进入 <code>inputStack</code> 的元素可以最先从 <code>outputStack</code> 弹出，达到队列先进先出的效果。</p><h3 id="【实现代码】-2"><a href="#【实现代码】-2" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">    inputStack  []<span class="type">int</span></span><br><span class="line">    outputStack []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> MyQueue &#123;</span><br><span class="line">    <span class="keyword">return</span> MyQueue&#123;</span><br><span class="line">        inputStack:  []<span class="type">int</span>&#123;&#125;,</span><br><span class="line">        outputStack: []<span class="type">int</span>&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span></span> Push(x <span class="type">int</span>)  &#123;</span><br><span class="line">    this.inputStack = <span class="built_in">append</span>(this.inputStack, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span></span> Pop() <span class="type">int</span> &#123;</span><br><span class="line">    this.moveInputToOutput()</span><br><span class="line">    popVal := this.outputStack[<span class="built_in">len</span>(this.outputStack)<span class="number">-1</span>]</span><br><span class="line">    this.outputStack = this.outputStack[:<span class="built_in">len</span>(this.outputStack)<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> popVal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span></span> Peek() <span class="type">int</span> &#123;</span><br><span class="line">    this.moveInputToOutput()</span><br><span class="line">    <span class="keyword">return</span> this.outputStack[<span class="built_in">len</span>(this.outputStack)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span></span> Empty() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(this.inputStack) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(this.outputStack) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 inputStack 中的所有元素移动到 outputStack，以便执行 FIFO 操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span></span> moveInputToOutput() &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.outputStack) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(this.inputStack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            this.outputStack = <span class="built_in">append</span>(this.outputStack, this.inputStack[<span class="built_in">len</span>(this.inputStack)<span class="number">-1</span>])</span><br><span class="line">            this.inputStack = this.inputStack[:<span class="built_in">len</span>(this.inputStack)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225 用队列实现栈"></a>225 用队列实现栈</h2><h3 id="【题目描述】-3"><a href="#【题目描述】-3" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>使用队列实现栈的下列操作：</p><ul><li>push(x) – 元素 x 入栈</li><li>pop() – 移除栈顶元素</li><li>top() – 获取栈顶元素</li><li>empty() – 返回栈是否为空</li></ul><p>注意:</p><ul><li>你只能使用队列的基本操作– 也就是 push to back, peek&#x2F;pop from front, size, 和 is empty 这些操作是合法的。</li><li>你所使用的语言可能不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li><li>你可以假设所有操作都是有效的 （例如, 对一个空的栈不会调用 pop 或者 top 操作）。</li></ul><h3 id="【解题思路】-3"><a href="#【解题思路】-3" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>要用队列实现一个后进先出（LIFO）的栈，我们可以使用两个队列：一个主队列（<code>mainQueue</code>）用于存储栈内的元素，另一个辅助队列（<code>helperQueue</code>）用于操作时的元素转移。</p><ul><li><strong>Push 操作</strong>：直接将元素加入到 <code>mainQueue</code>，因为队列是先进先出（FIFO），我们不需要做其他操作。</li><li><strong>Pop 操作</strong>：需要移除栈顶元素，即 <code>mainQueue</code> 的最后一个元素。为此，我们将 <code>mainQueue</code> 中除最后一个元素外的所有元素移动到 <code>helperQueue</code>，然后移除 <code>mainQueue</code> 中的最后一个元素（此时 <code>mainQueue</code> 为空），最后交换 <code>mainQueue</code> 和 <code>helperQueue</code>。这样，下次进行 pop 或 top 操作时，新的栈顶元素就在 <code>mainQueue</code> 的前端了。</li><li><strong>Top 操作</strong>：类似于 pop 操作，但是我们需要返回 <code>mainQueue</code> 最后一个元素的值，而不是移除它。</li><li><strong>Empty 操作</strong>：检查 <code>mainQueue</code> 是否为空即可。</li></ul><p>这个方法的关键在于使用辅助队列在每次 pop 和 top 操作时重新排序，确保栈顶元素总是可以通过 <code>mainQueue</code> 的 front 访问。</p><h3 id="【实现代码】-3"><a href="#【实现代码】-3" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyStack <span class="keyword">struct</span> &#123;</span><br><span class="line">queue1 []<span class="type">int</span></span><br><span class="line">queue2 []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> MyStack &#123;</span><br><span class="line"><span class="keyword">return</span> MyStack&#123;</span><br><span class="line">queue1: []<span class="type">int</span>&#123;&#125;,</span><br><span class="line">queue2: []<span class="type">int</span>&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyStack)</span></span> Push(x <span class="type">int</span>) &#123;</span><br><span class="line">this.queue1 = <span class="built_in">append</span>(this.queue1, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyStack)</span></span> Pop() <span class="type">int</span> &#123;</span><br><span class="line">this.move()</span><br><span class="line">v := this.queue1[<span class="number">0</span>]</span><br><span class="line">this.queue1 = []<span class="type">int</span>&#123;&#125;</span><br><span class="line">this.queue1, this.queue2 = this.queue2, this.queue1</span><br><span class="line"><span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyStack)</span></span> Top() <span class="type">int</span> &#123;</span><br><span class="line">this.move()</span><br><span class="line"><span class="keyword">return</span> this.queue1[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyStack)</span></span> Empty() <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(this.queue1) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(this.queue2) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyStack)</span></span> move() &#123;</span><br><span class="line"><span class="comment">//queue1中保留一个元素，用于top，peak</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(this.queue1) &gt; <span class="number">1</span> &#123;</span><br><span class="line">this.queue2 = <span class="built_in">append</span>(this.queue2, this.queue1[<span class="number">0</span>])</span><br><span class="line">this.queue1 = this.queue1[<span class="number">1</span>:]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20 有效的括号"></a>20 有效的括号</h2><h3 id="【题目描述】-4"><a href="#【题目描述】-4" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个只包括 <code>&#39;(&#39;，&#39;)&#39;，&#39;&#123;&#39;，&#39;&#125;&#39;，&#39;[&#39;，&#39;]&#39;</code> 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>注意空字符串可被认为是有效字符串。</li></ol><h3 id="【解题思路】-4"><a href="#【解题思路】-4" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这道题的关键在于如何检测括号的匹配顺序。一种高效的方法是使用栈的数据结构。栈具有后进先出（LIFO）的特性，这对于跟踪括号是否有效是非常有用的。</p><p>具体步骤如下：</p><ol><li>遍历给定的字符串中的每一个字符。</li><li>当遇到一个左括号时，将其推入栈中。</li><li>当遇到一个右括号时，检查栈顶元素是否是对应的左括号：<ul><li>如果是，从栈中弹出栈顶元素，继续检查下一个字符。</li><li>如果不是，或者栈为空（无法匹配当前右括号），那么字符串不是有效的括号序列。</li></ul></li><li>最后，如果栈为空，则所有括号都有效匹配；如果栈中仍有元素，则表示有未匹配的左括号，因此字符串不是有效的括号序列。</li></ol><h3 id="【实现代码】-4"><a href="#【实现代码】-4" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 使用map存储括号对应关系，方便查找</span></span><br><span class="line">    bracketMap := <span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">rune</span>&#123;<span class="string">&#x27;)&#x27;</span>: <span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;&#125;&#x27;</span>: <span class="string">&#x27;&#123;&#x27;</span>, <span class="string">&#x27;]&#x27;</span>: <span class="string">&#x27;[&#x27;</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> stack []<span class="type">rune</span> <span class="comment">// 使用切片作为栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, char := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="comment">// 如果是右括号</span></span><br><span class="line">        <span class="keyword">if</span> _, exists := bracketMap[char]; exists &#123;</span><br><span class="line">            <span class="comment">// 如果栈为空或者栈顶元素与当前右括号不匹配</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span> || stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] != bracketMap[char] &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 匹配成功，弹出栈顶元素</span></span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果是左括号，推入栈中</span></span><br><span class="line">            stack = <span class="built_in">append</span>(stack, char)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果栈为空，说明所有括号都成功匹配</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(stack) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047 删除字符串中的所有相邻重复项"></a>1047 删除字符串中的所有相邻重复项</h2><h3 id="【题目描述】-5"><a href="#【题目描述】-5" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给出由小写字母组成的字符串 <code>S</code>，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p><p>在 <code>S</code> 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p><h3 id="【解题思路】-5"><a href="#【解题思路】-5" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题可以通过栈的数据结构来高效解决。基本思路是遍历字符串中的每个字符，对每个字符执行以下操作：</p><ol><li>如果栈不为空，并且当前字符与栈顶字符相同，则这两个字符都需要被删除。这可以通过弹出栈顶字符来实现。</li><li>如果栈为空，或者当前字符与栈顶字符不同，则将当前字符推入栈中。</li></ol><p>遍历完成后，栈中剩下的字符就是删除所有相邻重复项后的结果。我们只需要将栈中的字符拼接起来即可得到最终答案。</p><h3 id="【实现代码】-5"><a href="#【实现代码】-5" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicates</span><span class="params">(S <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stack []<span class="type">rune</span> <span class="comment">// 使用切片模拟栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, char := <span class="keyword">range</span> S &#123;</span><br><span class="line">        <span class="comment">// 如果栈不为空且当前字符与栈顶字符相同，则弹出栈顶字符（删除两个相邻重复字符）</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &amp;&amp; stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] == char &#123;</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，将当前字符推入栈中</span></span><br><span class="line">            stack = <span class="built_in">append</span>(stack, char)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将栈中剩余的字符拼接起来，得到最终结果</span></span><br><span class="line">    result := <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> _, char := <span class="keyword">range</span> stack &#123;</span><br><span class="line">        result += <span class="type">string</span>(char)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150 逆波兰表达式求值"></a>150 逆波兰表达式求值</h2><h3 id="【题目描述】-6"><a href="#【题目描述】-6" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>根据逆波兰表示法，求表达式的值。</p><p>有效的运算符包括 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><p>说明：</p><ul><li>整数除法只保留整数部分。</li><li>给定逆波兰表达式总是有效的。换句话说，表达式总会得出一个结果，并且不会有任何除以零的操作。</li></ul><h3 id="【解题思路】-6"><a href="#【解题思路】-6" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>逆波兰表达式（也称后缀表达式）的求值可以通过使用栈这一数据结构来实现。基本思路是：</p><ol><li>创建一个栈来存储整数。</li><li>遍历每个元素：<ul><li>如果遇到一个数，就将它推入栈中。</li><li>如果遇到一个运算符，则从栈中弹出两个数，先弹出的数作为右操作数，后弹出的数作为左操作数，进行运算后，将结果再推回栈中。</li></ul></li><li>遍历结束后，栈顶元素就是表达式的结果。</li></ol><h3 id="【实现代码】-6"><a href="#【实现代码】-6" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;strconv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evalRPN</span><span class="params">(tokens []<span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stack []<span class="type">int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, token := <span class="keyword">range</span> tokens &#123;</span><br><span class="line">        <span class="keyword">switch</span> token &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>, <span class="string">&quot;-&quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="string">&quot;/&quot;</span>:</span><br><span class="line">            <span class="comment">// 弹出栈顶的两个元素</span></span><br><span class="line">            right, left := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>], stack[<span class="built_in">len</span>(stack)<span class="number">-2</span>]</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-2</span>] <span class="comment">// 更新栈</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 进行运算并将结果推回栈中</span></span><br><span class="line">            result := <span class="number">0</span></span><br><span class="line">            <span class="keyword">switch</span> token &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                result = left + right</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                result = left - right</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                result = left * right</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                result = left / right</span><br><span class="line">            &#125;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, result)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// 如果是数，将其转换为整数并推入栈中</span></span><br><span class="line">            num, _ := strconv.Atoi(token)</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, num)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 栈顶元素即为最终结果</span></span><br><span class="line">    <span class="keyword">return</span> stack[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239 滑动窗口最大值"></a>239 滑动窗口最大值</h2><h3 id="【题目描述】-7"><a href="#【题目描述】-7" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左端移动到数组的最右端。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。返回滑动窗口中的最大值。</p><h3 id="【解题思路】-7"><a href="#【解题思路】-7" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>解决这个问题的关键是如何在每次窗口移动时，有效地找到当前窗口的最大值。一个直观的方法是每次窗口移动时，遍历窗口中的所有元素来找最大值，但这种方法的时间复杂度较高。</p><p>一个更高效的方法是使用双端队列（Deque）来维护窗口内的最大值，使得时间复杂度降低。双端队列能够从两端以常数时间插入或删除元素。</p><p>具体步骤如下：</p><ol><li>使用一个双端队列存储元素的索引，队列中的第一个元素是当前窗口的最大值的索引。</li><li>遍历数组 <code>nums</code>，对于每个元素，做以下操作：<ul><li>首先，移除所有小于当前元素 <code>nums[i]</code> 的元素的索引，因为它们不可能是窗口的最大值。</li><li>然后，如果队列的头部元素（当前最大值的索引）已经不在窗口内（索引小于 <code>i-k+1</code>），就将其从队列中移除。</li><li>将当前元素的索引添加到队列的末尾。</li><li>如果已经遍历到第 <code>k</code> 个元素（<code>i ≥ k-1</code>），将当前窗口的最大值（队列头部元素对应的值）添加到结果数组中。</li></ul></li><li>返回结果数组。<br><img src="https://code-thinking.cdn.bcebos.com/gifs/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-2.gif"></li></ol><h3 id="【实现代码】-7"><a href="#【实现代码】-7" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先，我们需要定义一个双端队列（deque）来存储窗口内的元素下标。队列中的元素按照从大到小的顺序排列，保证队头元素是当前窗口中的最大值。</span></span><br><span class="line"><span class="comment">// 然后，我们遍历整个数组。在遍历过程中，我们需要维护以下规则：</span></span><br><span class="line"><span class="comment">// 如果队列不为空且当前元素大于等于队尾元素，我们将队尾元素出队，直到队列为空或者当前元素小于队尾元素。</span></span><br><span class="line"><span class="comment">// 将当前元素的下标入队。</span></span><br><span class="line"><span class="comment">// 在遍历过程中，我们需要判断当前窗口是否已经形成。如果窗口的左边界大于等于k-1，我们可以将队头元素加入结果数组中。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSlidingWindow</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">res := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">deque := []<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="comment">//找出前卡个元素</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(deque) &gt; <span class="number">0</span> &amp;&amp; deque[<span class="built_in">len</span>(deque)<span class="number">-1</span>] &lt; nums[i] &#123;</span><br><span class="line">deque = deque[:<span class="built_in">len</span>(deque)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">deque = <span class="built_in">append</span>(deque, nums[i])</span><br><span class="line">&#125;</span><br><span class="line">res = <span class="built_in">append</span>(res, deque[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j := k; j &lt; <span class="built_in">len</span>(nums); j++ &#123;</span><br><span class="line"><span class="comment">//如果队列的头部元素（当前最大值的索引）已经不在窗口内（索引小于 `i-k+1`），就将其从队列中移除。</span></span><br><span class="line"><span class="keyword">if</span> nums[j-k] == deque[<span class="number">0</span>] &#123;</span><br><span class="line">deque = deque[<span class="number">1</span>:]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(deque) &gt; <span class="number">0</span> &amp;&amp; deque[<span class="built_in">len</span>(deque)<span class="number">-1</span>] &lt; nums[j] &#123;</span><br><span class="line">deque = deque[:<span class="built_in">len</span>(deque)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">deque = <span class="built_in">append</span>(deque, nums[j])</span><br><span class="line">res = <span class="built_in">append</span>(res, deque[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347 前 K 个高频元素"></a>347 前 K 个高频元素</h2><h3 id="【题目描述】-8"><a href="#【题目描述】-8" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。</p><h3 id="【解题思路】-8"><a href="#【解题思路】-8" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题可以使用哈希表和优先队列（最小堆）来解决。</p><p>首先，我们可以使用哈希表来统计每个元素在数组中出现的频率。哈希表的键为元素，值为该元素出现的次数。</p><p>然后，我们可以使用优先队列（最小堆）来存储前 k 个高频元素。我们遍历哈希表中的所有键值对，对于每个键值对，如果优先队列的大小小于 k，我们就将该键值对直接加入优先队列。如果优先队列的大小等于 k，我们比较当前键值对的值和优先队列顶部键值对的值，如果当前键值对的值大于优先队列顶部的值，我们就将顶部的键值对移除，并将当前键值对加入优先队列。</p><p>最后，优先队列中剩下的就是前 k 个高频元素。我们将优先队列中的元素转换为数组并返回即可。</p><h3 id="【实现代码】-8"><a href="#【实现代码】-8" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">topKFrequent</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">type</span> Pair <span class="keyword">struct</span> &#123;</span><br><span class="line">Val       <span class="type">int</span></span><br><span class="line">Frequency <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//统计</span></span><br><span class="line">mp := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">mp[num]++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存在pairlist中</span></span><br><span class="line">pairList := []Pair&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> mp &#123;</span><br><span class="line">pairList = <span class="built_in">append</span>(pairList, Pair&#123;k, v&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line">heap := <span class="built_in">make</span>([]Pair, k)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">heap[i] = pairList[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> shifdown <span class="function"><span class="keyword">func</span><span class="params">(heap []Pair, i, n <span class="type">int</span>)</span></span></span><br><span class="line">shifdown = <span class="function"><span class="keyword">func</span><span class="params">(heap []Pair, i, n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">l, r := <span class="number">2</span>*i+<span class="number">1</span>, <span class="number">2</span>*i+<span class="number">2</span></span><br><span class="line">min := i</span><br><span class="line"><span class="comment">//heap[min].Frequency 中的是heap[min].Frequency， 不是heap[i].Frequency</span></span><br><span class="line"><span class="comment">//因为要找左右子节点中最小的</span></span><br><span class="line"><span class="keyword">if</span> l &lt; n &amp;&amp; heap[l].Frequency &lt; heap[min].Frequency &#123;</span><br><span class="line">min = l</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> r &lt; n &amp;&amp; heap[r].Frequency &lt; heap[min].Frequency &#123;</span><br><span class="line">min = r</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> min != i &#123;</span><br><span class="line">heap[i], heap[min] = heap[min], heap[i]</span><br><span class="line">shifdown(heap, min, n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := k/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">shifdown(heap, i, k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j := k; j &lt; <span class="built_in">len</span>(pairList); j++ &#123;</span><br><span class="line"><span class="keyword">if</span> pairList[j].Frequency &gt; heap[<span class="number">0</span>].Frequency &#123;</span><br><span class="line">heap[<span class="number">0</span>] = pairList[j]</span><br><span class="line">shifdown(heap, <span class="number">0</span>, k)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">res := []<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, heap[i].Val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="71-简化路径"><a href="#71-简化路径" class="headerlink" title="71 简化路径"></a>71 简化路径</h2><h3 id="【题目描述】-9"><a href="#【题目描述】-9" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。</p><p>在 Unix 风格的文件系统中，一个点（<code>.</code>）表示当前目录本身；此外，两个点 （<code>..</code>） 表示将目录切换到上一级（指向父目录）；两者都可以是复合路径的一部分。任意多个连续的斜杠（即，<code>&#39;//&#39;</code>）都被视为单个斜杠 <code>&#39;/&#39;</code>。对于此问题，任何其他格式的点（例如，<code>&#39;...&#39;</code>）都被视为文件&#x2F;目录名称。</p><p>请注意，返回的规范路径必须始终以斜杠 <code>&#39;/&#39;</code> 开头，并且两个目录名之间必须只有一个斜杠 <code>&#39;/&#39;</code>。最后一个目录名（如果存在）不能以 <code>&#39;/&#39;</code> 结束。此外，规范路径必须是表示绝对路径的最短字符串。</p><h3 id="【解题思路】-9"><a href="#【解题思路】-9" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><ol><li><strong>分割路径</strong>: 首先，我们需要根据斜杠 <code>&#39;/&#39;</code> 分割给定的路径，从而得到构成路径的各个部分。</li><li><strong>使用栈处理路径</strong>: 接着，我们可以使用一个栈来处理路径。遍历分割后的路径部分，对于每个部分：<ul><li>如果是 <code>&#39;..&#39;</code>，则表示需要返回上级目录，此时如果栈不为空，我们就弹出栈顶元素。</li><li>如果是 <code>&#39;.&#39;</code> 或者是空字符串（即连续的斜杠情况），我们不做任何操作。</li><li>如果是其他字符串，则表示是目录名，我们将其压入栈中。</li></ul></li><li><strong>构建简化后的路径</strong>: 最后，我们将栈中的元素连接起来，每个元素之间用斜杠 <code>&#39;/&#39;</code> 分隔，并在最前面加上 <code>&#39;/&#39;</code>，构成简化后的路径。</li></ol><h3 id="【实现代码】-9"><a href="#【实现代码】-9" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">simplifyPath</span><span class="params">(path <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="comment">// 分割路径</span></span><br><span class="line">parts := strings.Split(path, <span class="string">&quot;/&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> stack []<span class="type">string</span> <span class="comment">// 使用切片作为栈</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, part := <span class="keyword">range</span> parts &#123;</span><br><span class="line"><span class="keyword">switch</span> part &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;..&quot;</span>:</span><br><span class="line"><span class="comment">// 弹出栈顶元素（返回上级目录）</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;.&quot;</span>, <span class="string">&quot;&quot;</span>:</span><br><span class="line"><span class="comment">// 不做任何操作</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// 将目录名压入栈</span></span><br><span class="line">stack = <span class="built_in">append</span>(stack, part)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构建简化后的路径</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;/&quot;</span> + strings.Join(stack, <span class="string">&quot;/&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215 数组中的第K个最大元素"></a>215 数组中的第K个最大元素</h2><h3 id="【题目描述】-10"><a href="#【题目描述】-10" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>在未排序的数组中找到第 k 个最大的元素。注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><h3 id="【解题思路】-10"><a href="#【解题思路】-10" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题可以通过多种方式解决，但最直观的方法可能是使用排序。首先，将数组排序，然后直接访问第 k 个最大元素。在 Go 语言中，我们可以使用内置的排序方法来完成这一任务。然而，这种方法的时间复杂度是 O(NlogN)，其中 N 是数组的长度。</p><p>更高效的方法是使用堆排序或快速选择算法。这里，我将采用快速选择算法，它是快速排序算法的一个变体，可以在平均情况下以 O(N) 的时间复杂度找到第 k 个最大元素。快速选择算法的基本思想是随机选择一个元素作为枢轴，然后将数组分成两部分：一部分包含所有大于枢轴的元素，另一部分包含所有小于或等于枢轴的元素。这样，枢轴的最终位置就是它在排序数组中的确切位置。因此，我们可以比较枢轴的位置和 k 的大小，以决定是继续在左侧数组中查找，还是在右侧数组中查找。</p><h3 id="【实现代码】-10"><a href="#【实现代码】-10" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//堆思路</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthLargest</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(nums)</span><br><span class="line"><span class="comment">// 使用堆排序实现</span></span><br><span class="line">heap := <span class="built_in">make</span>([]<span class="type">int</span>, k)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">heap[i] = nums[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非叶子节点 shiftdown</span></span><br><span class="line">i := n/<span class="number">2</span> - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> ; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">shiftdown(heap, i)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(heap)</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">for</span> i := k; i &lt; n; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums[i] &gt; heap[<span class="number">0</span>] &#123;</span><br><span class="line">heap[<span class="number">0</span>] = nums[i]</span><br><span class="line">shiftdown(heap, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> heap[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shiftdown</span><span class="params">(heap []<span class="type">int</span>, i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(heap)</span><br><span class="line"><span class="keyword">for</span> i &lt; n &#123;</span><br><span class="line">l, r := <span class="number">2</span>*i+<span class="number">1</span>, <span class="number">2</span>*i+<span class="number">2</span></span><br><span class="line">min := i</span><br><span class="line"><span class="keyword">if</span> l &lt; n &amp;&amp; heap[min] &gt; heap[l] &#123;</span><br><span class="line">min = l</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> r &lt; n &amp;&amp; heap[min] &gt; heap[r] &#123;</span><br><span class="line">min = r</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> i != min &#123;</span><br><span class="line">heap[i], heap[min] = heap[min], heap[i]</span><br><span class="line">i = min</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快排思路</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthLargest</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line"><span class="keyword">return</span> selectKth(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>, <span class="built_in">len</span>(nums)-k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectKth</span><span class="params">(nums []<span class="type">int</span>, left, right, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> left == right &#123;</span><br><span class="line"><span class="keyword">return</span> nums[left]</span><br><span class="line">&#125;</span><br><span class="line">pivotIndex := partition(nums, left, right)</span><br><span class="line"><span class="keyword">if</span> k == pivotIndex &#123;</span><br><span class="line"><span class="keyword">return</span> nums[k]</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> k &lt; pivotIndex &#123;</span><br><span class="line"><span class="keyword">return</span> selectKth(nums, left, pivotIndex<span class="number">-1</span>, k)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> selectKth(nums, pivotIndex+<span class="number">1</span>, right, k)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(nums []<span class="type">int</span>, left, right <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">pivotIndex := left + rand.Intn(right-left+<span class="number">1</span>)</span><br><span class="line">pivot := nums[pivotIndex]</span><br><span class="line">nums[pivotIndex], nums[right] = nums[right], nums[pivotIndex]</span><br><span class="line">storeIndex := left</span><br><span class="line"><span class="keyword">for</span> i := left; i &lt;= right; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums[i] &lt; pivot &#123;</span><br><span class="line">nums[storeIndex], nums[i] = nums[i], nums[storeIndex]</span><br><span class="line">storeIndex++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">nums[right], nums[storeIndex] = nums[storeIndex], nums[right]</span><br><span class="line"><span class="keyword">return</span> storeIndex</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="/2024/03/28/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2024/03/28/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="核心知识"><a href="#核心知识" class="headerlink" title="核心知识"></a>核心知识</h1><h2 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h2><ul><li>前序遍历（递归，迭代）</li><li>中序遍历（递归，迭代）</li><li>后序遍历（递归，迭代）</li><li>层序遍历（借助queue迭代）</li></ul><h3 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span></span> (res []<span class="type">int</span>) &#123;</span><br><span class="line">res := []<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> traverse <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span></span><br><span class="line">traverse = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span>&#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">res = <span class="built_in">append</span>(res, root.Val)</span><br><span class="line">traverse(root.Left)</span><br><span class="line">traverse(root.Right)</span><br><span class="line">&#125;</span><br><span class="line">traverse(root)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span></span> (res []<span class="type">int</span>) &#123;</span><br><span class="line">res := []<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> traverse <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span></span><br><span class="line">traverse = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span>&#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">traverse(root.Left)</span><br><span class="line">res = <span class="built_in">append</span>(res, root.Val)</span><br><span class="line">traverse(root.Right)</span><br><span class="line">&#125;</span><br><span class="line">traverse(root)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postorderTraversal</span><span class="params">(root *TreeNode)</span></span> (res []<span class="type">int</span>) &#123;</span><br><span class="line">res := []<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> traverse <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span></span><br><span class="line">traverse = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span>&#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">traverse(root.Left)</span><br><span class="line">traverse(root.Right)</span><br><span class="line">res = <span class="built_in">append</span>(res, root.Val)</span><br><span class="line">&#125;</span><br><span class="line">traverse(root)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代遍历"><a href="#迭代遍历" class="headerlink" title="迭代遍历"></a>迭代遍历</h3><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p><img src="https://code-thinking.cdn.bcebos.com/gifs/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89.gif"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">stack := []*TreeNode&#123;root&#125;</span><br><span class="line">res := []<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">node := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">res = <span class="built_in">append</span>(res, node.Val)</span><br><span class="line"><span class="comment">//入栈顺序是先如右节点，再入左节点</span></span><br><span class="line"><span class="comment">//因为栈是先进后出，右节点是后被返回，所以要先入栈</span></span><br><span class="line"><span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">stack = <span class="built_in">append</span>(stack, node.Right)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">stack = <span class="built_in">append</span>(stack, node.Left)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p><img src="https://code-thinking.cdn.bcebos.com/gifs/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89.gif"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">res := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">stack := [] *TreeNode&#123;&#125;</span><br><span class="line">cur := root</span><br><span class="line"><span class="keyword">for</span> cur != <span class="literal">nil</span> || <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">//一直遍历左节点知道左节点为空</span></span><br><span class="line"><span class="keyword">if</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">stack = <span class="built_in">append</span>(stack, cur)</span><br><span class="line">cur = cur.Left</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//此时左节点为空，弹出栈顶元素，将改zhi加入res中，并继续遍历他的右节点</span></span><br><span class="line">cur = stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">res = <span class="built_in">append</span>(res, cur.Val)</span><br><span class="line">cur = cur.Right</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>后续遍历的顺序是左右中，前序遍历的顺序是中左右，将前序的入栈顺序反过来，前序就成了中右左，再将res的结果翻转就行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postorderTraversal</span><span class="params">(root *TreeNode)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">res := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">stack := []*TreeNode&#123;root&#125;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">cur := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">res = <span class="built_in">append</span>(res ,cur.Val)</span><br><span class="line"><span class="keyword">if</span> cur.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">stack = <span class="built_in">append</span>(stack, cur.Left)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> cur.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">stack = <span class="built_in">append</span>(stack, cur.Right)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">i,j:=<span class="number">0</span>,<span class="built_in">len</span>(res)<span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> i&lt;=j &#123;</span><br><span class="line">res[i],res[j] = res[j],res[i]</span><br><span class="line">i++</span><br><span class="line">j--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> results [][]<span class="type">int</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> results</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    queue := []*TreeNode&#123;root&#125;  <span class="comment">// 初始化队列，首先加入根节点</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        levelSize := <span class="built_in">len</span>(queue) <span class="comment">// 当前层的节点数量</span></span><br><span class="line">        <span class="keyword">var</span> currentLevel []<span class="type">int</span>  <span class="comment">// 当前层的结果</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; levelSize; i++ &#123; <span class="comment">// 遍历当前层的所有节点</span></span><br><span class="line">            node := queue[<span class="number">0</span>] <span class="comment">// 取出队列的第一个元素</span></span><br><span class="line">            queue = queue[<span class="number">1</span>:] <span class="comment">// 更新队列</span></span><br><span class="line">            currentLevel = <span class="built_in">append</span>(currentLevel, node.Val) <span class="comment">// 将当前节点的值加入到当前层结果中</span></span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123; <span class="comment">// 如果左子节点存在，加入队列</span></span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123; <span class="comment">// 如果右子节点存在，加入队列</span></span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        results = <span class="built_in">append</span>(results, currentLevel) <span class="comment">// 将当前层的结果加入到最终结果中</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>二叉搜索树是有序的，使用中序遍历，通常需要使用prev变量辅助，在在处理根节点后将prev&#x3D;root</p><h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124 二叉树中的最大路径和"></a>124 二叉树中的最大路径和</h2><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你一个二叉树的根节点 <code>root</code>，返回其节点值的最大路径和。</p><p>路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3]</span><br><span class="line">输出：6</span><br><span class="line">解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [-10,9,20,null,null,15,7]</span><br><span class="line">输出：42</span><br><span class="line">解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42</span><br></pre></td></tr></table></figure><h3 id="【解题思路】"><a href="#【解题思路】" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题可以通过递归来解决。我们需要计算两个值：</p><ol><li>当前子树内部的最大路径和（不需要返回给父节点的）。</li><li>提供给父节点的最大路径和（即从当前节点出发，最大可以贡献多少到父节点的路径和）。</li></ol><p>步骤如下：</p><ol><li>递归地计算左右子树可以提供给当前节点的最大路径和。</li><li>对于每个节点，考虑通过该节点的最大路径和可以是：<ul><li>仅包含该节点自身。</li><li>节点自身加上左子树提供的最大路径和。</li><li>节点自身加上右子树提供的最大路径和。</li><li>节点自身加上左右子树提供的最大路径和（此时，该路径不会返回给父节点，但可以更新全局的最大路径和）。</li></ul></li><li>使用一个全局变量记录遍历过程中找到的最大路径和，递归完成后，该变量即为所求。</li></ol><h3 id="【实现代码】"><a href="#【实现代码】" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxPathSum</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    maxSum := math.MinInt32</span><br><span class="line">    <span class="keyword">var</span> maxGain <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> <span class="type">int</span></span><br><span class="line">    maxGain = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归计算左右子树的最大贡献值，只有在贡献值大于0时才会选择该子树</span></span><br><span class="line">        leftGain := max(<span class="number">0</span>, maxGain(node.Left))</span><br><span class="line">        rightGain := max(<span class="number">0</span>, maxGain(node.Right))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 节点的最大路径和取决于该节点的值与其左右子树的最大贡献值</span></span><br><span class="line">        priceNewpath := node.Val + leftGain + rightGain</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新答案</span></span><br><span class="line">        maxSum = max(maxSum, priceNewpath)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回节点的最大贡献值</span></span><br><span class="line">        <span class="keyword">return</span> node.Val + max(leftGain, rightGain)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    maxGain(root)</span><br><span class="line">    <span class="keyword">return</span> maxSum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="103-二叉树的锯齿形层次遍历"><a href="#103-二叉树的锯齿形层次遍历" class="headerlink" title="103 二叉树的锯齿形层次遍历"></a>103 二叉树的锯齿形层次遍历</h2><h3 id="【题目描述】-1"><a href="#【题目描述】-1" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个二叉树，返回其节点值的锯齿形层次遍历（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p>例如：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回锯齿形层次遍历如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="【解题思路】-1"><a href="#【解题思路】-1" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><ol><li>使用广度优先搜索（BFS）遍历树的每一层。</li><li>使用一个队列来实现BFS，并记录当前层级以确定节点添加的顺序。</li><li>如果是偶数层（从0开始计数），则按照从左到右的顺序添加节点值；如果是奇数层，则按照从右到左的顺序添加节点值。</li><li>利用一个变量<code>zigzag</code>来标记当前层的遍历方向，每遍历完一层后改变其方向。</li></ol><h3 id="【实现代码】-1"><a href="#【实现代码】-1" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zigzagLevelOrder</span><span class="params">(root *TreeNode)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    queue := []*TreeNode&#123;root&#125;</span><br><span class="line">    zigzag := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        levelSize := <span class="built_in">len</span>(queue)</span><br><span class="line">        currentLevel := <span class="built_in">make</span>([]<span class="type">int</span>, levelSize)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; levelSize; i++ &#123;</span><br><span class="line">            currentNode := queue[<span class="number">0</span>]</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">            index := i</span><br><span class="line">            <span class="keyword">if</span> zigzag &#123;</span><br><span class="line">                index = levelSize - <span class="number">1</span> - i</span><br><span class="line">            &#125;</span><br><span class="line">            currentLevel[index] = currentNode.Val</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> currentNode.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, currentNode.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> currentNode.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, currentNode.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result = <span class="built_in">append</span>(result, currentLevel)</span><br><span class="line">        zigzag = !zigzag</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104 二叉树的最大深度"></a>104 二叉树的最大深度</h2><h3 id="【题目描述】-2"><a href="#【题目描述】-2" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个二叉树，找出其最大深度。最大深度是从根节点到最远叶子节点的最长路径上的节点数量。说明: 叶子节点是指没有子节点的节点。</p><h3 id="【解题思路】-2"><a href="#【解题思路】-2" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>解决这个问题，我们可以使用深度优先搜索（DFS）的方法。通过递归地检查每个节点，我们可以找到从根节点到叶子节点的最长路径。具体步骤如下：</p><ol><li>若当前节点为<code>nil</code>（空节点），则深度为0，返回0。</li><li>递归地计算左子树的最大深度<code>leftDepth</code>和右子树的最大深度<code>rightDepth</code>。</li><li>当前节点的最大深度为左、右子树的最大深度的最大值加1（加1表示加上当前节点本身）。</li></ol><p>这种方法的核心思想在于，它从底向上地计算每个节点的深度，直到达到最大深度。</p><h3 id="【实现代码】-2"><a href="#【实现代码】-2" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// TreeNode 定义二叉树的节点</span></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// maxDepth 计算二叉树的最大深度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="comment">// 空树的深度为0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归地计算左右子树的深度</span></span><br><span class="line">    leftDepth := maxDepth(root.Left)</span><br><span class="line">    rightDepth := maxDepth(root.Right)</span><br><span class="line">    <span class="comment">// 返回较大的深度并加1（当前节点的深度）</span></span><br><span class="line">    <span class="keyword">if</span> leftDepth &gt; rightDepth &#123;</span><br><span class="line">        <span class="keyword">return</span> leftDepth + <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rightDepth + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//bfs</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue := []*TreeNode&#123;root&#125;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span>&#123;</span><br><span class="line">        n:=<span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;n;i++ &#123;</span><br><span class="line">            cur := queue[<span class="number">0</span>]</span><br><span class="line">            queue= queue[<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> cur.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, cur.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> cur.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, cur.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res++</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111 二叉树的最小深度"></a>111 二叉树的最小深度</h2><h3 id="【题目描述】-3"><a href="#【题目描述】-3" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。说明：叶子节点是指没有子节点的节点。</p><h3 id="【解题思路】-3"><a href="#【解题思路】-3" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>解决这个问题，我们可以使用深度优先搜索（DFS）或广度优先搜索（BFS）。</p><p><strong>深度优先搜索（DFS）方法</strong>： 递归地计算左子树和右子树的最小深度。对于每一个非叶子节点，我们只需要关心其子树的最小深度。有几点需要注意：</p><ul><li>如果一个节点的左子树为空，则返回右子树的最小深度 + 1。</li><li>如果一个节点的右子树为空，则返回左子树的最小深度 + 1。</li><li>如果左右子树都不为空，则返回左、右子树的最小深度的最小值 + 1。</li></ul><p>这个方法的核心思想是递归地求解子问题，并从底向上返回最小深度。</p><p><strong>广度优先搜索（BFS）方法</strong>： 我们按层次遍历树，当我们遇到第一个叶子节点时，停止遍历并返回该叶子节点所在层数，这个层数就是树的最小深度。这种方法的好处是一旦找到一个叶子节点就可以停止遍历，而不需要遍历整棵树。</p><p>这里，我们选择深度优先搜索（DFS）方法来实现，因为它相对直观，容易理解。</p><h3 id="【实现代码】-3"><a href="#【实现代码】-3" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// TreeNode 代表二叉树的节点</span></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// minDepth 用于计算二叉树的最小深度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minDepth</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果左子树为空，递归计算右子树的最小深度并加一</span></span><br><span class="line">    <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minDepth(root.Right) + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果右子树为空，递归计算左子树的最小深度并加一</span></span><br><span class="line">    <span class="keyword">if</span> root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minDepth(root.Left) + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果左右子树都不为空，分别递归计算左右子树的最小深度，取最小值并加一</span></span><br><span class="line">    <span class="keyword">return</span> min(minDepth(root.Left), minDepth(root.Right)) + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// min 用于计算两个整数的最小值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//bfs</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minDepth</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">queue := []*TreeNode&#123;root&#125;</span><br><span class="line">res := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(queue)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;n;i++ &#123;</span><br><span class="line">cur := queue[<span class="number">0</span>]</span><br><span class="line">queue =queue[<span class="number">1</span>:]</span><br><span class="line"><span class="comment">//说明到了叶子节点， 直接返回</span></span><br><span class="line"><span class="keyword">if</span> cur.Left == <span class="literal">nil</span> &amp;&amp; cur.Right == <span class="literal">nil</span>&#123;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> cur.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">queue = <span class="built_in">append</span>(queue, cur.Left)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> cur.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">queue = <span class="built_in">append</span>(queue, cur.Right)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">res++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226 翻转二叉树"></a>226 翻转二叉树</h2><h3 id="【题目描述】-4"><a href="#【题目描述】-4" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>翻转一棵二叉树。</p><p>示例：</p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  2     7</span><br><span class="line"> / \   / \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  7     2</span><br><span class="line"> / \   / \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure><h3 id="【解题思路】-4"><a href="#【解题思路】-4" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>翻转一棵二叉树的基本思想是遍历树中的每个节点，并交换每个节点的左右子节点。这个过程可以通过递归或迭代（使用队列）来实现。这里我们使用递归的方法，因为它更简洁易懂。</p><ol><li><strong>递归函数的定义</strong>：定义一个递归函数，它接受一个节点作为参数，将该节点的左右子树翻转，并返回翻转后的节点。</li><li><strong>递归的终止条件</strong>：如果当前节点为空，说明已经到达叶子节点的下一层，直接返回null。</li><li><strong>递归的过程</strong>：对当前节点的左子节点和右子节点分别调用递归函数，然后将两个返回的节点交换位置，最后返回当前节点。</li></ol><p>通过这个递归过程，我们可以实现从上到下，从根节点到叶子节点的完全翻转。</p><h3 id="【实现代码】-4"><a href="#【实现代码】-4" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// TreeNode 定义二叉树的节点</span></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dfs</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">invertTree</span><span class="params">(root *TreeNode)</span></span> *TreeNode &#123;</span><br><span class="line"><span class="keyword">var</span> traverse <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span>*TreeNode </span><br><span class="line">traverse = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span>*TreeNode &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line">left := traverse(root.Left)</span><br><span class="line">right := traverse(root.Right)</span><br><span class="line">root.Left = right</span><br><span class="line">root.Right = left</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> traverse(root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//bfs</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">invertTree</span><span class="params">(root *TreeNode)</span></span> *TreeNode &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line">queue := []*TreeNode&#123;root&#125;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(queue)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;n;i++ &#123;</span><br><span class="line">cur := queue[<span class="number">0</span>]</span><br><span class="line">queue = queue[<span class="number">1</span>:]</span><br><span class="line">cur.Left , cur.Right = cur.Right, cur.Left</span><br><span class="line"><span class="keyword">if</span> cur.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">queue = <span class="built_in">append</span>(queue, cur.Left)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> cur.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">queue = <span class="built_in">append</span>(queue, cur.Right)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101 对称二叉树"></a>101 对称二叉树</h2><h3 id="【题目描述】-5"><a href="#【题目描述】-5" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个二叉树，检查它是否是镜像对称的。即，二叉树与它的镜像（左右反转）相同。</p><p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure><p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure><h3 id="【解题思路】-5"><a href="#【解题思路】-5" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>要判断一个二叉树是否是对称的，我们可以采用递归的方法。对于树中任意两个对称节点，它们的值相等，且一个节点的左子节点与另一个节点的右子节点对称，一个节点的右子节点与另一个节点的左子节点对称。</p><ol><li><strong>递归函数的定义</strong>：定义一个递归函数<code>isMirror</code>，它接受两个节点作为参数，如果这两个节点对称，则返回<code>true</code>，否则返回<code>false</code>。</li><li><strong>递归的终止条件</strong>：如果两个节点都为空，则它们对称；如果只有一个节点为空，或者两个节点的值不相等，则它们不对称。</li><li><strong>递归的过程</strong>：对于两个节点<code>left</code>和<code>right</code>，判断<code>left</code>的左子节点与<code>right</code>的右子节点是否对称，以及<code>left</code>的右子节点与<code>right</code>的左子节点是否对称。</li></ol><p>最后，调用这个递归函数，以根节点的左右子节点为参数开始判断。</p><h3 id="【实现代码】-5"><a href="#【实现代码】-5" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// TreeNode 定义二叉树的节点</span></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dfs</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSymmetric</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">var</span> traverse <span class="function"><span class="keyword">func</span><span class="params">(left, right *TreeNode)</span></span> <span class="type">bool</span></span><br><span class="line">traverse = <span class="function"><span class="keyword">func</span><span class="params">(left, right *TreeNode)</span></span> <span class="type">bool</span>&#123;</span><br><span class="line"><span class="comment">//左右为空</span></span><br><span class="line"><span class="keyword">if</span> left == <span class="literal">nil</span> &amp;&amp; right == <span class="literal">nil</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//左右都不为空</span></span><br><span class="line"><span class="keyword">if</span> left != <span class="literal">nil</span> &amp;&amp; right != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> left.Val == right.Val &amp;&amp; traverse(left.Left, right.Right) &amp;&amp; traverse(left.Right, right.Left)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//左右有一个为空</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> traverse(root.Left, root.Right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//bfs</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSymmetric</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">queue := []*TreeNode&#123;root.Left, root.Right&#125;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">left, right := queue[<span class="number">0</span>],queue[<span class="number">1</span>]</span><br><span class="line">queue = queue[<span class="number">2</span>:]</span><br><span class="line"><span class="comment">//左右都为空</span></span><br><span class="line"><span class="keyword">if</span> left == <span class="literal">nil</span> &amp;&amp; right == <span class="literal">nil</span>&#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//left为空或right为空</span></span><br><span class="line"><span class="keyword">if</span> left == <span class="literal">nil</span> || right == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//左右都不为空</span></span><br><span class="line"><span class="keyword">if</span> left.Val != right.Val &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如队列</span></span><br><span class="line">queue = <span class="built_in">append</span>(queue, left.Left,right.Right, left.Right, right.Left)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110 平衡二叉树"></a>110 平衡二叉树</h2><h3 id="【题目描述】-6"><a href="#【题目描述】-6" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一棵二叉树，判断其是否是一个高度平衡的二叉树。一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1，则称这棵树为高度平衡的二叉树。</p><h3 id="【解题思路】-6"><a href="#【解题思路】-6" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>要判断一棵树是否是平衡二叉树，我们需要从底向上遍历这棵树的每一个节点，对于每一个节点，计算其左右子树的高度，如果左右子树的高度差的绝对值大于1，则整棵树不是平衡二叉树；如果每一个节点的左右子树的高度差的绝对值都不超过1，则这棵树是平衡二叉树。</p><p>我们可以定义一个递归函数来计算二叉树的高度，递归过程中一旦发现有子树不满足高度平衡的条件，立即返回一个特殊值（例如，-1）以避免进一步的递归，这样可以提高算法的效率。</p><h3 id="【实现代码】-6"><a href="#【实现代码】-6" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// TreeNode 定义二叉树的节点</span></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isBalanced</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="comment">//-1表示不平衡，其他的代表高度</span></span><br><span class="line"><span class="keyword">var</span> traverse <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span></span><br><span class="line">traverse = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">left := traverse(root.Left)</span><br><span class="line">right := traverse(root.Right)</span><br><span class="line"><span class="keyword">if</span> left == <span class="number">-1</span> || right == <span class="number">-1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> abs(left-right) &gt; <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max(left, right) + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> traverse(root) != <span class="number">-1</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// abs 计算绝对值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">abs</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// max 返回两个数中的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257 二叉树的所有路径"></a>257 二叉树的所有路径</h2><h3 id="【题目描述】-7"><a href="#【题目描述】-7" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p><p><strong>说明</strong>: 叶子节点是指没有子节点的节点。</p><p><strong>示例</strong>:</p><p>输入:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   1</span><br><span class="line"> /   \</span><br><span class="line">2     3</span><br><span class="line"> \</span><br><span class="line">  5</span><br></pre></td></tr></table></figure><p>输出: [“1-&gt;2-&gt;5”, “1-&gt;3”]</p><p>解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3。</p><h3 id="【解题思路】-7"><a href="#【解题思路】-7" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>解决这个问题的关键是使用深度优先搜索（DFS）遍历整棵树，并在遍历的过程中记录路径。当到达叶子节点时，将当前路径添加到结果列表中。</p><p>具体步骤如下：</p><ol><li><strong>递归函数的定义</strong>：定义一个辅助递归函数<code>dfs</code>，它接受当前节点<code>node</code>和当前路径<code>path</code>作为参数。每次递归调用时，将当前节点加入到路径中。</li><li><strong>递归的终止条件</strong>：当当前节点是叶子节点时，将当前路径加入到结果列表中，然后返回。</li><li><strong>递归的过程</strong>：如果当前节点不是叶子节点，对其左右子节点进行递归调用，继续向下搜索。</li></ol><h3 id="【实现代码】-7"><a href="#【实现代码】-7" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// TreeNode 定义二叉树的节点</span></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binaryTreePaths</span><span class="params">(root *TreeNode)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">res := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">path := []<span class="type">string</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> backtrack <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span></span><br><span class="line">backtrack = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//终止条件 叶结点</span></span><br><span class="line"><span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span>&#123;</span><br><span class="line">path = <span class="built_in">append</span>(path, strconv.Itoa(root.Val))</span><br><span class="line">res = <span class="built_in">append</span>(res, strings.Join(path, <span class="string">&quot;-&gt;&quot;</span>))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">path = <span class="built_in">append</span>(path, strconv.Itoa(root.Val))</span><br><span class="line"><span class="keyword">if</span> root.Left != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//递归和回溯是在一起的</span></span><br><span class="line">backtrack(root.Left)</span><br><span class="line">path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> root.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">backtrack(root.Right)</span><br><span class="line">path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">backtrack(root)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404 左叶子之和"></a>404 左叶子之和</h2><h3 id="【题目描述】-8"><a href="#【题目描述】-8" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>计算给定二叉树的所有左叶子之和。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>在这个例子中，有两个左叶子，分别是9和15，所以返回的和是24。</p><h3 id="【解题思路】-8"><a href="#【解题思路】-8" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>为了找到所有的左叶子节点并计算它们的和，我们可以采用递归的方式遍历整棵树。关键是要区分什么是左叶子节点：如果一个节点具有左子节点，且该左子节点不再有任何子节点，那么这个左子节点就是一个左叶子节点。</p><p>具体步骤如下：</p><ol><li><strong>递归函数的定义</strong>：定义一个辅助递归函数<code>dfs</code>，它接受当前节点<code>node</code>作为参数。每次递归调用时，检查当前节点的左子节点是否是左叶子，如果是，则将其值加到总和中。</li><li><strong>递归的终止条件</strong>：如果当前节点为空，则直接返回。</li><li><strong>递归的过程</strong>：对当前节点的左右子节点进行递归调用，累加左叶子的和。</li></ol><h3 id="【实现代码】-8"><a href="#【实现代码】-8" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// TreeNode 定义二叉树的节点</span></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sumOfLeftLeaves 计算所有左叶子之和</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumOfLeftLeaves</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">var</span> traverse <span class="function"><span class="keyword">func</span> <span class="params">(root *TreeNode)</span></span> </span><br><span class="line">res := <span class="number">0</span></span><br><span class="line">traverse = <span class="function"><span class="keyword">func</span> <span class="params">(root *TreeNode)</span></span>  &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//左叶子节点的判断依据是当前节点的左子树不为空，且左子树的左右孩子是空</span></span><br><span class="line"><span class="keyword">if</span> root.Left != <span class="literal">nil</span> &amp;&amp; root.Left.Left == <span class="literal">nil</span> &amp;&amp; root.Left.Right == <span class="literal">nil</span>&#123;</span><br><span class="line">res += root.Left.Val</span><br><span class="line">&#125;</span><br><span class="line">traverse(root.Left)</span><br><span class="line">traverse(root.Right)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">traverse(root)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513 找树左下角的值"></a>513 找树左下角的值</h2><h3 id="【题目描述】-9"><a href="#【题目描述】-9" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个二叉树，在树的最后一行找到最左边的值。</p><p><strong>示例 1:</strong></p><p>输入:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  2</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure><p>输出:<br>1</p><p><strong>示例 2:</strong></p><p>输入:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> /   / \</span><br><span class="line">4   5   6</span><br><span class="line">   /</span><br><span class="line">  7</span><br></pre></td></tr></table></figure><p>输出:<br>7</p><p><strong>注意:</strong> 您可以假设树（即给定的根节点）不为 NULL。</p><h3 id="【解题思路】-9"><a href="#【解题思路】-9" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>找到树最后一行最左边的值，可以使用广度优先搜索（BFS）遍历二叉树。我们按层遍历树，每次遍历一层节点，并记录这一层的第一个节点的值。当我们遍历到最后一层时，记录的就是最后一层最左边的值。</p><p>具体步骤如下：</p><ol><li>使用一个队列来支持BFS遍历，初始时将根节点入队。</li><li>当队列不为空时，进行以下操作：<ul><li>获取当前队列的长度，这个长度就是当前层的节点数量。</li><li>遍历这一层的节点，对于每个节点，先将其左子节点入队，再将其右子节点入队。</li><li>在遍历每层的第一个节点时，记录其值。因为按照左子节点先入队的顺序，该值就是当前层最左边的值。</li></ul></li><li>当遍历完成后，记录的值就是最后一行最左边的值。</li></ol><h3 id="【实现代码】-9"><a href="#【实现代码】-9" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;container/list&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TreeNode 定义二叉树节点</span></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//bfs 比较简单</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findBottomLeftValue</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">queue := []*TreeNode&#123;root&#125;</span><br><span class="line">res := root.Val</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(queue)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;n;i++ &#123;</span><br><span class="line">cur := queue[<span class="number">0</span>]</span><br><span class="line">queue = queue[<span class="number">1</span>:]</span><br><span class="line">res = cur.Val</span><br><span class="line"><span class="keyword">if</span> cur.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">queue = <span class="built_in">append</span>(queue, cur.Right)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> cur.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">queue = <span class="built_in">append</span>(queue, cur.Left)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//dfs</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findBottomLeftValue</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">res := root.Val</span><br><span class="line">maxDepth := <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> traverse <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode, curDepth <span class="type">int</span>)</span></span></span><br><span class="line">traverse = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode, curDepth <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> curDepth &gt; maxDepth &#123;</span><br><span class="line">maxDepth = curDepth</span><br><span class="line">res = root.Val</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(root.Left, curDepth+<span class="number">1</span>)</span><br><span class="line">traverse(root.Right, curDepth+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">traverse(root, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112 路径总和"></a>112 路径总和</h2><h3 id="【题目描述】-10"><a href="#【题目描述】-10" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>叶子节点是指没有子节点的节点。</p><p><strong>示例 1:</strong></p><p>输入：<code>root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22</code><br>输出：<code>true</code><br>解释：等于目标和的根节点到叶节点路径如上图所示。</p><p><strong>示例 2:</strong></p><p>输入：<code>root = [1,2,3], targetSum = 5</code><br>输出：<code>false</code><br>解释：树中存在两条根节点到叶子节点的路径：<br>(1 –&gt; 2) 总和为 3<br>(1 –&gt; 3) 总和为 4<br>不存在总和为 5 的根节点到叶子节点的路径。</p><p><strong>示例 3:</strong></p><p>输入：<code>root = [], targetSum = 0</code><br>输出：<code>false</code><br>解释：由于树是空的，所以不存在根节点到叶子节点的路径。</p><h3 id="【解题思路】-10"><a href="#【解题思路】-10" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>要判断是否存在一条从根节点到叶子节点的路径，其路径上所有节点的值相加等于目标和，我们可以使用递归的方法遍历这棵树。对于每一个节点，我们做以下判断：</p><ol><li>如果当前节点是叶子节点（即没有左右子节点），检查当前路径的总和（包括当前节点）是否等于目标和。</li><li>如果当前节点不是叶子节点，递归检查其左子节点和右子节点，其中路径总和需要加上当前节点的值。</li></ol><p>通过递归地进行这样的判断，我们可以找到是否存在符合条件的路径。</p><h3 id="【实现代码】-10"><a href="#【实现代码】-10" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// TreeNode 定义二叉树节点</span></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hasPathSum 检查是否存在从根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasPathSum</span><span class="params">(root *TreeNode, targetSum <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 如果节点为空直接返回false</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是叶子节点，检查是否满足路径总和等于目标和</span></span><br><span class="line">    <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root.Val == targetSum</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归检查左子节点和右子节点，路径总和需要减去当前节点的值</span></span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root.Left, targetSum-root.Val) || hasPathSum(root.Right, targetSum-root.Val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113 路径总和 II"></a>113 路径总和 II</h2><h3 id="【题目描述】-11"><a href="#【题目描述】-11" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code>，找出所有从根节点到叶子节点路径总和等于给定目标和的路径。</p><p>叶子节点是指没有子节点的节点。</p><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22</span><br><span class="line">输出：[[5,4,11,2],[5,8,4,5]]</span><br><span class="line">解释：有两条路径的和等于目标数 22:</span><br><span class="line">5 + 4 + 11 + 2 = 22</span><br><span class="line">5 + 8 + 4 + 5 = 22</span><br></pre></td></tr></table></figure><h3 id="【解题思路】-11"><a href="#【解题思路】-11" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题可以通过深度优先搜索（DFS）来解决。基本思路是遍历每一条从根节点到叶子节点的路径，并记录下来。如果路径上节点的值之和等于目标和，就将这条路径添加到结果列表中。</p><p>具体步骤如下：</p><ol><li>创建一个全局变量 <code>res</code> 用于存储所有符合条件的路径。</li><li>进行深度优先搜索，搜索过程中，维护一个当前路径的列表 <code>path</code> 和当前路径的和 <code>sum</code>。</li><li>遍历到一个节点时，将该节点的值加到 <code>sum</code> 上，并将该节点加入到 <code>path</code> 中。</li><li>如果当前节点是叶子节点且 <code>sum</code> 等于目标和，就将 <code>path</code> 复制一份加入到 <code>res</code> 中。</li><li>递归遍历左子节点和右子节点，每次递归前后，需要更新 <code>path</code> 和 <code>sum</code>。</li><li>遍历结束后，<code>res</code> 中就是所有满足条件的路径。</li></ol><h3 id="【实现代码】-11"><a href="#【实现代码】-11" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// TreeNode 定义二叉树节点</span></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pathSum</span><span class="params">(root *TreeNode, targetSum <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">path := []<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> backtrack <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode, targetSum <span class="type">int</span>)</span></span></span><br><span class="line">backtrack = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode, targetSum <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &amp;&amp; root.Val == targetSum &#123;</span><br><span class="line">path = <span class="built_in">append</span>(path, root.Val)</span><br><span class="line">res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="type">int</span>(<span class="literal">nil</span>), path...))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">path = <span class="built_in">append</span>(path, root.Val)</span><br><span class="line"><span class="keyword">if</span> root.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">backtrack(root.Left, targetSum-root.Val)</span><br><span class="line">path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> root.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">backtrack(root.Right, targetSum-root.Val)</span><br><span class="line">path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">backtrack(root, targetSum)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105 从前序与中序遍历序列构造二叉树"></a>105 从前序与中序遍历序列构造二叉树</h2><h3 id="【题目描述】-12"><a href="#【题目描述】-12" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定两个整数数组，一个是二叉树的前序遍历结果，另一个是同一棵树的中序遍历结果。你需要根据这两个数组，重建出原二叉树。</p><p>注意:</p><ul><li>假设树中没有重复的元素。</li></ul><p>例如，给定：</p><p>前序遍历 preorder &#x3D; [3,9,20,15,7]<br>中序遍历 inorder &#x3D; [9,3,15,20,7]</p><p>返回以下二叉树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><h3 id="【解题思路】-12"><a href="#【解题思路】-12" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>前序遍历的第一个元素是树的根节点。在中序遍历中，根节点把树分为左子树和右子树。利用这个特性，我们可以递归地构建整棵树。</p><ol><li><strong>定位根节点</strong>：前序数组的第一个元素是根节点。</li><li><strong>划分子树</strong>：在中序数组中找到根节点，划分出左子树和右子树的中序遍历数组。</li><li><strong>递归构建</strong>：<ul><li>对左子树和右子树分别递归调用构建方法。</li><li>需要注意的是，每次递归时，前序数组和中序数组都应该只包含当前子树的节点。</li></ul></li></ol><h3 id="【实现代码】-12"><a href="#【实现代码】-12" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// buildTree 根据前序和中序遍历构造二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(preorder []<span class="type">int</span>, inorder []<span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历的第一个元素是根节点</span></span><br><span class="line">    rootValue := preorder[<span class="number">0</span>]</span><br><span class="line">    root := &amp;TreeNode&#123;Val: rootValue&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在中序遍历中找到根节点的位置，这将中序数组分为左右子树</span></span><br><span class="line">    midIndex := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> inorder &#123;</span><br><span class="line">        <span class="keyword">if</span> v == rootValue &#123;</span><br><span class="line">            midIndex = i</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归构建左子树和右子树</span></span><br><span class="line">    root.Left = buildTree(preorder[<span class="number">1</span>:midIndex+<span class="number">1</span>], inorder[:midIndex])</span><br><span class="line">    root.Right = buildTree(preorder[midIndex+<span class="number">1</span>:], inorder[midIndex+<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106 从中序与后序遍历序列构造二叉树"></a>106 从中序与后序遍历序列构造二叉树</h2><h3 id="【题目描述】-13"><a href="#【题目描述】-13" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p><p>注意:<br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><p>中序遍历 inorder &#x3D; [9,3,15,20,7]<br>后序遍历 postorder &#x3D; [9,15,7,20,3]<br>返回如下的二叉树：</p><pre><code>3</code></pre><p>   &#x2F; <br>  9  20<br>    &#x2F;  <br>   15   7</p><h3 id="【解题思路】-13"><a href="#【解题思路】-13" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这道题可以通过递归的方式来解决。我们知道，后序遍历的最后一个元素是根节点，而在中序遍历中，根节点的左侧是左子树，右侧是右子树。</p><p>我们可以先找到后序遍历的最后一个元素作为根节点，然后在中序遍历中找到根节点的位置，这样就可以确定左子树和右子树的节点数量。接下来，我们可以递归地构建左子树和右子树，直到所有节点都被处理完毕。</p><p>具体步骤如下：</p><ol><li>如果中序遍历或后序遍历为空，则返回 nil。</li><li>从后序遍历的最后一个元素取出根节点的值。</li><li>在中序遍历中找到根节点的位置，记为 rootIndex。</li><li>计算左子树的节点数量：leftSize &#x3D; rootIndex - inStart。</li><li>递归构建左子树：root.Left &#x3D; buildTree(inorder[inStart:rootIndex], postorder[postStart:postStart+leftSize])。</li><li>递归构建右子树：root.Right &#x3D; buildTree(inorder[rootIndex+1:inEnd], postorder[postStart+leftSize:postEnd-1])。</li><li>返回根节点 root。</li></ol><p>通过不断递归地构建左右子树，最终就可以还原出整棵二叉树。</p><h3 id="【实现代码】-13"><a href="#【实现代码】-13" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(inorder []<span class="type">int</span>, postorder []<span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line"><span class="comment">// inorder left,root,right</span></span><br><span class="line"><span class="comment">// postorder left,right,root</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> traverse <span class="function"><span class="keyword">func</span><span class="params">(inorder []<span class="type">int</span>, postorder []<span class="type">int</span>)</span></span> *TreeNode</span><br><span class="line">traverse = <span class="function"><span class="keyword">func</span><span class="params">(inorder []<span class="type">int</span>, postorder []<span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(inorder)&lt;=<span class="number">0</span> || <span class="built_in">len</span>(postorder) &lt;=<span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">root := &amp;TreeNode&#123;Val: postorder[<span class="built_in">len</span>(postorder)<span class="number">-1</span>]&#125;</span><br><span class="line">rootIndex := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(inorder); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> inorder[i] == root.Val &#123;</span><br><span class="line">rootIndex = i</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">inorderleft := inorder[:rootIndex]</span><br><span class="line">inorderright := inorder[rootIndex+<span class="number">1</span>:]</span><br><span class="line">postorderleft := postorder[:<span class="built_in">len</span>(inorderleft)]</span><br><span class="line">postorderright := postorder[<span class="built_in">len</span>(inorderleft):<span class="built_in">len</span>(postorder)<span class="number">-1</span>]</span><br><span class="line">root.Left = traverse(inorderleft, postorderleft)</span><br><span class="line">root.Right = traverse(inorderright, postorderright)</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> traverse(inorder, postorder)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654 最大二叉树"></a>654 最大二叉树</h2><h3 id="【题目描述】-14"><a href="#【题目描述】-14" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个不含重复元素的整数数组<code>nums</code>。一个以此数组直接递归构建的<strong>最大二叉树</strong>定义如下：</p><ul><li>二叉树的根是数组<code>nums</code>中的最大元素。</li><li>左子树是通过数组中最大值左边部分递归构造出的最大二叉树。</li><li>右子树是通过数组中最大值右边部分递归构造出的最大二叉树。</li></ul><p>返回由给定数组<code>nums</code>构建的最大二叉树。</p><h3 id="【解题思路】-14"><a href="#【解题思路】-14" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这道题的关键在于理解最大二叉树的构建过程。我们可以通过以下步骤来构建最大二叉树：</p><ol><li><strong>找到数组中的最大值</strong>，这个最大值将会成为当前二叉树的根节点。</li><li><strong>分割数组</strong>：将原数组分为两部分，最大值左边的数组用来构建左子树，最大值右边的数组用来构建右子树。</li><li><strong>递归构建</strong>：对左右两个子数组分别递归执行上述两个步骤，直到数组为空为止。</li></ol><p>使用递归的方式可以简洁地实现这个过程。</p><h3 id="【实现代码】-14"><a href="#【实现代码】-14" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val <span class="type">int</span></span><br><span class="line">    Left *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constructMaximumBinaryTree</span><span class="params">(nums []<span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line"><span class="keyword">var</span> traverser <span class="function"><span class="keyword">func</span><span class="params">(l, r <span class="type">int</span>)</span></span> *TreeNode</span><br><span class="line">traverser = <span class="function"><span class="keyword">func</span><span class="params">(l, r <span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line"><span class="keyword">if</span> l &gt; r &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">maxPos := <span class="number">-1</span></span><br><span class="line">maxValue := <span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> i := l; i &lt;= r; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums[i] &gt; maxValue &#123;</span><br><span class="line">maxValue = nums[i]</span><br><span class="line">maxPos = i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">root := &amp;TreeNode&#123;</span><br><span class="line">Val: maxValue,</span><br><span class="line">&#125;</span><br><span class="line">root.Left = traverser(l, maxPos<span class="number">-1</span>)</span><br><span class="line">root.Right = traverser(maxPos+<span class="number">1</span>, r)</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> traverser(<span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617 合并二叉树"></a>617 合并二叉树</h2><h3 id="【题目描述】-15"><a href="#【题目描述】-15" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。你需要将它们合并成一个新的二叉树。合并的规则是如果两个节点重叠，那么将这两个节点的值相加作为节点合并后的新值，否则不为<code>NULL</code>的节点将直接作为新二叉树的节点。</p><h3 id="【解题思路】-15"><a href="#【解题思路】-15" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>合并两棵二叉树的过程可以通过递归实现。对于任意一个节点，合并后的值为两个二叉树中对应节点的值之和。如果一个节点在一个树中存在而在另一个树中不存在，那么这个节点的值将直接成为新树的对应节点的值。</p><p>具体步骤如下：</p><ol><li>如果两个二叉树的当前节点都为空，则返回<code>nil</code>。</li><li>如果其中一个节点为空，另一个不为空，则返回非空节点。</li><li>如果两个节点都不为空，则将两个节点的值相加，并递归地合并两个节点的左子树和右子树。</li></ol><h3 id="【实现代码】-15"><a href="#【实现代码】-15" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dfs</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTrees</span><span class="params">(root1 *TreeNode, root2 *TreeNode)</span></span> *TreeNode &#123;</span><br><span class="line"><span class="keyword">if</span> root1 == <span class="literal">nil</span> &amp;&amp; root2 == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> root1== <span class="literal">nil</span> &amp;&amp; root2!= <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> root1!= <span class="literal">nil</span> &amp;&amp; root2== <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root1</span><br><span class="line">&#125;</span><br><span class="line">root := &amp;TreeNode&#123;Val:root1.Val + root2.Val&#125;</span><br><span class="line">root.Left = mergeTrees(root1.Left, root2.Left)</span><br><span class="line">root.Right = mergeTrees(root1.Right, root2.Right)</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//bfs</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTrees</span><span class="params">(root1 *TreeNode, root2 *TreeNode)</span></span> *TreeNode &#123;</span><br><span class="line"><span class="keyword">if</span> root1 == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> root2 == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root1</span><br><span class="line">&#125;</span><br><span class="line">queue := []*TreeNode&#123;root1, root2&#125;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">left, right := queue[<span class="number">0</span>], queue[<span class="number">1</span>]</span><br><span class="line">queue = queue[<span class="number">2</span>:]</span><br><span class="line">left.Val = left.Val + right.Val</span><br><span class="line"><span class="comment">//左子树都不为空 入队列</span></span><br><span class="line"><span class="keyword">if</span> left.Left != <span class="literal">nil</span> &amp;&amp; right.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">queue = <span class="built_in">append</span>(queue, left.Left, right.Left)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//右子树都不为空 入队列</span></span><br><span class="line"><span class="keyword">if</span> left.Right != <span class="literal">nil</span> &amp;&amp; right.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">queue = <span class="built_in">append</span>(queue, left.Right, right.Right)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//左右子树有一个为空，不需要入队列</span></span><br><span class="line"><span class="keyword">if</span> left.Left == <span class="literal">nil</span> &amp;&amp; right.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">left.Left = right.Left</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> left.Right == <span class="literal">nil</span> &amp;&amp; right.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">left.Right = right.Right</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="700-二叉搜索树的查找"><a href="#700-二叉搜索树的查找" class="headerlink" title="700 二叉搜索树的查找"></a>700 二叉搜索树的查找</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchBST</span><span class="params">(root *TreeNode, val <span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> root.Val == val &#123;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> root.Val &gt; val &#123;</span><br><span class="line"><span class="keyword">return</span> searchBST(root.Left, val)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> searchBST(root.Right, val)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchBST</span><span class="params">(root *TreeNode, val <span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> root.Val == val &#123;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> root.Val &gt; val &#123;</span><br><span class="line">root = root.Left</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">root = root.Right</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98 验证二叉搜索树"></a>98 验证二叉搜索树</h2><h3 id="【题目描述】-16"><a href="#【题目描述】-16" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树（BST）。一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含小于当前节点的数。</li><li>节点的右子树只包含大于当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><h3 id="【解题思路】-16"><a href="#【解题思路】-16" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>验证二叉搜索树的有效性可以通过递归来完成。基本思路是，利用二叉搜索树的性质：对于任意节点，它的值必须大于其左子树中所有节点的最大值，同时小于其右子树中所有节点的最小值。这意味着，我们可以通过递归来检查每个节点，同时更新当前节点值所允许的最小值和最大值。</p><p>我们可以定义一个辅助函数来实现递归，该函数除了传递当前节点外，还需要传递当前值的允许最小值和最大值。在递归过程中，我们根据当前节点是左节点还是右节点，更新这个范围，并检查当前节点的值是否在这个范围内。</p><h3 id="【实现代码】-16"><a href="#【实现代码】-16" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidBST</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> validate(root, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// validate 函数接收当前节点以及这个节点值允许的最小值和最大值</span></span><br><span class="line"><span class="comment">//dfs</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validate</span><span class="params">(node *TreeNode, min *<span class="type">int</span>, max *<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 如果节点为空，说明满足BST的条件</span></span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果节点值不在允许的范围内，返回false</span></span><br><span class="line">    <span class="keyword">if</span> (min != <span class="literal">nil</span> &amp;&amp; node.Val &lt;= *min) || (max != <span class="literal">nil</span> &amp;&amp; node.Val &gt;= *max) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归检查左子树，更新最大值为当前节点值，因为左子树的所有值都应该小于当前节点值</span></span><br><span class="line">    <span class="comment">// 递归检查右子树，更新最小值为当前节点值，因为右子树的所有值都应该大于当前节点值</span></span><br><span class="line">    <span class="keyword">return</span> validate(node.Left, min, &amp;node.Val) &amp;&amp; validate(node.Right, &amp;node.Val, max)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidBST</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">var</span> prev *TreeNode</span><br><span class="line"><span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(root * TreeNode)</span></span> <span class="type">bool</span></span><br><span class="line">dfs = <span class="function"><span class="keyword">func</span><span class="params">(root * TreeNode)</span></span> <span class="type">bool</span>&#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !dfs(root.Left) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> prev != <span class="literal">nil</span> &amp;&amp; prev.Val &gt;= root.Val &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根节点遍历后赋值</span></span><br><span class="line">prev = root</span><br><span class="line"><span class="keyword">return</span> dfs(root.Right)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dfs(root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidBST</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="comment">// 中序遍历 左根右</span></span><br><span class="line">stack := []*TreeNode&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> cur, prev *TreeNode = root, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt;<span class="number">0</span>  || cur != <span class="literal">nil</span>&#123;</span><br><span class="line"><span class="keyword">if</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">stack = <span class="built_in">append</span>(stack, cur)</span><br><span class="line">cur = cur.Left</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cur = stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] </span><br><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">if</span> prev != <span class="literal">nil</span> &amp;&amp;  prev.Val &gt;= cur.Val &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">prev  =cur</span><br><span class="line">cur = cur.Right</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="530-最小绝对差值"><a href="#530-最小绝对差值" class="headerlink" title="530 最小绝对差值"></a>530 最小绝对差值</h2><h3 id="【题目描述】-17"><a href="#【题目描述】-17" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个二叉搜索树的根节点 <code>root</code>，返回树中任意两不同节点值之间的最小差值。差值是一个正数，其计算方式为 <code>|a-b|</code> 其中 <code>a</code> 和 <code>b</code> 是两个数。</p><h3 id="【解题思路】-17"><a href="#【解题思路】-17" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>二叉搜索树（BST）的一个性质是：对于树上的任意节点 <code>N</code>，其左子树中的所有节点的值都小于 <code>N</code>，右子树的所有节点的值都大于 <code>N</code>。利用这个性质，我们可以中序遍历整个树。在中序遍历过程中，树中的节点值会按照升序的方式被访问。因此，我们只需要比较相邻两节点的值，就能找到树中任意两不同节点值之间的最小差值。</p><p>具体步骤如下：</p><ol><li>进行中序遍历，过程中记录前一个节点的值。</li><li>对于当前节点，计算它与前一个节点的差值，更新最小差值。</li><li>继续遍历，直到遍历完整棵树。</li></ol><h3 id="【实现代码】-17"><a href="#【实现代码】-17" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMinimumDifference</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    minDiff := math.MaxInt <span class="comment">// 初始化最小差值为最大值</span></span><br><span class="line">    <span class="keyword">var</span> prev *TreeNode            <span class="comment">// 用于记录前一个节点</span></span><br><span class="line">    <span class="keyword">var</span> traverse <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode)</span></span>  <span class="comment">// 声明中序遍历函数</span></span><br><span class="line"></span><br><span class="line">    traverse = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        traverse(node.Left) <span class="comment">// 递归遍历左子树</span></span><br><span class="line">        <span class="keyword">if</span> prev != <span class="literal">nil</span> &amp;&amp; node.Val-prev.Val &lt; minDiff &#123;</span><br><span class="line">            minDiff = node.Val - prev.Val <span class="comment">// 更新最小差值</span></span><br><span class="line">        &#125;</span><br><span class="line">        prev = node <span class="comment">// 更新前一个节点</span></span><br><span class="line">        traverse(node.Right) <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    traverse(root) <span class="comment">// 开始中序遍历</span></span><br><span class="line">    <span class="keyword">return</span> minDiff <span class="comment">// 返回最小差值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMinimumDifference</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">queue := []*TreeNode&#123;&#125;</span><br><span class="line">cur := root </span><br><span class="line"><span class="keyword">var</span> prev  *TreeNode</span><br><span class="line">minDiff := math.MaxInt</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt;<span class="number">0</span> || cur != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">queue = <span class="built_in">append</span>(queue, cur)</span><br><span class="line">cur = cur.Left</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cur = queue[<span class="built_in">len</span>(queue)<span class="number">-1</span>]</span><br><span class="line">queue =queue[:<span class="built_in">len</span>(queue)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">if</span> prev != <span class="literal">nil</span> &#123;</span><br><span class="line">minDiff = min(minDiff, cur.Val-prev.Val)</span><br><span class="line">&#125;</span><br><span class="line">prev = cur</span><br><span class="line">cur = cur.Right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> minDiff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501 二叉搜索树中的众数"></a>501 二叉搜索树中的众数</h2><h3 id="【题目描述】-18"><a href="#【题目描述】-18" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</p><p><strong>假定 BST 有如下定义：</strong></p><ul><li>结构上，左子树的所有元素都小于根节点，右子树的所有元素都大于根节点。</li><li>左子树和右子树也都是二叉搜索树。</li></ul><h3 id="【解题思路】-18"><a href="#【解题思路】-18" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>由于是二叉搜索树，我们可以利用它的性质——中序遍历二叉搜索树会得到一个升序的序列。在这个过程中，我们可以记录当前元素的出现次数，并与之前记录的最大出现次数进行比较，从而找到众数。</p><p>具体步骤如下：</p><ol><li>初始化三个变量，<code>currentCount</code>（当前元素计数）、<code>maxCount</code>（最大出现次数）和<code>prevElement</code>（前一个元素）用于在遍历过程中进行比较。</li><li>进行中序遍历，在遍历过程中更新这些变量，并记录当前出现次数最多的元素。</li><li>如果当前元素计数大于最大计数，则清空结果列表，并将当前元素添加进去；如果当前元素计数等于最大计数，则将当前元素也添加到结果列表中。</li><li>遍历完成后，返回结果列表。</li></ol><h3 id="【实现代码】-18"><a href="#【实现代码】-18" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMode</span><span class="params">(root *TreeNode)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">res := []<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> prev *TreeNode</span><br><span class="line"><span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span></span><br><span class="line"><span class="keyword">var</span> count, maxCount <span class="type">int</span></span><br><span class="line">dfs = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">dfs(root.Left)</span><br><span class="line"><span class="keyword">if</span> prev != <span class="literal">nil</span> &amp;&amp; prev.Val == root.Val &#123;</span><br><span class="line">count++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">count = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果当前元素比最大的还大，则直接清空</span></span><br><span class="line"><span class="keyword">if</span> count &gt; maxCount &#123;</span><br><span class="line">res = []<span class="type">int</span>&#123;root.Val&#125;</span><br><span class="line">maxCount = count</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> count == maxCount &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, root.Val)</span><br><span class="line">&#125;</span><br><span class="line">prev = root</span><br><span class="line"></span><br><span class="line">dfs(root.Right)</span><br><span class="line">&#125;</span><br><span class="line">dfs(root)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236 二叉树的最近公共祖先"></a>236 二叉树的最近公共祖先</h2><h3 id="【题目描述】-19"><a href="#【题目描述】-19" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先（LCA，Lowest Common Ancestor）。最近公共祖先的定义为：对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。</p><h3 id="【解题思路】-19"><a href="#【解题思路】-19" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题可以通过递归来解决。对于每个节点来说，如果当前节点就是 p、q 中的一个，或者在它的左右子树中分别找到了 p 和 q，那么这个节点就是 p 和 q 的最近公共祖先。</p><ol><li><strong>递归终止条件</strong>：如果当前节点为空或者等于 p 或 q，则返回当前节点。</li><li><strong>递归左子树和右子树</strong>：分别在左右子树中递归查找 p 和 q，如果在一个子树中找到了 p 或 q，则返回那个节点。</li><li><strong>分情况讨论</strong>：<ul><li>如果 p 和 q 分别位于当前节点的两侧，即一个在左子树，一个在右子树，那么当前节点就是它们的最近公共祖先。</li><li>如果 p 和 q 都在左子树，那么返回左子树的递归结果。</li><li>如果 p 和 q 都在右子树，那么返回右子树的递归结果。</li><li>如果 p 和 q 中只有一个存在于当前子树中，则只返回那个节点。</li></ul></li></ol><p>通过这样的递归逻辑，最终能够找到 p 和 q 的最近公共祖先。<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/202102041512582.png"></p><h3 id="【实现代码】-19"><a href="#【实现代码】-19" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> || root == p || root == q &#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    left := lowestCommonAncestor(root.Left, p, q)</span><br><span class="line">    right := lowestCommonAncestor(root.Right, p, q)</span><br><span class="line"></span><br><span class="line"><span class="comment">//left, right != nil说明找到了</span></span><br><span class="line">    <span class="comment">// 如果左子树找到了p或q，右子树找到了q或p，则说明当前root就是LCA</span></span><br><span class="line">    <span class="keyword">if</span> left != <span class="literal">nil</span> &amp;&amp; right != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果左子树为空，说明p和q都不在左子树中，返回右子树的查找结果</span></span><br><span class="line">    <span class="keyword">if</span> left == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同理，如果右子树为空，返回左子树的查找结果</span></span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a>235. 二叉搜索树的最近公共祖先</h2><h3 id="【题目描述】-20"><a href="#【题目描述】-20" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p>例如，给定如下二叉搜索树: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    6</span><br><span class="line">   / \</span><br><span class="line">  2   8</span><br><span class="line"> / \ / \</span><br><span class="line">0  4 7  9</span><br><span class="line">   / \</span><br><span class="line">  3   5</span><br></pre></td></tr></table></figure><p><strong>示例 1:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</span><br><span class="line">输出: 2</span><br><span class="line">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li></ul><h3 id="【解题思路】-20"><a href="#【解题思路】-20" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>由于题目给的是二叉搜索树，我们可以利用二叉搜索树的特性：左子树的所有节点的值都小于根节点的值，右子树的所有节点的值都大于根节点的值。根据这个特性，我们可以从根节点开始遍历，如果p和q的值都大于根节点的值，那么它们的最近公共祖先一定在右子树中，我们可以递归地在右子树中寻找。如果p和q的值都小于根节点的值，那么它们的最近公共祖先一定在左子树中，我们同样可以递归地在左子树中寻找。如果p和q的值一个大于根节点的值，一个小于根节点的值，那么根节点就是它们的最近公共祖先。</p><h3 id="【实现代码】-20"><a href="#【实现代码】-20" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// TreeNode 定义二叉树节点</span></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line"> Val   <span class="type">int</span></span><br><span class="line"> Left  *TreeNode</span><br><span class="line"> Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> || root == p || root == q &#123;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> root.Val &gt; p.Val &amp;&amp; root.Val &gt; q.Val &#123;</span><br><span class="line"><span class="keyword">return</span> lowestCommonAncestor(root.Left ,p, q)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> root.Val &lt; p.Val &amp;&amp; root.Val &lt; q.Val &#123;</span><br><span class="line"><span class="keyword">return</span> lowestCommonAncestor(root.Right ,p, q)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a>701. 二叉搜索树中的插入操作</h2><h3 id="【题目描述】-21"><a href="#【题目描述】-21" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。</p><p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。</p><p>例如,</p><p>给定的树:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    4</span><br><span class="line">   / \</span><br><span class="line">  2   7</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure><p>和 插入的值: 5</p><p>你可以返回这个二叉搜索树:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    4</span><br><span class="line">   / \</span><br><span class="line">  2   7</span><br><span class="line"> / \   \</span><br><span class="line">1   3   5</span><br></pre></td></tr></table></figure><p>或者这个树也是有效的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  2   7</span><br><span class="line"> / \   </span><br><span class="line">1   3</span><br><span class="line">     \</span><br><span class="line">      4</span><br></pre></td></tr></table></figure><h3 id="【解题思路】-21"><a href="#【解题思路】-21" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>插入操作在二叉搜索树中相对简单，因为二叉搜索树的特性就是左子树的所有节点的值都小于根节点的值，右子树的所有节点的值都大于根节点的值。</p><p>所以，我们可以从根节点开始，比较要插入的值和当前节点的值。如果要插入的值小于当前节点的值，我们就将其插入到当前节点的左子树中；如果要插入的值大于当前节点的值，我们就将其插入到当前节点的右子树中。如果当前节点为空，那么要插入的值就应该成为新的节点。</p><p>这个过程可以通过递归来实现。</p><h3 id="【实现代码】-21"><a href="#【实现代码】-21" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line"> Val   <span class="type">int</span></span><br><span class="line"> Left  *TreeNode</span><br><span class="line"> Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertIntoBST</span><span class="params">(root *TreeNode, val <span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;TreeNode&#123;</span><br><span class="line">Val: val,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> root.Val &gt; val &#123;</span><br><span class="line">root.Left = insertIntoBST(root.Left, val)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">root.Right = insertIntoBST(root.Right, val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450 删除二叉搜索树中的节点"></a>450 删除二叉搜索树中的节点</h2><h3 id="【题目描述】-22"><a href="#【题目描述】-22" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤:</p><ol><li>找到要删除的节点</li><li>删除该节点</li></ol><h3 id="【解题思路】-22"><a href="#【解题思路】-22" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>首先我们需要在树中找到要删除的节点。如果该节点没有子节点，那么我们只需要直接将它删除。如果该节点只有一个子节点，那么我们只需要用该子节点来替换被删除的节点。如果该节点有两个子节点，那么我们需要找到该节点的后继节点（该节点右子树中最小的节点），用该后继节点的值替换被删除节点的值，然后再递归删除该后继节点。</p><h3 id="【实现代码】-22"><a href="#【实现代码】-22" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteNode</span><span class="params">(root *TreeNode, key <span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> root.Val == key &#123;</span><br><span class="line"><span class="keyword">if</span> root.Left == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root.Right</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root.Left</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//左右都不为空，则将左子树挂载右字数的最左节点</span></span><br><span class="line">rightLeft:= root.Right</span><br><span class="line"><span class="keyword">for</span> rightLeft.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">rightLeft = rightLeft.Left</span><br><span class="line">&#125;</span><br><span class="line">rightLeft.Left = root.Left</span><br><span class="line"><span class="keyword">return</span> root.Right</span><br><span class="line">&#125; </span><br><span class="line">root.Left = deleteNode(root.Left, key)</span><br><span class="line">root.Right = deleteNode(root.Right, key)</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669 修剪二叉搜索树"></a>669 修剪二叉搜索树</h2><h3 id="【题目描述】-23"><a href="#【题目描述】-23" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在 [low, high] 中。修剪树不应该改变保留在树中的元素的相对结构（即，如果没有被移除，原有的父代子代关系都应当保留）。可以证明，存在唯一的答案。</p><p>返回修剪后的二叉搜索树的新的根节点。注意，根节点可能会被更改。</p><h3 id="【解题思路】-23"><a href="#【解题思路】-23" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>我们可以使用递归的方式遍历二叉搜索树，对每个节点进行判断。如果当前节点的值小于最小边界low，那么我们需要修剪掉该节点的左子树，递归处理右子树。如果当前节点的值大于最大边界high，那么我们需要修剪掉该节点的右子树，递归处理左子树。如果当前节点的值在 [low, high] 范围内，我们就保留该节点，并递归处理它的左右子树。</p><h3 id="【实现代码】-23"><a href="#【实现代码】-23" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trimBST</span><span class="params">(root *TreeNode, low <span class="type">int</span>, high <span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> root.Val &lt; low &#123;</span><br><span class="line">        <span class="comment">// 当前节点值小于最小边界，修剪掉左子树</span></span><br><span class="line">        <span class="keyword">return</span> trimBST(root.Right, low, high)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> root.Val &gt; high &#123;</span><br><span class="line">        <span class="comment">// 当前节点值大于最大边界，修剪掉右子树</span></span><br><span class="line">        <span class="keyword">return</span> trimBST(root.Left, low, high)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前节点值在范围内，保留该节点</span></span><br><span class="line">        root.Left = trimBST(root.Left, low, high)</span><br><span class="line">        root.Right = trimBST(root.Right, low, high)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108 将有序数组转换为二叉搜索树"></a>108 将有序数组转换为二叉搜索树</h2><h3 id="【题目描述】-24"><a href="#【题目描述】-24" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>将一个按照升序排列的有序数组转换为一棵高度平衡的二叉搜索树。高度平衡二叉树是指一个二叉树每个节点的左右两个子树的高度差的绝对值不超过 1。</p><h3 id="【解题思路】-24"><a href="#【解题思路】-24" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题的关键在于如何构建一个高度平衡的二叉搜索树。由于数组是有序的，我们可以利用这一点，每次选择中间的元素作为根节点，这样可以保证树的平衡。具体步骤如下：</p><ol><li><strong>找到中间元素</strong>：首先找到数组的中间元素，将其作为树的根节点。如果数组长度是偶数，可以选择中间两个元素中的任意一个。</li><li><strong>递归构建子树</strong>：然后将中间元素左边的数组作为左子树，右边的数组作为右子树，递归这一过程。</li><li><strong>递归终止条件</strong>：当数组为空时，递归结束。</li></ol><p>通过这种方式，我们可以确保每次都是从数组的中间分割，这样构建出的二叉搜索树自然是高度平衡的。</p><h3 id="【实现代码】-24"><a href="#【实现代码】-24" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortedArrayToBST</span><span class="params">(nums []<span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> constructBST(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constructBST</span><span class="params">(nums []<span class="type">int</span>, left, right <span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">    <span class="keyword">if</span> left &gt; right &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    mid := left + (right-left)/<span class="number">2</span> <span class="comment">// 避免溢出</span></span><br><span class="line">    root := &amp;TreeNode&#123;Val: nums[mid]&#125;</span><br><span class="line">    root.Left = constructBST(nums, left, mid<span class="number">-1</span>)</span><br><span class="line">    root.Right = constructBST(nums, mid+<span class="number">1</span>, right)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538 把二叉搜索树转换为累加树"></a>538 把二叉搜索树转换为累加树</h2><h3 id="【题目描述】-25"><a href="#【题目描述】-25" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给出二叉搜索树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p><h3 id="【解题思路】-25"><a href="#【解题思路】-25" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题的关键在于理解如何递归遍历二叉搜索树（BST），以及如何累加节点值。由于BST的性质是左子树的值小于根节点的值，右子树的值大于根节点的值，我们可以利用这一点进行逆中序遍历（即先右后左的中序遍历）。通过这种遍历方式，我们可以从最大的节点值开始，逐步累加，然后更新每个节点的值。</p><p>具体步骤如下：</p><ol><li><strong>递归遍历右子树</strong>：首先递归地遍历右子树，这样可以从最大的节点值开始。</li><li><strong>更新节点值</strong>：遍历到一个节点时，用一个累加变量（sum）来记录当前已经遍历过的节点值的总和。将当前节点的值加到这个累加变量上，然后将累加变量的值赋给当前节点。</li><li><strong>递归遍历左子树</strong>：完成右子树和当前节点的处理后，递归地遍历左子树。</li><li><strong>递归结束条件</strong>：如果节点为空，则返回。</li></ol><p>通过这种方式，我们可以确保每个节点被更新为原树中大于或等于该节点值的值之和。</p><h3 id="【实现代码】-25"><a href="#【实现代码】-25" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convertBST</span><span class="params">(root *TreeNode)</span></span> *TreeNode &#123;</span><br><span class="line"><span class="comment">//右根左</span></span><br><span class="line"><span class="keyword">var</span> prev *TreeNode</span><br><span class="line"><span class="keyword">var</span> traverse <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span></span><br><span class="line">traverse = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">traverse(root.Right)</span><br><span class="line"><span class="keyword">if</span> prev != <span class="literal">nil</span> &#123;</span><br><span class="line">root.Val += prev.Val</span><br><span class="line">&#125;</span><br><span class="line">prev = root</span><br><span class="line">traverse(root.Left)</span><br><span class="line">&#125;</span><br><span class="line">traverse(root)</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯</title>
      <link href="/2024/03/26/leetcode/%E5%9B%9E%E6%BA%AF/"/>
      <url>/2024/03/26/leetcode/%E5%9B%9E%E6%BA%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="&gt; 原理"></a>&gt; 原理</h1><blockquote><p>回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案<br>为了让回溯法高效一些，会加一些剪枝的操作<br>回溯法解决的问题都可以抽象为树形结构，集合的大小就构成了树的宽度，递归的深度构成的树的深度</p></blockquote><p>回溯法，一般可以解决如下几种问题：</p><ul><li>组合问题（不强调顺序）：N个数里面按一定规则找出k个数的集合</li><li>排列问题（强调顺序）：N个数按一定规则全排列，有几种排列方式</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>棋盘问题：N皇后，解数独等等</li></ul><p>去重逻辑：<br>所有的去重都需要先对数组进行排序（递增子序列除外）</p><ol><li>对于组合类，子集类的去重 <code> i &gt; startIndex &amp;&amp; candidates[i] == candidates[i-1]</code></li><li>递增子序列，不能排序，因为会改变顺序，在for循环外层定义used数组，循环里对数组赋值，且不需要对used做回溯处理 <code>(len(path)&gt; 0 &amp;&amp;  path[len(path)-1] &gt; nums[i]) || used[nums[i]]</code></li><li>全排列，顶层定义used数组，<code>i&gt;0 &amp;&amp; nums[i] == nums[i-1]) &amp;&amp; !used[i-1]</code></li></ol><p>递归流程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/* 回溯算法框架 */</span><br><span class="line">// 如果有重复元素，防止重复元素出现，需要先对数组排序，然后加上if i&gt;start &amp;&amp; nums[i] == nums[i-1]:continue 剪枝处理</span><br><span class="line">func backtrack(state *State, choices []Choice, res *[]State) &#123;</span><br><span class="line">    // 判断是否为解</span><br><span class="line">    if isSolution(state) &#123;</span><br><span class="line">        // 记录解</span><br><span class="line">        recordSolution(state, res)</span><br><span class="line">        // 不再继续搜索</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    // 遍历所有选择</span><br><span class="line">    //start 是否从0开始决定了元素是否需要重复取</span><br><span class="line">    // i:= start 标识不能重复取</span><br><span class="line">    for i:=0;i&lt;len(chocices);i++ &#123;</span><br><span class="line">    //如果只需要取一个元素则是choices[i]， 如果是一段元素，可能是choices[start:i+1]</span><br><span class="line">    choice ：= choices[i]</span><br><span class="line">        // 剪枝：判断选择是否合法</span><br><span class="line">        if isValid(state, choice) &#123;</span><br><span class="line">            // 尝试：做出选择，更新状态</span><br><span class="line">            makeChoice(state, choice)</span><br><span class="line">            backtrack(state, choices, res)</span><br><span class="line">            // 回退：撤销选择，恢复到之前的状态</span><br><span class="line">            undoChoice(state, choice)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22 括号生成"></a>22 括号生成</h2><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p><p>例如，给出 n &#x3D; 3，一个可能的解为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &quot;((()))&quot;,</span><br><span class="line">  &quot;(()())&quot;,</span><br><span class="line">  &quot;(())()&quot;,</span><br><span class="line">  &quot;()(())&quot;,</span><br><span class="line">  &quot;()()()&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="【解题思路】"><a href="#【解题思路】" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>本题可以使用回溯法解决。回溯法是一种通过探索所有可能的候选解来找出所有的解的算法。如果候选解被确认不是一个解（或者至少不是最后一个解），回溯算法会丢弃它，并且回退到之前的步骤，尝试其他可能的解。</p><p>对于这个题目，我们可以从空字符串开始，递归地添加左括号和右括号，但是要遵守以下规则：</p><ol><li>只有当还有左括号剩余时才能添加左括号。</li><li>只有当右括号的数量大于左括号的数量时才能添加右括号。</li><li>当左括号和右括号都添加完毕，形成一个有效的组合。</li></ol><p>通过这种方式，我们可以保证生成的括号组合是有效的。</p><h3 id="【实现代码】"><a href="#【实现代码】" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateParenthesis</span><span class="params">(n <span class="type">int</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">var</span> isValid <span class="function"><span class="keyword">func</span><span class="params">(str []<span class="type">byte</span>)</span></span> <span class="type">bool</span></span><br><span class="line">isValid = <span class="function"><span class="keyword">func</span><span class="params">(str []<span class="type">byte</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">stack := []<span class="type">byte</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(str); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> str[i] == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">stack = <span class="built_in">append</span>(stack, str[i])</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(stack) &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] != <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(stack) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">res := []<span class="type">string</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> backtrack <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">path := []<span class="type">byte</span>&#123;&#125;</span><br><span class="line">brack := []<span class="type">byte</span>&#123;<span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;)&#x27;</span>&#125;</span><br><span class="line">backtrack = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(path) &gt; <span class="number">2</span>*n &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="number">2</span>*n &#123;</span><br><span class="line"><span class="keyword">if</span> isValid(path) &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, <span class="type">string</span>(path))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">path = <span class="built_in">append</span>(path, brack[i])</span><br><span class="line">backtrack()</span><br><span class="line">path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">backtrack()</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="77-组合"><a href="#77-组合" class="headerlink" title="77 组合"></a>77 组合</h2><h3 id="【题目描述】-1"><a href="#【题目描述】-1" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</p><p>你可以按 任何顺序 返回答案。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4, k = 2</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1, k = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; n &lt;&#x3D; 20</li><li>1 &lt;&#x3D; k &lt;&#x3D; n</li></ul><h3 id="【解题思路】-1"><a href="#【解题思路】-1" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这道题可以使用回溯算法来解决。回溯算法是一种通过探索所有可能的候选解来找出所有的解的算法。如果候选解被确认不是一个解（或者至少不是最后一个解），回溯算法会通过在上一步进行一些变化抛弃该解，即回溯并且再次尝试。</p><p>具体思路如下：</p><ol><li>从数字1开始，递归地选择数字，直到选择的数字个数达到k个。</li><li>在选择过程中，需要保证选择的数字是递增的，且不能重复选择。</li><li>当选择的数字个数达到k个时，将当前选择的数字组合加入结果集合中。</li><li>回溯：将当前选择的数字从组合中移除，并尝试选择下一个数字。</li></ol><h3 id="【实现代码】-1"><a href="#【实现代码】-1" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(n <span class="type">int</span>, k <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result [][]<span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> combination []<span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> backtrack <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line">    </span><br><span class="line">    backtrack = <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(combination) == k &#123;</span><br><span class="line">            temp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(combination))</span><br><span class="line">            <span class="built_in">copy</span>(temp, combination)</span><br><span class="line">            result = <span class="built_in">append</span>(result, temp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i := start; i &lt;= n; i++ &#123;</span><br><span class="line">            combination = <span class="built_in">append</span>(combination, i)</span><br><span class="line">            backtrack(i + <span class="number">1</span>)</span><br><span class="line">            combination = combination[:<span class="built_in">len</span>(combination)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    backtrack(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216 组合总和 III"></a>216 组合总和 III</h2><h3 id="【题目描述】-2"><a href="#【题目描述】-2" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：</p><ul><li>只使用数字1到9</li><li>每个数字 最多使用一次</li></ul><p>返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p><p>示例 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: k = 3, n = 7</span><br><span class="line">输出: [[1,2,4]]</span><br><span class="line">解释:</span><br><span class="line">1 + 2 + 4 = 7</span><br><span class="line">没有其他符合的组合了。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: k = 3, n = 9</span><br><span class="line">输出: [[1,2,6], [1,3,5], [2,3,4]]</span><br><span class="line">解释:</span><br><span class="line">1 + 2 + 6 = 9</span><br><span class="line">1 + 3 + 5 = 9</span><br><span class="line">2 + 3 + 4 = 9</span><br><span class="line">没有其他符合的组合了。</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: k = 4, n = 1</span><br><span class="line">输出: []</span><br><span class="line">解释: 不存在有效的组合。</span><br><span class="line">在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 &gt; 1，没有有效的组合。</span><br></pre></td></tr></table></figure><p>提示:</p><ul><li>2 &lt;&#x3D; k &lt;&#x3D; 9</li><li>1 &lt;&#x3D; n &lt;&#x3D; 60</li></ul><h3 id="【解题思路】-2"><a href="#【解题思路】-2" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这道题可以使用回溯算法来解决。我们可以从数字1开始，递归地选择数字，直到选择的数字个数达到k个，并且它们的和等于n。</p><p>具体思路如下：</p><ol><li>从数字1开始，递归地选择数字，直到选择的数字个数达到k个。</li><li>在选择过程中，需要保证选择的数字是递增的，且不能重复选择。</li><li>在选择过程中，记录当前选择的数字的和，如果和等于n，并且选择的数字个数等于k，则将当前选择的数字组合加入结果集合中。</li><li>如果当前选择的数字的和已经大于n，或者选择的数字个数已经达到k个，则不再继续选择，进行回溯。</li><li>回溯：将当前选择的数字从组合中移除，并尝试选择下一个数字。</li></ol><h3 id="【实现代码】-2"><a href="#【实现代码】-2" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum3</span><span class="params">(k <span class="type">int</span>, n <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">//和为n 的k个数</span></span><br><span class="line">res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">path := []<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> backtrace <span class="function"><span class="keyword">func</span><span class="params">(left <span class="type">int</span>, start <span class="type">int</span>)</span></span> </span><br><span class="line">backtrace = <span class="function"><span class="keyword">func</span><span class="params">(left <span class="type">int</span>, start <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(path) &gt; k || left &lt; <span class="number">0</span>&#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(path) == k  &amp;&amp; left == <span class="number">0</span>&#123;</span><br><span class="line"><span class="built_in">copy</span> := <span class="built_in">append</span>([]<span class="type">int</span>(<span class="literal">nil</span>), path...)</span><br><span class="line">res = <span class="built_in">append</span>(res, <span class="built_in">copy</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i:=start;i&lt;=<span class="number">9</span>;i++ &#123;</span><br><span class="line">path = <span class="built_in">append</span>(path, i)</span><br><span class="line">backtrace(left-i, i+<span class="number">1</span>)</span><br><span class="line">path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">backtrace(n, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17 电话号码的字母组合"></a>17 电话号码的字母组合</h2><h3 id="【题目描述】-3"><a href="#【题目描述】-3" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png" alt="image"></p><p>示例 1：<br>输入：digits &#x3D; “23”<br>输出：[“ad”,”ae”,”af”,”bd”,”be”,”bf”,”cd”,”ce”,”cf”]</p><p>示例 2：<br>输入：digits &#x3D; “”<br>输出：[]</p><p>示例 3：<br>输入：digits &#x3D; “2”<br>输出：[“a”,”b”,”c”]</p><h3 id="【解题思路】-3"><a href="#【解题思路】-3" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这道题可以使用回溯算法来解决。我们可以将数字字符串中的每个数字映射到对应的字母列表，然后通过回溯的方式生成所有可能的字母组合。</p><p>具体思路如下：</p><ol><li>创建一个映射表，将每个数字映射到对应的字母列表。</li><li>定义一个递归函数 backtrack，它接受当前的字母组合、剩余的数字字符串以及结果列表作为参数。</li><li>如果剩余的数字字符串为空，说明当前的字母组合已经完成，将其添加到结果列表中。</li><li>否则，取出当前数字字符串的第一个数字，获取其对应的字母列表。</li><li>遍历字母列表，将每个字母添加到当前的字母组合中，并递归调用 backtrack 函数，处理剩余的数字字符串。</li><li>递归结束后，将最后一个添加的字母从当前字母组合中移除，以回溯到上一层。</li><li>最终，结果列表中将包含所有可能的字母组合。</li></ol><h3 id="【实现代码】-3"><a href="#【实现代码】-3" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">letterCombinations</span><span class="params">(digits <span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">len</span>(digits) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="type">string</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">mp := <span class="keyword">map</span>[<span class="type">byte</span>][]<span class="type">byte</span>&#123;</span><br><span class="line"><span class="string">&#x27;2&#x27;</span>: &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;,</span><br><span class="line"><span class="string">&#x27;3&#x27;</span>: &#123;<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>&#125;,</span><br><span class="line"><span class="string">&#x27;4&#x27;</span>: &#123;<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>&#125;,</span><br><span class="line"><span class="string">&#x27;5&#x27;</span>: &#123;<span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;,</span><br><span class="line"><span class="string">&#x27;6&#x27;</span>: &#123;<span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;,</span><br><span class="line"><span class="string">&#x27;7&#x27;</span>: &#123;<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;s&#x27;</span>&#125;,</span><br><span class="line"><span class="string">&#x27;8&#x27;</span>: &#123;<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;v&#x27;</span>&#125;,</span><br><span class="line"><span class="string">&#x27;9&#x27;</span>: &#123;<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">res := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">path := []<span class="type">byte</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> backtrace <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span></span><br><span class="line">backtrace = <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(digits) &#123;</span><br><span class="line"><span class="built_in">copy</span> := <span class="built_in">append</span>([]<span class="type">byte</span>(<span class="literal">nil</span>), path...)</span><br><span class="line">res = <span class="built_in">append</span>(res, <span class="type">string</span>(<span class="built_in">copy</span>))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := start; i &lt; <span class="built_in">len</span>(digits); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(mp[digits[i]]); j++ &#123;</span><br><span class="line">path = <span class="built_in">append</span>(path, mp[digits[i]][j])</span><br><span class="line">backtrace(i + <span class="number">1</span>)</span><br><span class="line">path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">backtrace(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39 组合总和"></a>39 组合总和</h2><h3 id="【题目描述】-4"><a href="#【题目描述】-4" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p><p>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p><p>示例 1：<br>输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7<br>输出：$[[2,2,3],[7]]$<br>解释：<br>2 和 3 可以形成一组候选，2 + 2 + 3 &#x3D; 7 。注意 2 可以使用多次。<br>7 也是一个候选， 7 &#x3D; 7 。<br>仅有这两种组合。</p><p>示例 2：<br>输入: candidates &#x3D; [2,3,5], target &#x3D; 8<br>输出:$[[2,2,2,2],[2,3,3],[3,5]]$</p><p>示例 3：<br>输入: candidates &#x3D; [2], target &#x3D; 1<br>输出: []</p><h3 id="【解题思路】-4"><a href="#【解题思路】-4" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这道题可以使用回溯算法来解决。我们可以将问题看作是在候选数组中选择数字，使得选择的数字之和等于目标值。</p><p>具体思路如下：</p><ol><li>定义一个递归函数 backtrack，它接受当前的组合、剩余的目标值以及当前考虑的候选数字的起始索引作为参数。</li><li>如果剩余的目标值为 0，说明当前的组合满足条件，将其添加到结果列表中。</li><li>如果剩余的目标值小于 0，说明当前的组合不满足条件，直接返回。</li><li>否则，从当前考虑的候选数字的起始索引开始遍历候选数组。</li><li>对于每个候选数字，将其添加到当前的组合中，并递归调用 backtrack 函数，更新剩余的目标值和下一个考虑的候选数字的起始索引。</li><li>递归结束后，将最后一个添加的候选数字从当前组合中移除，以回溯到上一层。</li><li>最终，结果列表中将包含所有满足条件的组合。</li></ol><h3 id="【实现代码】-4"><a href="#【实现代码】-4" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum</span><span class="params">(candidates []<span class="type">int</span>, target <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">path := []<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> backtrack <span class="function"><span class="keyword">func</span><span class="params">(start, left <span class="type">int</span>)</span></span></span><br><span class="line">backtrack = <span class="function"><span class="keyword">func</span><span class="params">(start, left <span class="type">int</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> left &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> left == <span class="number">0</span>  &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="type">int</span>(<span class="literal">nil</span>), path...))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i:=start;i&lt;<span class="built_in">len</span>(candidates);i++ &#123;</span><br><span class="line">path = <span class="built_in">append</span>(path, candidates[i])</span><br><span class="line">backtrack(i, left-candidates[i])</span><br><span class="line">path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">backtrack(<span class="number">0</span>, target)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40 组合总和 II"></a>40 组合总和 II</h2><h3 id="【题目描述】-5"><a href="#【题目描述】-5" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。<br>candidates 中的每个数字在每个组合中只能使用 一次 。<br>注意：解集不能包含重复的组合。<br>示例 1:<br>输入: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,<br>输出:<br>$$<br>[<br>[1,1,6],<br>[1,2,5],<br>[1,7],<br>[2,6]<br>]<br>$$</p><p>示例 2:<br>输入: candidates &#x3D; [2,5,2,1,2], target &#x3D; 5,<br>输出:</p><p>$$[<br>[1,2,2],<br>[5]<br>]$$</p><h3 id="【解题思路】-5"><a href="#【解题思路】-5" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这道题与组合总和类似，但有以下不同点：</p><ol><li>每个数字在每个组合中只能使用一次。</li><li>解集不能包含重复的组合。</li></ol><p>为了满足这些条件，我们可以对候选数组进行排序，然后在回溯的过程中进行去重操作。</p><p>具体思路如下：</p><ol><li>对候选数组进行排序，方便后续的去重操作。</li><li>定义一个递归函数 backtrack，它接受当前的组合、剩余的目标值以及当前考虑的候选数字的起始索引作为参数。</li><li>如果剩余的目标值为 0，说明当前的组合满足条件，将其添加到结果列表中。</li><li>如果剩余的目标值小于 0，说明当前的组合不满足条件，直接返回。</li><li>否则，从当前考虑的候选数字的起始索引开始遍历候选数组。</li><li>对于每个候选数字，如果它与前一个数字相同且前一个数字没有被使用过，则跳过当前数字，避免产生重复的组合。</li><li>将当前候选数字添加到组合中，并递归调用 backtrack 函数，更新剩余的目标值和下一个考虑的候选数字的起始索引。</li><li>递归结束后，将最后一个添加的候选数字从当前组合中移除，以回溯到上一层。</li><li>最终，结果列表中将包含所有满足条件的组合。</li></ol><h3 id="【实现代码】-5"><a href="#【实现代码】-5" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum2</span><span class="params">(candidates []<span class="type">int</span>, target <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result [][]<span class="type">int</span></span><br><span class="line">    <span class="comment">// 对候选数组进行排序</span></span><br><span class="line">    sort.Ints(candidates)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义回溯函数</span></span><br><span class="line">    <span class="keyword">var</span> backtrack <span class="function"><span class="keyword">func</span><span class="params">(combination []<span class="type">int</span>, remainingTarget <span class="type">int</span>, startIndex <span class="type">int</span>)</span></span></span><br><span class="line">    backtrack = <span class="function"><span class="keyword">func</span><span class="params">(combination []<span class="type">int</span>, remainingTarget <span class="type">int</span>, startIndex <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 如果剩余目标值为 0，将当前组合添加到结果列表中</span></span><br><span class="line">        <span class="keyword">if</span> remainingTarget == <span class="number">0</span> &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, <span class="built_in">append</span>([]<span class="type">int</span>&#123;&#125;, combination...))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果剩余目标值小于 0，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> remainingTarget &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从当前考虑的候选数字的起始索引开始遍历候选数组</span></span><br><span class="line">        <span class="keyword">for</span> i := startIndex; i &lt; <span class="built_in">len</span>(candidates); i++ &#123;</span><br><span class="line">            <span class="comment">// 如果当前数字与前一个数字相同且前一个数字被使用过，则跳过当前数字</span></span><br><span class="line">            <span class="comment">// 所以需要对数组进行排序</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; startIndex &amp;&amp; candidates[i] == candidates[i<span class="number">-1</span>] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将当前候选数字添加到组合中</span></span><br><span class="line">            combination = <span class="built_in">append</span>(combination, candidates[i])</span><br><span class="line">            <span class="comment">// 递归调用回溯函数，更新剩余目标值和下一个考虑的候选数字的起始索引</span></span><br><span class="line">            backtrack(combination, remainingTarget-candidates[i], i+<span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 回溯，移除最后一个添加的候选数字</span></span><br><span class="line">            combination = combination[:<span class="built_in">len</span>(combination)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用回溯函数，生成组合</span></span><br><span class="line">    backtrack([]<span class="type">int</span>&#123;&#125;, target, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131 分割回文串"></a>131 分割回文串</h2><h3 id="【题目描述】-6"><a href="#【题目描述】-6" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。</p><p>回文串 是正着读和反着读都一样的字符串。</p><p>示例 1：<br>输入：s &#x3D; “aab”<br>输出：[[“a”,”a”,”b”],[“aa”,”b”]]</p><p>示例 2：<br>输入：s &#x3D; “a”<br>输出：[[“a”]]</p><h3 id="【解题思路】-6"><a href="#【解题思路】-6" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这道题可以使用回溯算法来解决。我们可以将问题看作是在字符串中选择分割点，使得分割后的每个子串都是回文串。</p><p>具体思路如下：</p><ol><li>定义一个递归函数 backtrack，它接受当前的分割方案、剩余的字符串以及字符串的起始索引作为参数。</li><li>如果剩余字符串为空，说明当前的分割方案满足条件，将其添加到结果列表中。</li><li>否则，从当前字符串的起始索引开始遍历字符串。</li><li>对于每个可能的分割点，判断从起始索引到分割点之间的子串是否为回文串。</li><li>如果是回文串，将其添加到当前的分割方案中，并递归调用 backtrack 函数，处理剩余的字符串。</li><li>递归结束后，将最后一个添加的子串从当前分割方案中移除，以回溯到上一层。</li><li>最终，结果列表中将包含所有可能的分割方案。</li></ol><h3 id="【实现代码】-6"><a href="#【实现代码】-6" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(s <span class="type">string</span>)</span></span> [][]<span class="type">string</span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(s)</span><br><span class="line">res := [][]<span class="type">string</span>&#123;&#125;</span><br><span class="line">path := []<span class="type">string</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> backtrace <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span></span><br><span class="line">backtrace = <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> start &gt; n &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> start  == n &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="type">string</span>(<span class="literal">nil</span>), path...))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := start; i &lt; n; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> isPaladim(s[start:i+<span class="number">1</span>]) &#123;</span><br><span class="line">path = <span class="built_in">append</span>(path, s[start:i+<span class="number">1</span>])</span><br><span class="line">backtrace(i+<span class="number">1</span>)</span><br><span class="line">path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">backtrace(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPaladim</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">l, r := <span class="number">0</span>, <span class="built_in">len</span>(s)<span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> l &lt;= r &#123;</span><br><span class="line"><span class="keyword">if</span> s[l] != s[r] &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">l++</span><br><span class="line">r--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="93-复原-IP-地址"><a href="#93-复原-IP-地址" class="headerlink" title="93 复原 IP 地址"></a>93 复原 IP 地址</h2><h3 id="【题目描述】-7"><a href="#【题目描述】-7" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p><p>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:&#49;&#x39;&#50;&#x2e;&#x31;&#54;&#56;&#x40;&#x31;&#x2e;&#49;">&#49;&#x39;&#50;&#x2e;&#x31;&#54;&#56;&#x40;&#x31;&#x2e;&#49;</a>“ 是 无效 IP 地址。<br>给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。</p><p>示例 1：<br>输入：s &#x3D; “25525511135”<br>输出：[“255.255.11.135”,”255.255.111.35”]</p><p>示例 2：<br>输入：s &#x3D; “0000”<br>输出：[“0.0.0.0”]</p><p>示例 3：<br>输入：s &#x3D; “101023”<br>输出：[“1.0.10.23”,”1.0.102.3”,”10.1.0.23”,”10.10.2.3”,”101.0.2.3”]</p><h3 id="【解题思路】-7"><a href="#【解题思路】-7" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这道题可以使用回溯算法来解决。我们可以将问题看作是在字符串中选择三个分割点，使得分割后的四个子串都是有效的 IP 地址段</p><h3 id="【实现代码】-7"><a href="#【实现代码】-7" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">restoreIpAddresses</span><span class="params">(s <span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(s)</span><br><span class="line">res := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">path := []<span class="type">string</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> backtrace <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span></span><br><span class="line">backtrace = <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> start &gt; n &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> start == n &amp;&amp; <span class="built_in">len</span>(path) == <span class="number">4</span> &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, strings.Join(path, <span class="string">&quot;.&quot;</span>))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := start; i &lt; n; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> isValid(s[start : i+<span class="number">1</span>]) &#123;</span><br><span class="line">path = <span class="built_in">append</span>(path, s[start:i+<span class="number">1</span>])</span><br><span class="line">backtrace(i + <span class="number">1</span>)</span><br><span class="line">path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">backtrace(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; <span class="number">1</span> &amp;&amp; s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">3</span> &amp;&amp; s &gt;<span class="string">&quot;255&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; <span class="number">3</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78 子集"></a>78 子集</h2><h3 id="【题目描述】-8"><a href="#【题目描述】-8" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p><p>示例 1：<br>输入：nums &#x3D; [1,2,3]<br>输出：$[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]$</p><p>示例 2：<br>输入：nums &#x3D; [0]<br>输出：$[[],[0]]$</p><h3 id="【解题思路】-8"><a href="#【解题思路】-8" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这道题可以使用回溯算法来解决。我们可以将问题看作是在数组中选择或不选择每个元素，生成所有可能的子集。</p><p>具体思路如下：</p><ol><li>定义一个递归函数 backtrack，它接受当前的子集、剩余的数组以及当前考虑的元素的索引作为参数。</li><li>将当前的子集添加到结果列表中，因为空集也是一个有效的子集。</li><li>从当前考虑的元素的索引开始遍历数组。</li><li>对于每个元素，我们有两种选择：<ul><li>将当前元素添加到子集中，并递归调用 backtrack 函数，处理剩余的数组和下一个元素的索引。</li><li>不将当前元素添加到子集中，直接递归调用 backtrack 函数，处理剩余的数组和下一个元素的索引。</li></ul></li><li>递归结束后，我们将得到所有可能的子集。</li></ol><h3 id="【实现代码】-8"><a href="#【实现代码】-8" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsets</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">path := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">n := <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> backtrace <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span></span><br><span class="line">backtrace = <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="type">int</span>(<span class="literal">nil</span>), path...))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := start; i &lt; n; i++ &#123;</span><br><span class="line">path = <span class="built_in">append</span>(path, nums[i])</span><br><span class="line">backtrace(i + <span class="number">1</span>)</span><br><span class="line">path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">backtrace(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90 子集 II"></a>90 子集 II</h2><h3 id="【题目描述】-9"><a href="#【题目描述】-9" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,2]</span><br><span class="line">输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure><h3 id="【解题思路】-9"><a href="#【解题思路】-9" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题可以通过回溯算法来解决。回溯算法是一种通过探索所有可能的候选解来找出所有的解的算法。对于这个问题，我们可以从空集开始，逐步添加元素构建子集。</p><ol><li><strong>排序</strong>：首先，将数组排序。这样做是为了让重复的元素在数组中相邻，便于我们在后面的步骤中跳过重复的子集。</li><li><strong>回溯</strong>：然后，我们使用回溯法逐个访问数组中的每个元素，考虑将它加入当前子集中或不加入。对于加入的情况，我们将元素添加到当前子集中，然后进行下一步递归；对于不加入的情况，我们直接进行下一步递归。</li><li><strong>去重</strong>：在每一步递归调用之前，如果当前元素和前一个元素相同，且前一个元素没有被加入到子集中，我们则跳过当前元素，以避免生成重复的子集。</li></ol><p>通过这种方法，我们可以生成所有不重复的子集。</p><h3 id="【实现代码】-9"><a href="#【实现代码】-9" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsetsWithDup</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">path := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">n := <span class="built_in">len</span>(nums)</span><br><span class="line"><span class="comment">// 和78相比，多了个去重的要求</span></span><br><span class="line">sort.Ints(nums)</span><br><span class="line"><span class="keyword">var</span> backtrace <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span></span><br><span class="line">backtrace = <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="type">int</span>(<span class="literal">nil</span>), path...))</span><br><span class="line"><span class="keyword">for</span> i := start; i &lt; n; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i&gt;start &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">path = <span class="built_in">append</span>(path, nums[i])</span><br><span class="line">backtrace(i + <span class="number">1</span>)</span><br><span class="line">path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">backtrace(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="491-递增子序列"><a href="#491-递增子序列" class="headerlink" title="491 递增子序列"></a>491 递增子序列</h2><h3 id="【题目描述】-10"><a href="#【题目描述】-10" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个整型数组，你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是 2。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4, 6, 7, 7]</span><br><span class="line">输出: [[4, 6], [4, 6, 7], [4, 6, 7, 7], [4, 7], [4, 7, 7], [6, 7], [6, 7, 7], [7,7]]</span><br></pre></td></tr></table></figure><h3 id="【解题思路】-10"><a href="#【解题思路】-10" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题可以通过回溯法来解决。关键点在于如何避免生成重复的子序列，以及如何确保子序列是递增的。</p><ol><li><p><strong>去重复</strong>：为了避免生成重复的子序列，我们可以在同一深度的递归中，如果当前元素与前一个元素相同，就跳过当前元素。</p></li><li><p><strong>保持递增</strong>：为了确保子序列是递增的，我们只在当前元素不小于子序列的最后一个元素时，才将当前元素添加到子序列中。</p></li><li><p><strong>回溯法</strong>：从数组的第一个元素开始，尝试所有可能的递增子序列组合。对于每个元素，我们有两个选择：包含这个元素或不包含。如果包含这个元素，我们就将它添加到当前的子序列中，并继续递归。如果不包含，我们直接进行下一步递归。</p></li><li><p><strong>终止条件</strong>：当我们处理完数组中的所有元素后，如果当前子序列的长度至少为2，则将其添加到结果集中。</p></li></ol><h3 id="【实现代码】-10"><a href="#【实现代码】-10" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findSubsequences</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">path := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">n := <span class="built_in">len</span>(nums)</span><br><span class="line"><span class="keyword">var</span> backtrack <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span></span><br><span class="line">backtrack = <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">//满足要求</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(path) &gt;= <span class="number">2</span>&#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="type">int</span>(<span class="literal">nil</span>), path...))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个要求不改变顺序的递增，所以不能使用i&gt;start &amp;&amp; nums[i] == nums[i-1]这种方式来去重</span></span><br><span class="line"><span class="comment">//需要引入map来对每一层去重，注意used是定义在backtrack之内的，且没有对used的撤回操作，因为是对每一层进行去重</span></span><br><span class="line">used := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := start; i &lt; n; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">len</span>(path)&gt; <span class="number">0</span> &amp;&amp;  path[<span class="built_in">len</span>(path)<span class="number">-1</span>] &gt; nums[i]) || used[nums[i]] &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">used[nums[i]] = <span class="literal">true</span></span><br><span class="line">path = <span class="built_in">append</span>(path, nums[i])</span><br><span class="line">backtrack(i + <span class="number">1</span>)</span><br><span class="line">path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">backtrack(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46 全排列"></a>46 全排列</h2><h3 id="【题目描述】-11"><a href="#【题目描述】-11" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个不含重复数字的数组 <code>nums</code>，返回其所有可能的全排列。你可以按任意顺序返回答案。</p><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="【解题思路】-11"><a href="#【解题思路】-11" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题是经典的回溯算法应用场景。要解决这个问题，我们可以遵循以下几个步骤：</p><ol><li><strong>选择路径</strong>：我们需要一个路径变量来记录我们到目前为止做的选择，即已经选择的数字。</li><li><strong>选择列表</strong>：我们需要知道我们当前可以做的选择，即还没有被选择的数字。</li><li><strong>结束条件</strong>：我们需要知道何时保存遍历到的结果，即路径变量的长度等于输入数组的长度。</li></ol><p>具体步骤如下：</p><ul><li>从数组的第一个元素开始，选择当前元素，然后进入下一层递归。</li><li>在递归中，从数组中选择一个还未被选择的元素，继续递归。</li><li>重复这个过程，直到所有的元素都被选择，这时我们得到了一个全排列，将其添加到结果列表中。</li><li>回溯到上一步，撤销上一步的选择，尝试其他的选择。</li></ul><p>通过这样的过程，我们可以遍历得到所有可能的全排列。</p><h3 id="【实现代码】-11"><a href="#【实现代码】-11" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permute</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">path := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">n := <span class="built_in">len</span>(nums)</span><br><span class="line">used := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> backtrack <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">backtrack = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(path) == n &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="type">int</span>(<span class="literal">nil</span>), path...))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> used[i] &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">path = <span class="built_in">append</span>(path, nums[i])</span><br><span class="line">used[i] = <span class="literal">true</span></span><br><span class="line">backtrack()</span><br><span class="line">path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">used[i] = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">backtrack()</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47 全排列 II"></a>47 全排列 II</h2><h3 id="【题目描述】-12"><a href="#【题目描述】-12" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个可包含重复数字的序列 <code>nums</code>，返回所有不重复的全排列。</p><h3 id="【解题思路】-12"><a href="#【解题思路】-12" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>全排列问题通常可以使用回溯法解决，但在本题中由于序列中可能存在重复数字，因此需要额外地处理重复情况，避免生成重复的排列。<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201124201331223.png"><br>解题步骤如下：</p><ol><li><p>先对数组进行排序，这样相同的数字会相邻，方便后续的去重处理。</p></li><li><p>定义回溯函数<code>backtrack</code>，参数包括：当前处理的数字索引<code>first</code>、已选择的数字列表<code>chosen</code>和原始数组<code>nums</code>。</p></li><li><p>在<code>backtrack</code>中，首先检查是否已经选取了所有的数字（即<code>chosen</code>的长度是否等于<code>nums</code>的长度）。如果是，则找到了一个有效的全排列，将其添加到结果列表中。</p></li><li><p>如果还有未选择的数字，则从<code>first</code>开始遍历数组<code>nums</code>：</p><ul><li><p>检查当前数字<code>nums[i]</code>是否与前面的某个数字重复，且前面的数字尚未被选择（即<code>i &gt; first</code>且<code>nums[i] == nums[i-1]</code>且<code>!chosen[i-1]</code>）。如果是，则跳过当前数字，以避免生成重复的排列。</p></li><li><p>否则，将当前数字添加到<code>chosen</code>中，标记为已选择，并递归调用<code>backtrack</code>处理下一个数字。</p></li><li><p>回溯时，将当前数字从<code>chosen</code>中移除，标记为未选择，以便尝试其他可能的数字。</p></li></ul></li></ol><h3 id="【实现代码】-12"><a href="#【实现代码】-12" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permuteUnique</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">path := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">n := <span class="built_in">len</span>(nums)</span><br><span class="line"><span class="comment">//需要排序</span></span><br><span class="line">sort.Ints(nums)</span><br><span class="line">used := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> backtrack <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">backtrack = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(path) == n &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="type">int</span>(<span class="literal">nil</span>), path...))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line"><span class="comment">// nums[i] == nums[i-1] &amp;&amp; !used[i-1] 防止的是同一层重复 防止的是同一层重复</span></span><br><span class="line"><span class="comment">// 同一层 上一次循环有相等元素，递归回溯后成了false</span></span><br><span class="line"><span class="comment">//需要加上 !used[i-1]， 否则同一树枝上可能出现nums[i] == nums[i-1] 的情况，但是这种情况下used[i-1]是true</span></span><br><span class="line"><span class="comment">// 这也是和第46题的区别</span></span><br><span class="line"><span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) &amp;&amp; !used[i<span class="number">-1</span>] &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// used[i]保证的是树枝层不重复</span></span><br><span class="line"><span class="keyword">if</span> used[i] &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">used[i] = <span class="literal">true</span></span><br><span class="line">path = <span class="built_in">append</span>(path, nums[i])</span><br><span class="line">backtrack()</span><br><span class="line">path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">used[i] = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">backtrack()</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="51-N皇后"><a href="#51-N皇后" class="headerlink" title="51 N皇后"></a>51 N皇后</h2><h3 id="【题目描述】-13"><a href="#【题目描述】-13" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。给你一个整数 n ，返回所有不同的 n 皇后问题的解决方案。每一种解法包含一个不同的 n 皇后在棋盘上的位置，输出的解应该不包含重复的解。皇后可以攻击与之处在同一行、同一列或同一斜线上的棋子。</p><h3 id="【解题思路】-13"><a href="#【解题思路】-13" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>解决 N 皇后问题的一个有效方法是使用回溯法。回溯法是一种通过探索所有可能的候选解来找到所有解的算法。如果一个候选解最终不是一个解，那么回溯算法会丢弃它，并回溯到之前的步骤，尝试另一个可能的解。</p><p>对于 N 皇后问题，我们可以从第一行开始，尝试在每一列中放置一个皇后，然后移动到下一行。每当我们放置一个皇后时，我们需要检查当前位置是否安全（即在当前位置的行、列和对角线上没有其他皇后）。如果当前位置安全，我们继续在下一行放置另一个皇后。如果我们达到了一个状态，在当前行没有安全的位置可以放置皇后，我们就回溯到上一行，改变上一个皇后的位置。</p><p>通过递归实现回溯算法，我们可以找到所有可能的解决方案。<br><img src="https://www.hello-algo.com/chapter_backtracking/n_queens_problem.assets/n_queens_placing.png"></p><h3 id="【实现代码】-13"><a href="#【实现代码】-13" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;strings&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">solveNQueens</span><span class="params">(n <span class="type">int</span>)</span></span> [][]<span class="type">string</span> &#123;</span><br><span class="line">    results := [][]<span class="type">string</span>&#123;&#125;</span><br><span class="line">    board := <span class="built_in">make</span>([][]<span class="type">string</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> board &#123;</span><br><span class="line">        board[i] = <span class="built_in">make</span>([]<span class="type">string</span>, n)</span><br><span class="line">        <span class="keyword">for</span> j := <span class="keyword">range</span> board[i] &#123;</span><br><span class="line">            board[i][j] = <span class="string">&quot;.&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backtrack(&amp;results, board, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backtrack</span><span class="params">(results *[][]<span class="type">string</span>, board [][]<span class="type">string</span>, row <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> row == <span class="built_in">len</span>(board) &#123;</span><br><span class="line">        tempResult := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(board))</span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">range</span> board &#123;</span><br><span class="line">            tempResult[i] = strings.Join(board[i], <span class="string">&quot;&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        *results = <span class="built_in">append</span>(*results, tempResult)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    n := <span class="built_in">len</span>(board[row])</span><br><span class="line">    <span class="keyword">for</span> col := <span class="number">0</span>; col &lt; n; col++ &#123;</span><br><span class="line">        <span class="keyword">if</span> !isValid(board, row, col) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        board[row][col] = <span class="string">&quot;Q&quot;</span></span><br><span class="line">        backtrack(results, board, row+<span class="number">1</span>)</span><br><span class="line">        board[row][col] = <span class="string">&quot;.&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">(board [][]<span class="type">string</span>, row, col <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(board)</span><br><span class="line">    <span class="comment">// Check column</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; row; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> board[i][col] == <span class="string">&quot;Q&quot;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Check upper left diagonal</span></span><br><span class="line">    <span class="keyword">for</span> i, j := row<span class="number">-1</span>, col<span class="number">-1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i, j = i<span class="number">-1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> board[i][j] == <span class="string">&quot;Q&quot;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Check upper right diagonal</span></span><br><span class="line">    <span class="keyword">for</span> i, j := row<span class="number">-1</span>, col+<span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i, j = i<span class="number">-1</span>, j+<span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> board[i][j] == <span class="string">&quot;Q&quot;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Example: solve a 4-queens problem</span></span><br><span class="line">    results := solveNQueens(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> _, solution := <span class="keyword">range</span> results &#123;</span><br><span class="line">        <span class="keyword">for</span> _, row := <span class="keyword">range</span> solution &#123;</span><br><span class="line">            <span class="built_in">println</span>(row)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;------&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2024/03/11/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2024/03/11/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h1><p> 动态规划中每一个状态一定是由上一个状态推导出来</p><h2 id="五部曲"><a href="#五部曲" class="headerlink" title="五部曲"></a>五部曲</h2><ol><li>确定dp数组及下标含义</li><li>确定递推公式</li><li>dp数组初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><h2 id="能解决的问题"><a href="#能解决的问题" class="headerlink" title="能解决的问题"></a>能解决的问题</h2><ul><li>背包问题<ul><li>01背包</li><li>完全背包</li><li>多重背包</li></ul></li><li>打家劫舍</li><li>股票问题<ul><li>只能买卖一次</li><li>可以买卖多次</li><li>最多买卖两次</li><li>最多买卖k次</li></ul></li><li>子序列问题<ul><li>子序列（不连续）</li><li>子序列（连续）</li><li>编辑距离</li><li>回文</li></ul></li></ul><h2 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509 斐波那契数"></a>509 斐波那契数</h2><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你一个整数 n，请你返回第 n 个斐波那契数。斐波那契数列的定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) = 0, F(1) = 1</span><br><span class="line">F(n) = F(n - 1) + F(n - 2), 对于 n &gt;= 2</span><br></pre></td></tr></table></figure><h3 id="【解题思路】"><a href="#【解题思路】" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>使用动态规划算法：</p><ol><li>定义一个数组 <code>dp</code>，其中 <code>dp[i]</code> 表示第 <code>i</code> 个斐波那契数。</li><li>初始化 <code>dp[0] = 0</code> 和 <code>dp[1] = 1</code>。</li><li>对于 <code>i</code> 从 2 到 <code>n</code>，计算 <code>dp[i] = dp[i - 1] + dp[i - 2]</code>。</li><li>返回 <code>dp[n]</code>。</li></ol><h3 id="【实现代码】"><a href="#【实现代码】" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">dp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">dp[<span class="number">1</span>]=<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> n&lt;<span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">2</span>;i&lt;=n;i++ &#123;</span><br><span class="line">res:=dp[<span class="number">0</span>]+dp[<span class="number">1</span>]</span><br><span class="line">dp[<span class="number">0</span>]=dp[<span class="number">1</span>]</span><br><span class="line">dp[<span class="number">1</span>]=res</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70 爬楼梯"></a>70 爬楼梯</h2><h3 id="【题目描述】-1"><a href="#【题目描述】-1" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><h3 id="【解题思路】-1"><a href="#【解题思路】-1" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>使用动态规划算法：</p><ol><li>定义一个数组 <code>dp</code>，其中 <code>dp[i]</code> 表示爬到第 <code>i</code> 阶楼梯的方法数。</li><li>初始化 <code>dp[0] = 1</code> 和 <code>dp[1] = 1</code>。</li><li>对于 <code>i</code> 从 2 到 <code>n</code>，计算 <code>dp[i] = dp[i - 1] + dp[i - 2]</code>。</li><li>返回 <code>dp[n]</code>。</li></ol><h3 id="【实现代码】-1"><a href="#【实现代码】-1" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个数组来存储爬楼梯的方法数</span></span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数组</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算爬楼梯的方法数</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回爬到第 n 阶楼梯的方法数</span></span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746 使用最小花费爬楼梯"></a>746 使用最小花费爬楼梯</h2><h3 id="【题目描述】-2"><a href="#【题目描述】-2" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你一个整数数组 <code>cost</code>，其中 <code>cost[i]</code> 是第 <code>i</code> 阶台阶的成本。一旦你支付了第 <code>i</code> 阶台阶的成本，你就可以免费进入第 <code>i+1</code> 和第 <code>i+2</code> 阶台阶。也就是说，你可以以 <code>cost[i]</code> 的成本进入台阶 <code>i、i+1</code> 和 <code>i+2</code>。</p><p>你从第一阶台阶开始，并需要到达最后一步。请你返回到达最后一步的最小花费。</p><h3 id="【解题思路】-2"><a href="#【解题思路】-2" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>使用动态规划算法：</p><ol><li>定义一个数组 <code>dp</code>，其中 <code>dp[i]</code> 表示到达第 <code>i</code> 阶台阶的最小花费。</li><li>初始化 <code>dp[0] = 0</code> 和 <code>dp[1] = cost[0]</code>。</li><li>对于 <code>i</code> 从 2 到 <code>n</code>，计算 <code>dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])</code>。</li><li>返回 <code>dp[n]</code>。</li></ol><h3 id="【实现代码】-2"><a href="#【实现代码】-2" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minCostClimbingStairs</span><span class="params">(cost []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(cost)</span><br><span class="line"><span class="comment">//代表到到达第i台阶需要的最小体力</span></span><br><span class="line">dp := <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">dp[<span class="number">0</span>], dp[<span class="number">1</span>] = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">2</span>;i&lt;=n;i++ &#123;</span><br><span class="line">dp[i] = min(cost[i<span class="number">-2</span>]+dp[i<span class="number">-2</span>], cost[i<span class="number">-1</span>]+dp[i<span class="number">-1</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a,b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> a&lt;b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62 不同路径"></a>62 不同路径</h2><h3 id="【题目描述】-3"><a href="#【题目描述】-3" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p><p>问：机器人有多少种不同的路径可以达到终点？</p><h3 id="【解题思路】-3"><a href="#【解题思路】-3" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>使用动态规划算法：</p><ol><li>定义一个二维数组 <code>dp</code>，其中 <code>dp[i][j]</code> 表示从左上角走到 <code>(i, j)</code> 的不同路径数。</li><li>初始化 <code>dp[0][0] = 1</code>，因为从左上角到左上角只有一条路径。</li><li>对于 <code>i</code> 从 1 到 <code>m</code>，计算 <code>dp[i][0] = dp[i-1][0]</code>，因为从左上角到 <code>(i, 0)</code> 的路径数等于从 <code>(i-1, 0)</code> 到 <code>(i, 0)</code> 的路径数。</li><li>对于 <code>j</code> 从 1 到 <code>n</code>，计算 <code>dp[0][j] = dp[0][j-1]</code>，因为从左上角到 <code>(0, j)</code> 的路径数等于从 <code>(0, j-1)</code> 到 <code>(0, j)</code> 的路径数。</li><li>对于 <code>i</code> 从 1 到 <code>m</code> 和 <code>j</code> 从 1 到 <code>n</code>，计算 <code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code>，因为从左上角到 <code>(i, j)</code> 的路径数等于从 <code>(i-1, j)</code> 到 <code>(i, j)</code> 的路径数加上从 <code>(i, j-1)</code> 到 <code>(i, j)</code> 的路径数。</li><li>返回 <code>dp[m-1][n-1]</code>。</li></ol><h3 id="【实现代码】-3"><a href="#【实现代码】-3" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uniquePaths</span><span class="params">(m <span class="type">int</span>, n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个二维数组来存储不同路径数</span></span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="type">int</span>, m)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数组</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算不同路径数</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; m; i++ &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回不同路径数</span></span><br><span class="line">    <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63 不同路径 II"></a>63 不同路径 II</h2><h3 id="【题目描述】-4"><a href="#【题目描述】-4" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p><p>现在，网格中某些格子被认为是障碍物，机器人无法进入。返回机器人到达右下角的不同路径数。</p><h3 id="【解题思路】-4"><a href="#【解题思路】-4" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>使用动态规划算法：</p><ol><li>定义一个二维数组 <code>dp</code>，其中 <code>dp[i][j]</code> 表示从左上角走到 <code>(i, j)</code> 的不同路径数。</li><li>初始化 <code>dp[0][0] = 1</code>，因为从左上角到左上角只有一条路径。</li><li>对于 <code>i</code> 从 1 到 <code>m</code>，如果 <code>grid[i-1][0] != 1</code>，则计算 <code>dp[i][0] = dp[i-1][0]</code>，否则 <code>dp[i][0] = 0</code>。</li><li>对于 <code>j</code> 从 1 到 <code>n</code>，如果 <code>grid[0][j-1] != 1</code>，则计算 <code>dp[0][j] = dp[0][j-1]</code>，否则 <code>dp[0][j] = 0</code>。</li><li>对于 <code>i</code> 从 1 到 <code>m</code> 和 <code>j</code> 从 1 到 <code>n</code>，如果 <code>grid[i][j] != 1</code>，则计算 <code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code>，否则 <code>dp[i][j] = 0</code>。</li><li>返回 <code>dp[m-1][n-1]</code>。</li></ol><h3 id="【实现代码】-4"><a href="#【实现代码】-4" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(obstacleGrid [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    m := <span class="built_in">len</span>(obstacleGrid)</span><br><span class="line">    n := <span class="built_in">len</span>(obstacleGrid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个二维数组来存储不同路径数</span></span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="type">int</span>, m)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数组</span></span><br><span class="line">    <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">0</span> &#123;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算不同路径数</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span> &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">        <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][j] == <span class="number">0</span> &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">0</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回不同路径数</span></span><br><span class="line">    <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343 整数拆分"></a>343 整数拆分</h2><h3 id="【题目描述】-5"><a href="#【题目描述】-5" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个正整数 <code>n</code>，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p><h3 id="【解题思路】-5"><a href="#【解题思路】-5" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>解决这个问题的关键是理解如何分割整数以获得最大的乘积。动态规划是解决这类问题的一种有效方法。</p><p>动态规划的基本思想是从底向上计算，先解决子问题，然后逐步解决更大的问题。对于整数拆分问题，我们可以定义一个数组 <code>dp</code>，其中 <code>dp[i]</code> 表示整数 <code>i</code> 拆分后得到的最大乘积。对于每一个整数 <code>i</code>，我们尝试将其拆分为 <code>j</code> 和 <code>i-j</code>（<code>1 &lt;= j &lt; i</code>），然后计算这两个数的乘积以及它们对应的 <code>dp</code> 值的乘积，取这些值中的最大值作为 <code>dp[i]</code> 的值。</p><p>初始化时，<code>dp[1]</code> 是1，因为按照题意，至少要拆分成两个正整数。</p><h3 id="【实现代码】-5"><a href="#【实现代码】-5" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">integerBreak</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">//拆分后得到的最大乘积</span></span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; i; j++ &#123;</span><br><span class="line">            <span class="comment">// dp[i]可以分为两种情况，一是j * (i-j),i-j 不拆分的最大乘积</span></span><br><span class="line"><span class="comment">// j * dp[i-j] i-j 拆分下的最大乘积</span></span><br><span class="line">            dp[i] = max(dp[i], max(j*(i-j), j*dp[i-j]))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// max函数返回两个整数中的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(integerBreak(<span class="number">10</span>)) <span class="comment">// 输出示例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96 不同的二叉搜索树"></a>96 不同的二叉搜索树</h2><h3 id="【题目描述】-6"><a href="#【题目描述】-6" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个整数 <code>n</code>，求以 <code>1 ... n</code> 为节点组成的二叉搜索树有多少种？</p><h3 id="【解题思路】-6"><a href="#【解题思路】-6" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题可以通过动态规划的方式来解决。核心思想是，我们可以考虑以每个数 <code>i</code> 作为根节点，那么左子树的节点元素就是 <code>1 ... (i-1)</code>，右子树的节点元素就是 <code>(i+1) ... n</code>。因此，如果我们知道了左子树和右子树的组合数，我们就可以计算出总的树的数量。</p><p>定义一个数组 <code>dp</code>，其中 <code>dp[i]</code> 表示由 <code>i</code> 个连续的节点组成的二叉搜索树的数量。对于 <code>dp[i]</code>（假设根节点为 <code>k</code>），它等于左边的树的数量乘以右边的树的数量，即 <code>dp[k-1] * dp[i-k]</code>。所以，我们可以得到以下状态转移方程：<br>$dp[i] &#x3D; \sum_{k&#x3D;1}^{i} dp[k-1] * dp[i-k]$<br>初始化 <code>dp[0] = 1</code> 和 <code>dp[1] = 1</code>，因为当树为空或只有一个节点时，只有一种情况。</p><h3 id="【实现代码】-6"><a href="#【实现代码】-6" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numTrees</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>], dp[<span class="number">1</span>] = <span class="number">1</span>, <span class="number">1</span> <span class="comment">// 初始化dp[0]和dp[1]</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= i; j++ &#123;</span><br><span class="line">            dp[i] += dp[j<span class="number">-1</span>] * dp[i-j] <span class="comment">// 状态转移方程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416 分割等和子集"></a>416 分割等和子集</h2><h3 id="【题目描述】-7"><a href="#【题目描述】-7" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你一个只包含正整数的非空数组 <code>nums</code>。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><h3 id="【解题思路】-7"><a href="#【解题思路】-7" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题可以转化为一个经典的动态规划问题——0-1背包问题。具体来说，我们想知道数组中是否存在一些数字，它们的和等于数组总和的一半。这是因为只有当数组的总和为偶数，并且可以找到和为总和一半的子集时，才能将数组分割成和相等的两个子集。</p><p>动态规划的思想是，我们创建一个二维数组 <code>dp</code>，其中 <code>dp[i][j]</code> 表示从数组的 <code>[0, i]</code> 区间内选取若干个整数，是否存在一种选取方式使得被选取的整数和为 <code>j</code>。状态转移方程如下：</p><ul><li>如果不选取当前数字 <code>nums[i]</code>，那么是否存在一种选取方式使得当前的和为 <code>j</code>，取决于前一个状态 <code>dp[i-1][j]</code>；</li><li>如果选取当前数字 <code>nums[i]</code>，那么是否存在一种选取方式使得当前的和为 <code>j</code>，取决于 <code>dp[i-1][j-nums[i]]</code>。</li></ul><p>初始化 <code>dp[0][nums[0]] = true</code>，因为选取 <code>nums[0]</code> 就可以得到和为 <code>nums[0]</code> 的子集。最终答案为 <code>dp[n-1][sum/2]</code>，其中 <code>n</code> 是数组 <code>nums</code> 的长度，<code>sum</code> 是数组 <code>nums</code> 的总和。</p><h3 id="【实现代码】-7"><a href="#【实现代码】-7" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canPartition</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">total := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> index := <span class="keyword">range</span> nums &#123;</span><br><span class="line">total += nums[index]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> total%<span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">packSize := total / <span class="number">2</span></span><br><span class="line">dp := <span class="built_in">make</span>([]<span class="type">int</span>, packSize+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := packSize; j &gt;= nums[i]; j-- &#123;</span><br><span class="line">dp[j] = max(dp[j], dp[j-nums[i]]+nums[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 剪枝</span></span><br><span class="line"><span class="keyword">if</span> dp[<span class="keyword">package</span>] == <span class="keyword">package</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[packSize] == packSize</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1049-最后一块石头的重量-II"><a href="#1049-最后一块石头的重量-II" class="headerlink" title="1049 最后一块石头的重量 II"></a>1049 最后一块石头的重量 II</h2><h3 id="【题目描述】-8"><a href="#【题目描述】-8" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>有一堆石头，每块石头的重量都是正整数。每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p><ul><li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li><li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头的新重量为 <code>y-x</code>。</li></ul><p>最后，最多只会剩下一块石头。返回此石头的最小可能重量。如果没有石头剩下，就返回 0。</p><h3 id="【解题思路】-8"><a href="#【解题思路】-8" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题可以转化为一个类似背包问题的动态规划问题。我们可以将石头分成两堆，尽量让这两堆石头的总重量相接近。问题就变成了从石头中选取一些石头，使得它们的总重量尽可能接近石头总重量的一半。</p><p>我们定义一个动态规划数组 <code>dp</code>，其中 <code>dp[i]</code> 表示重量为 <code>i</code> 是否可以由数组中的石头组成。我们遍历石头数组，对于每块石头，更新 <code>dp</code> 数组的值。最终，我们检查 <code>dp</code> 数组，从总重量的一半开始向下查找，第一个为 <code>true</code> 的位置就表示最接近总重量一半的重量。</p><h3 id="【实现代码】-8"><a href="#【实现代码】-8" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把一堆石头分成两堆,求两堆石头重量差最小值 进一步分析：要让差值小,两堆石头的重量都要接近sum/2;</span></span><br><span class="line"><span class="comment">// 即容量为sum/2下的最大重量</span></span><br><span class="line"><span class="comment">// @doc https://leetcode.cn/problems/last-stone-weight-ii/solutions/805162/yi-pian-wen-zhang-chi-tou-bei-bao-wen-ti-5lfv/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lastStoneWeightII</span><span class="params">(stones []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// dp[i][j]从前i个物品中选放在容量为j的背包的最大值</span></span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, weight := <span class="keyword">range</span> stones &#123;</span><br><span class="line">sum += weight</span><br><span class="line">&#125;</span><br><span class="line">avg := sum / <span class="number">2</span></span><br><span class="line">dp := <span class="built_in">make</span>([]<span class="type">int</span>, avg+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(stones); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := avg; j &gt;= stones[i]; j-- &#123;</span><br><span class="line">dp[j] = max(dp[j], dp[j-stones[i]]+stones[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum - dp[avg]*<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494 目标和"></a>494 目标和</h2><h3 id="【题目描述】-9"><a href="#【题目描述】-9" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>target</code>。</p><p>向数组中的每个整数前添加 <code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code>，然后串联起所有整数，可以构造一个表达式。</p><p>返回可以通过上述操作得到该目标数的不同表达式的数量。</p><h3 id="【解题思路】-9"><a href="#【解题思路】-9" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题实质上是一个组合问题，可以转化为一个动态规划问题，类似于背包问题。我们可以将所有数字分为两部分，一部分数字总和为 <code>P</code>，另一部分数字总和为 <code>N</code>，其中 <code>P</code> 使用 <code>&#39;+&#39;</code> 操作，<code>N</code> 使用 <code>&#39;-&#39;</code> 操作。因此，我们得到等式 <code>P - N = target</code>。同时，我们知道 <code>P + N = sum</code>，其中 <code>sum</code> 是数组 <code>nums</code> 的所有元素之和。联立这两个等式，可以解得 <code>P = (target + sum) / 2</code>。问题转化为了从数组 <code>nums</code> 中选取若干个元素，使得这些元素的和为 <code>(target + sum) / 2</code>，计算有多少种选取方式。</p><p>动态规划的状态定义为 <code>dp[i][j]</code>，表示从数组的 <code>[0, i]</code> 区间内选取若干个整数，是否存在一种选取方式使得被选取的整数的和为 <code>j</code>。状态转移方程为 <code>dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i]]</code>。</p><h3 id="【实现代码】-9"><a href="#【实现代码】-9" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findTargetSumWays</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        sum += num</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> abs(target) &gt; sum || (target+sum)%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    target = (target + sum) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, target+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// 初始化，没有选择任何元素时，和为0的方式有1种</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">for</span> j := target; j &gt;= num; j-- &#123;</span><br><span class="line">            dp[j] += dp[j-num]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">abs</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="474-一和零"><a href="#474-一和零" class="headerlink" title="474 一和零"></a>474 一和零</h2><h3 id="【题目描述】-10"><a href="#【题目描述】-10" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你一个二进制字符串数组 <code>strs</code> 和两个整数 <code>m</code> 和 <code>n</code>。</p><p>请你找出并返回 <code>strs</code> 的最大子集的大小，该子集中最多有 <code>m</code> 个 0 和 <code>n</code> 个 1。</p><p>如果 <code>x</code> 的所有元素也是 <code>y</code> 的元素，集合 <code>x</code> 是集合 <code>y</code> 的子集。</p><h3 id="【解题思路】-10"><a href="#【解题思路】-10" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题可以看作是一个二维的0-1背包问题。这里有两个限制条件（0的数量不超过<code>m</code>，1的数量不超过<code>n</code>），我们的目标是在这两个限制条件下，选择尽可能多的字符串。</p><p>动态规划的状态可以定义为 <code>dp[i][j]</code>，表示使用 <code>i</code> 个 0 和 <code>j</code> 个 1 时能构成的最大子集大小。状态转移方程为：<code>dp[i][j] = max(dp[i][j], dp[i-zero][j-one] + 1)</code>。这里 <code>zero</code> 和 <code>one</code> 分别表示当前字符串中0和1的数量。</p><p>算法的基本思路是遍历每个字符串，对于每个字符串，更新动态规划表格。由于更新当前状态只依赖于之前的状态，为了避免覆盖之前的状态，我们需要从大到小更新 <code>dp[i][j]</code>。</p><h3 id="【实现代码】-10"><a href="#【实现代码】-10" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaxForm</span><span class="params">(strs []<span class="type">string</span>, m <span class="type">int</span>, n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="type">int</span>, m+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, str := <span class="keyword">range</span> strs &#123;</span><br><span class="line">        zero, one := countZeroAndOne(str)</span><br><span class="line">        <span class="keyword">for</span> i := m; i &gt;= zero; i-- &#123;</span><br><span class="line">            <span class="keyword">for</span> j := n; j &gt;= one; j-- &#123;</span><br><span class="line">                dp[i][j] = max(dp[i][j], dp[i-zero][j-one]+<span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// countZeroAndOne 计算一个字符串中0和1的数量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countZeroAndOne</span><span class="params">(str <span class="type">string</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">    zero, one := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, char := <span class="keyword">range</span> str &#123;</span><br><span class="line">        <span class="keyword">if</span> char == <span class="string">&#x27;0&#x27;</span> &#123;</span><br><span class="line">            zero++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            one++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> zero, one</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// max 返回两个整数中的较大值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518 零钱兑换 II"></a>518 零钱兑换 II</h2><h3 id="【题目描述】-11"><a href="#【题目描述】-11" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p><p>请你计算并返回可以凑成总金额所需的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code>。</p><p>假设每一种面额的硬币有无限个。 </p><p>题目数据保证结果符合 32 位带符号整数。</p><h3 id="【解题思路】-11"><a href="#【解题思路】-11" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题可以用动态规划（Dynamic Programming，DP）来解决。我们可以维护一个一维的DP数组 <code>dp</code>，其中 <code>dp[i]</code> 表示组成金额 <code>i</code> 的硬币组合数。初始时，<code>dp[0] = 1</code>，因为组成金额0的方式只有一种，即不选择任何硬币。</p><p>对于每一种硬币，我们遍历 <code>dp</code> 数组，更新组成各个金额的组合数。对于每个金额 <code>i</code> 和每个硬币 <code>coin</code>，如果 <code>i</code> 大于等于 <code>coin</code> 的面额，则 <code>dp[i] += dp[i - coin]</code>。这里 <code>dp[i - coin]</code> 表示在当前硬币面额基础上，组成金额 <code>i - coin</code> 的组合数目，所以将其加到 <code>dp[i]</code> 上，从而更新组成金额 <code>i</code> 的组合数。</p><h3 id="【实现代码】-11"><a href="#【实现代码】-11" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(amount <span class="type">int</span>, coins []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, amount+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// 初始化，金额为0的组合数为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//是组合问题，所以是先物品再背包</span></span><br><span class="line">    <span class="keyword">for</span> _, coin := <span class="keyword">range</span> coins &#123;</span><br><span class="line">        <span class="keyword">for</span> i := coin; i &lt;= amount; i++ &#123;</span><br><span class="line">            dp[i] += dp[i-coin]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[amount]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377 组合总和 Ⅳ"></a>377 组合总和 Ⅳ</h2><h3 id="【题目描述】-12"><a href="#【题目描述】-12" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> 和一个目标整数 <code>target</code>，请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的组合的个数。</p><p>题目数据保证答案符合 32 位整数范围。</p><h3 id="【解题思路】-12"><a href="#【解题思路】-12" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题可以通过动态规划来解决。我们可以定义一个数组 <code>dp</code>，其中 <code>dp[i]</code> 表示达到总和为 <code>i</code> 的组合个数。初始状态 <code>dp[0] = 1</code>，因为总和为0的方式只有一种，即不选择任何元素。</p><p>接下来，我们对于每一个目标和 <code>i</code>（从1到<code>target</code>），都尝试遍历数组 <code>nums</code> 中的每一个数 <code>num</code>，如果 <code>i - num &gt;= 0</code>，则说明我们可以使用 <code>num</code> 来组成总和 <code>i</code>。因此，我们可以把组成总和为 <code>i - num</code> 的方式数加到 <code>dp[i]</code> 上，即 <code>dp[i] += dp[i - num]</code>。</p><p>这样，我们从 <code>1</code> 遍历到 <code>target</code>，最终 <code>dp[target]</code> 就是我们想要的答案。</p><h3 id="【实现代码】-12"><a href="#【实现代码】-12" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum4</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, target+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// 初始化，只有一种方式组成总和为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//排列问题只能先背包再物品</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= target; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">            <span class="keyword">if</span> i-num &gt;= <span class="number">0</span> &#123;</span><br><span class="line">                dp[i] += dp[i-num]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[target]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322 零钱兑换"></a>322 零钱兑换</h2><h3 id="【题目描述】-13"><a href="#【题目描述】-13" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你一个整数数组 <code>coins</code>，表示不同面额的硬币；以及一个整数 <code>amount</code>，表示总金额。计算并返回可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code>。你可以认为每种硬币的数量是无限的。</p><h3 id="【解题思路】-13"><a href="#【解题思路】-13" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题是一个典型的动态规划问题。我们可以创建一个数组 <code>dp</code> 来保存达到每个金额所需的最小硬币数。<code>dp[i]</code> 表示达到金额 <code>i</code> 所需的最小硬币数。</p><p>初始时，<code>dp[0] = 0</code> 因为金额为0时不需要任何硬币。对于所有其他金额，我们可以初始化为一个大数，例如 <code>amount + 1</code>，代表无法达到该金额。</p><p>然后，我们遍历每个金额，对于每个金额，我们又遍历每种硬币，如果当前硬币面额不超过当前金额，我们更新 <code>dp[i]</code> 为 <code>min(dp[i], dp[i - coin] + 1)</code>。这里 <code>dp[i - coin] + 1</code> 表示使用这种硬币之前的最小硬币数加上这一枚硬币。</p><p>最后，我们检查 <code>dp[amount]</code> 的值，如果它没有被更新过（即还是初始值 <code>amount + 1</code>），则表示无法达到该金额，返回 <code>-1</code>。否则，返回 <code>dp[amount]</code>。</p><h3 id="【实现代码】-13"><a href="#【实现代码】-13" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coinChange</span><span class="params">(coins []<span class="type">int</span>, amount <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, amount+<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 初始化dp数组，除了dp[0]为0外，其余设为一个大数</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= amount; i++ &#123;</span><br><span class="line">        dp[i] = amount + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= amount; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> _, coin := <span class="keyword">range</span> coins &#123;</span><br><span class="line">            <span class="keyword">if</span> coin &lt;= i &#123;</span><br><span class="line">                dp[i] = min(dp[i], dp[i-coin]+<span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> dp[amount] &gt; amount &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span> <span class="comment">// 表示无法凑成该金额</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// min 返回两个整数中的较小值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279 完全平方数"></a>279 完全平方数</h2><h3 id="【题目描述】-14"><a href="#【题目描述】-14" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定正整数 <code>n</code>，找到若干个完全平方数（例如，1, 4, 9, 16, …）使得它们的和等于 <code>n</code>。你需要让组成和的完全平方数的个数最少。</p><h3 id="【解题思路】-14"><a href="#【解题思路】-14" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题可以通过动态规划来解决。我们创建一个数组 <code>dp</code>，其中 <code>dp[i]</code> 表示数字 <code>i</code> 最少可以由几个完全平方数相加组成。初始时，<code>dp[0] = 0</code>，因为数字0不需要任何完全平方数就能组成。</p><p>对于每个数字 <code>i</code>（从1到 <code>n</code>），我们初始化 <code>dp[i]</code> 为一个较大的数，例如 <code>i</code> 自身（因为最坏的情况下，<code>i</code> 可以由 <code>i</code> 个1相加组成）。然后，我们遍历所有小于等于 <code>i</code> 的完全平方数 <code>j*j</code>，更新 <code>dp[i]</code> 为 <code>min(dp[i], dp[i - j*j] + 1)</code>。这里 <code>dp[i - j*j] + 1</code> 表示数字 <code>i</code> 可以由数字 <code>i - j*j</code> 加上一个完全平方数 <code>j*j</code> 组成，因此更新 <code>dp[i]</code> 为这两者之间的较小值。</p><p>最终，<code>dp[n]</code> 就是答案，即数字 <code>n</code> 最少可以由几个完全平方数组成。</p><h3 id="【实现代码】-14"><a href="#【实现代码】-14" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numSquares</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">dp := <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line"><span class="comment">// 10000是最大值</span></span><br><span class="line">dp[i] = <span class="number">100001</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//完全背包</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line"><span class="comment">//排列问题 先遍历物品再遍历背包</span></span><br><span class="line"><span class="keyword">for</span> j := i * i; j &lt;= n; j++ &#123;</span><br><span class="line">dp[j] = min(dp[j], dp[j-i*i]+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// min 返回两个整数中的较小值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139 单词拆分"></a>139 单词拆分</h2><h3 id="【题目描述】-15"><a href="#【题目描述】-15" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你一个非空字符串 <code>s</code> 和一个包含非空单词的列表 <code>wordDict</code>，判定 <code>s</code> 是否可以被空格拆分为一个或多个在字典中出现的单词。</p><p>说明：</p><ul><li>拆分时可以重复使用字典中的单词。</li><li>你可以假设字典中没有重复的单词。</li></ul><h3 id="【解题思路】-15"><a href="#【解题思路】-15" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题可以通过动态规划来解决。我们定义一个布尔数组 <code>dp</code>，其中 <code>dp[i]</code> 表示字符串 <code>s</code> 的前 <code>i</code> 个字符（<code>s[0...i-1]</code>）能否被分割成一个或多个字典中出现的单词。初始时，<code>dp[0]</code> 为 <code>true</code>，因为空字符串总是字典中单词的有效组合。</p><p>接下来，对于字符串 <code>s</code> 的每一个位置 <code>i</code>（从1到字符串长度），我们遍历 <code>i</code> 之前的所有位置 <code>j</code>（从0到 <code>i-1</code>），检查 <code>s[j...i-1]</code>（即从第 <code>j</code> 个字符到第 <code>i-1</code> 个字符的子串）是否是字典中的单词，并且 <code>dp[j]</code> 是否为 <code>true</code>。如果这两个条件都满足，那么说明 <code>s[0...i-1]</code> 可以被分割成字典中的单词，我们将 <code>dp[i]</code> 设置为 <code>true</code>。</p><p>最终，<code>dp[s.length]</code> 的值就是我们想要的答案，它表示整个字符串 <code>s</code> 能否被分割成字典中的单词。</p><h3 id="【实现代码】-15"><a href="#【实现代码】-15" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wordBreak</span><span class="params">(s <span class="type">string</span>, wordDict []<span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    wordDictSet := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> _, word := <span class="keyword">range</span> wordDict &#123;</span><br><span class="line">        wordDictSet[word] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(s)+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span> <span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> dp[j] &amp;&amp; wordDictSet[s[j:i]] &#123;</span><br><span class="line">                dp[i] = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="built_in">len</span>(s)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198 打家劫舍"></a>198 打家劫舍</h2><h3 id="【题目描述】-16"><a href="#【题目描述】-16" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><h3 id="【解题思路】-16"><a href="#【解题思路】-16" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题可以使用动态规划来解决。我们可以创建一个数组 <code>dp</code>，其中 <code>dp[i]</code> 表示从第 <code>0</code> 个房间到第 <code>i</code> 个房间可以偷窃到的最高金额。对于每个房间 <code>i</code>，小偷有两个选择：偷窃或不偷窃。</p><ul><li>如果小偷选择偷窃房间 <code>i</code>，那么他不能偷窃房间 <code>i-1</code>，所以他可以偷窃到的最高金额是房间 <code>i</code> 的金额加上 <code>dp[i-2]</code>。</li><li>如果小偷选择不偷窃房间 <code>i</code>，那么他可以偷窃到的最高金额就是 <code>dp[i-1]</code>。</li></ul><p>因此，我们可以得到状态转移方程：<code>dp[i] = max(dp[i-1], nums[i] + dp[i-2])</code>。</p><p>我们从第一个房间开始，使用这个状态转移方程来计算每个房间可以偷窃到的最高金额，最后 <code>dp[n-1]</code> 就是我们想要的答案，其中 <code>n</code> 是房间的总数。</p><h3 id="【实现代码】-16"><a href="#【实现代码】-16" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rob</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">    dp[<span class="number">1</span>] = max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt; n; i++ &#123;</span><br><span class="line">        dp[i] = max(dp[i<span class="number">-1</span>], nums[i]+dp[i<span class="number">-2</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213 打家劫舍 II"></a>213 打家劫舍 II</h2><h3 id="【题目描述】-17"><a href="#【题目描述】-17" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是相邻的。再次给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><h3 id="【解题思路】-17"><a href="#【解题思路】-17" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这道题是打家劫舍的升级版，由于房屋围成一圈的特殊结构，我们不能同时偷窃第一个房屋和最后一个房屋。这就意味着有两种情况：一种是偷窃第一个房屋到倒数第二个房屋，另一种是偷窃第二个房屋到最后一个房屋。我们只需要分别计算这两种情况下可以偷窃到的最高金额，然后取二者的较大值即可。</p><p>我们可以复用打家劫舍 I 的逻辑来计算给定起始点和结束点的最大偷窃金额。具体来说，我们定义一个辅助函数 <code>robRange</code>，它接受房屋金额数组 <code>nums</code> 和两个索引 <code>start</code> 和 <code>end</code>，计算在 <code>[start, end]</code> 范围内可以偷窃到的最高金额。</p><p>最终，我们比较 <code>robRange(nums, 0, n-2)</code> 和 <code>robRange(nums, 1, n-1)</code> 的结果（其中 <code>n</code> 是房屋的总数），返回二者中的较大值。</p><h3 id="【实现代码】-17"><a href="#【实现代码】-17" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rob</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(nums)</span><br><span class="line"><span class="keyword">if</span> n &lt;= <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> n &lt;= <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">return</span> max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> max(doRob(nums[<span class="number">0</span>:n<span class="number">-1</span>]), doRob(nums[<span class="number">1</span>:n]))</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doRob</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(nums)</span><br><span class="line"><span class="keyword">if</span> n&lt;=<span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line">dp := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">dp[<span class="number">1</span>] = max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">2</span>;i&lt;n;i++ &#123;</span><br><span class="line">dp[i] = max(dp[i<span class="number">-2</span>]+nums[i],dp[i<span class="number">-1</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="337-打家劫舍-III"><a href="#337-打家劫舍-III" class="headerlink" title="337 打家劫舍 III"></a>337 打家劫舍 III</h2><h3 id="【题目描述】-18"><a href="#【题目描述】-18" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>在上次打劫完一条街道之后和一圈房屋后，小偷再次发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列形成了一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p><p>计算在不触动警报的情况下，小偷一夜之内能够偷窃到的最高金额。</p><h3 id="【解题思路】-18"><a href="#【解题思路】-18" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这是一个经典的动态规划问题，可以用树形动态规划的方式来解决。对于树上的每个节点，有两种状态：偷或不偷。</p><ul><li>如果偷当前节点，那么两个子节点就不能偷；</li><li>如果不偷当前节点，那么两个子节点可以偷，也可以不偷（取决于哪种方案能得到更大的金额）。</li></ul><p>因此，对于每个节点，我们需要返回两个值：一个是偷这个节点能得到的最大金额，另一个是不偷这个节点能得到的最大金额。</p><p>我们可以用递归的方式，自底向上地解决这个问题。</p><h3 id="【实现代码】-18"><a href="#【实现代码】-18" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// TreeNode is a binary tree node.</span></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rob returns the maximum amount of money the thief can rob without alerting the police.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rob</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    res := dfs(root)</span><br><span class="line">    <span class="keyword">return</span> max(res[<span class="number">0</span>], res[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dfs returns two values, the first is the maximum amount of money when robbing the current node,</span></span><br><span class="line"><span class="comment">// and the second is the maximum amount when not robbing the current node.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(node *TreeNode)</span></span> [<span class="number">2</span>]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">2</span>]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    left := dfs(node.Left)</span><br><span class="line">    right := dfs(node.Right)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rob the current node, cannot rob its children</span></span><br><span class="line">    rob := node.Val + left[<span class="number">1</span>] + right[<span class="number">1</span>]</span><br><span class="line">    <span class="comment">// Do not rob the current node, choose the maximum amount of its children</span></span><br><span class="line">    notRob := max(left[<span class="number">0</span>], left[<span class="number">1</span>]) + max(right[<span class="number">0</span>], right[<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [<span class="number">2</span>]<span class="type">int</span>&#123;rob, notRob&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121 买卖股票的最佳时机"></a>121 买卖股票的最佳时机</h2><h3 id="【题目描述】-19"><a href="#【题目描述】-19" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个数组，它的第 <code>i</code> 个元素是一支给定股票第 <code>i</code> 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p><p>注意：你不能在买入股票前卖出股票。</p><h3 id="【解题思路】-19"><a href="#【解题思路】-19" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>动态规划是一种通过把原问题分解为相对简单的子问题的方式来求解复杂问题的方法。对于本题，我们可以维护两个变量，<code>minPrice</code>和<code>maxProfit</code>。<code>minPrice</code>是到当前价格为止的最低股票价格，<code>maxProfit</code>是我们可以获得的最大利润。</p><p>我们初始化<code>minPrice</code>为<code>int</code>的最大值，<code>maxProfit</code>为0。然后遍历价格数组，对于每个价格，我们首先更新<code>minPrice</code>，使其为当前价格和之前的<code>minPrice</code>中的较小值。然后，我们计算当前价格卖出的利润（当前价格减去<code>minPrice</code>），如果这个利润比我们之前记录的<code>maxProfit</code>要大，我们就更新<code>maxProfit</code>。</p><p>通过这种方法，我们只需要遍历一次数组，就可以找到最低购买价格和最高卖出价格之间的最大差值，即最大利润。</p><h3 id="【实现代码】-19"><a href="#【实现代码】-19" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">//只能进行一次交易</span></span><br><span class="line"><span class="comment">//dp[i][0]在第i天交易完后手上有股票的最大利润</span></span><br><span class="line"><span class="comment">//dp[i][1]在第i天交易完后手上没有股票的最大利润</span></span><br><span class="line">dp := <span class="built_in">make</span>([][<span class="number">2</span>]<span class="type">int</span>, <span class="built_in">len</span>(prices))</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="built_in">len</span>(prices);i++ &#123;</span><br><span class="line"><span class="comment">//持有 昨天持有，今天买入的持有</span></span><br><span class="line">dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], -prices[i])</span><br><span class="line"><span class="comment">//不持有</span></span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>]+prices[i])</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[<span class="built_in">len</span>(prices)<span class="number">-1</span>][<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//贪心</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(prices) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    minPrice := prices[<span class="number">0</span>]</span><br><span class="line">    maxProfit := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(prices); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> prices[i] &lt; minPrice &#123;</span><br><span class="line">            minPrice = prices[i]</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> prices[i] - minPrice &gt; maxProfit &#123;</span><br><span class="line">            maxProfit = prices[i] - minPrice</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122 买卖股票的最佳时机 II"></a>122 买卖股票的最佳时机 II</h2><h3 id="【题目描述】-20"><a href="#【题目描述】-20" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个数组 prices ，其中 prices[i] 表示股票第 i 天的价格。<br>在每一天，你可能会决定购买和&#x2F;或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以购买它，然后在 同一天 出售。<br>返回 你能获得的 最大 利润 。</p><h3 id="【解题思路】-20"><a href="#【解题思路】-20" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这道题可以使用动态规划来解决。我们可以定义两个变量：</p><ol><li><code>hold</code>：表示当前持有股票时的最大利润</li><li><code>notHold</code>：表示当前不持有股票时的最大利润</li></ol><p>对于每一天，我们可以选择持有股票或不持有股票，并更新相应的最大利润：</p><ol><li>如果选择持有股票，那么最大利润为前一天不持有股票的利润减去当天股票的价格，即 <code>hold = notHold - prices[i]</code></li><li>如果选择不持有股票，那么最大利润为前一天持有股票的利润加上当天股票的价格，即 <code>notHold = max(notHold, hold + prices[i])</code></li></ol><p>最终，不持有股票时的最大利润即为所求的最大利润。</p><h3 id="【实现代码】-20"><a href="#【实现代码】-20" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123; </span><br><span class="line"><span class="comment">//0 第i天手上持有股票，1没有股票</span></span><br><span class="line"><span class="comment">//dp[i][0]</span></span><br><span class="line">n := <span class="built_in">len</span>(prices)</span><br><span class="line">dp := <span class="built_in">make</span>([][<span class="number">2</span>]<span class="type">int</span>, n)</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;n;i++ &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>]-prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>]+prices[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不持有股票肯定收益更大</span></span><br><span class="line"><span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//贪心</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123; </span><br><span class="line">res := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(prices);i++ &#123;</span><br><span class="line"><span class="keyword">if</span> prices[i]-prices[i<span class="number">-1</span>] &gt; <span class="number">0</span>&#123;</span><br><span class="line"><span class="comment">//累加利润为正的和就是最大利润</span></span><br><span class="line">res += prices[i]-prices[i<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="123-买卖股票的最佳时机-III"><a href="#123-买卖股票的最佳时机-III" class="headerlink" title="123 买卖股票的最佳时机 III"></a>123 买卖股票的最佳时机 III</h2><p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。<br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>使用三维数组的动态规划来解决“买卖股票的最佳时机 III”问题，可以帮助我们更清晰地理解状态之间的转移关系。在这种方法中，我们将使用一个三维数组 <code>dp</code> 来存储到达每一天，进行了0次、1次或2次交易，并且当前是否持有股票的最大利润。</p><h3 id="【解题思路】-21"><a href="#【解题思路】-21" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><ol><li><p><strong>状态定义：</strong> <code>dp[i][j][k]</code> 表示在第i天，已经进行了j次交易（j可以取0, 1, 2），当前持有状态为k时（k可以取0或1，0表示不持有，1表示持有）的最大利润。</p></li><li><p><strong>状态转移：</strong></p><ul><li>第i天结束后不持有股票的情况（k&#x3D;0）：<ul><li>前一天也不持有股票，今天什么也没做：<code>dp[i-1][j][0]</code></li><li>前一天持有股票，今天卖出了：<code>dp[i-1][j-1][1] + prices[i]</code></li></ul></li><li>第i天结束后持有股票的情况（k&#x3D;1）：<ul><li>前一天也持有股票，今天什么也没做：<code>dp[i-1][j][1]</code></li><li>前一天不持有股票，今天买入了：<code>dp[i-1][j][0] - prices[i]</code></li></ul></li></ul></li><li><p><strong>初始化：</strong></p><ul><li><code>dp[0][0][0] = 0</code> 第0天，0次交易，不持有股票，利润为0。</li><li><code>dp[0][0][1] = -prices[0]</code> 第0天，0次交易，持有股票，利润为-prices[0]。</li><li>对于所有j &gt; 0，<code>dp[0][j][0] = 0</code>，<code>dp[0][j][1] = -prices[0]</code>。</li></ul></li><li><p><strong>目标：</strong> <code>max(dp[n-1][j][0])</code>，其中n为天数，j可以取0, 1, 2。</p></li></ol><h3 id="【实现代码】-21"><a href="#【实现代码】-21" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(prices)</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dp := <span class="built_in">make</span>([][][]<span class="type">int</span>, n)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">dp[i] = <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">3</span>) <span class="comment">// 0, 1, 2次交易</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="keyword">range</span> dp[i] &#123;</span><br><span class="line">dp[i][j] = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>) <span class="comment">// 持有状态：0不持有，1持有</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">2</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">2</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt;= <span class="number">2</span>; j++ &#123;</span><br><span class="line">dp[i][j][<span class="number">0</span>] = dp[i<span class="number">-1</span>][j][<span class="number">0</span>]</span><br><span class="line"><span class="keyword">if</span> j &gt; <span class="number">0</span> &#123;</span><br><span class="line">dp[i][j][<span class="number">0</span>] = max(dp[i][j][<span class="number">0</span>], dp[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">1</span>]+prices[i])</span><br><span class="line">&#125;</span><br><span class="line">dp[i][j][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][j][<span class="number">1</span>], dp[i<span class="number">-1</span>][j][<span class="number">0</span>]-prices[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> max(dp[n<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>], max(dp[n<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[n<span class="number">-1</span>][<span class="number">2</span>][<span class="number">0</span>]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">prices := []<span class="type">int</span>&#123;<span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(maxProfit(prices)) <span class="comment">// 输出: 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="188-买卖股票的最佳时机-IV"><a href="#188-买卖股票的最佳时机-IV" class="headerlink" title="188 买卖股票的最佳时机 IV"></a>188 买卖股票的最佳时机 IV</h2><h3 id="【题目描述】-21"><a href="#【题目描述】-21" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个整数数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 是一支给定的股票在第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>k</strong> 笔交易。</p><p><strong>注意：</strong> 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><h3 id="【解题思路】-22"><a href="#【解题思路】-22" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题是“买卖股票的最佳时机”系列问题中的一个更通用的形式。我们可以使用动态规划（DP）算法来解决这个问题。</p><p>动态规划的核心思想在于找出状态转移方程。对于本题，我们可以设 <code>dp[i][j][0]</code> 表示在第 <code>i</code> 天结束时，最多完成 <code>j</code> 笔交易，并且当前不持有股票时的最大利润；<code>dp[i][j][1]</code> 表示在第 <code>i</code> 天结束时，最多完成 <code>j</code> 笔交易，并且当前持有股票时的最大利润。</p><p>状态转移方程如下：</p><ul><li><code>dp[i][j][0] = max(dp[i-1][j][0], dp[i-1][j][1] + prices[i])</code>：表示第 <code>i</code> 天不持有股票的情况下的最大利润，可以从前一天就不持有股票转移过来，或者是前一天持有股票，但在今天卖出了。</li><li><code>dp[i][j][1] = max(dp[i-1][j][1], dp[i-1][j-1][0] - prices[i])</code>：表示第 <code>i</code> 天持有股票的情况下的最大利润，可以从前一天就持有股票转移过来，或者是前一天不持有股票，但在今天买入了。</li></ul><p>初始状态：对于第 <code>0</code> 天，不持有股票的利润是 <code>0</code>；持有股票的利润是 <code>-prices[0]</code>。</p><h3 id="【实现代码】-22"><a href="#【实现代码】-22" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(k <span class="type">int</span>, prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(prices)</span><br><span class="line">dp:=<span class="built_in">make</span>([][][<span class="number">2</span>]<span class="type">int</span>, n)</span><br><span class="line"><span class="comment">//注意是k+1 不是k</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;n;i++ &#123;</span><br><span class="line">dp[i] = <span class="built_in">make</span>([][<span class="number">2</span>]<span class="type">int</span>, k+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//dp[i天][j次交易][0:持有，1：不持有]</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=k;i++ &#123;</span><br><span class="line">dp[<span class="number">0</span>][i][<span class="number">0</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;n;i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">1</span>;j&lt;=k;j++ &#123;</span><br><span class="line"><span class="comment">//持有</span></span><br><span class="line">dp[i][j][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][j][<span class="number">0</span>], dp[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">1</span>]-prices[i])</span><br><span class="line"><span class="comment">//不持有</span></span><br><span class="line">dp[i][j][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][j][<span class="number">1</span>], dp[i<span class="number">-1</span>][j][<span class="number">0</span>]+prices[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n<span class="number">-1</span>][k][<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309 最佳买卖股票时机含冷冻期"></a>309 最佳买卖股票时机含冷冻期</h2><h3 id="【题目描述】-22"><a href="#【题目描述】-22" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个整数数组，其中第 <code>i</code> 个元素代表了第 <code>i</code> 天的股票价格。设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul><li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul><h3 id="【解题思路】-23"><a href="#【解题思路】-23" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>为了使用二维数组简化动态规划的实现，我们可以定义一个<code>dp</code>数组，其中<code>dp[i][j]</code>表示第<code>i</code>天结束时的最大收益，<code>j</code>有三种状态，分别表示：</p><ul><li><code>0</code>：持有股票（买入股票或保持前一天的持有状态）</li><li><code>1</code>：不持有股票，处于冷冻期（即刚刚卖出股票）</li><li><code>2</code>：不持有股票，不处于冷冻期（可以买入股票）</li></ul><p>状态转移方程如下：</p><ul><li>当<code>j=0</code>时，<code>dp[i][0] = max(dp[i-1][0], dp[i-1][2] - prices[i])</code>，表示第<code>i</code>天持有股票的最大收益。</li><li>当<code>j=1</code>时，<code>dp[i][1] = dp[i-1][0] + prices[i]</code>，表示第<code>i</code>天卖出股票后的最大收益。</li><li>当<code>j=2</code>时，<code>dp[i][2] = max(dp[i-1][2], dp[i-1][1])</code>，表示第<code>i</code>天不持有股票且不处于冷冻期的最大收益。</li></ul><p>初始状态设定：</p><ul><li><code>dp[0][0] = -prices[0]</code>，第一天买入股票</li><li><code>dp[0][1] = 0</code>，第一天不可能处于冷冻期</li><li><code>dp[0][2] = 0</code>，第一天不买股票</li></ul><p>最终，我们需要的答案是<code>max(dp[n-1][1], dp[n-1][2])</code>，即最后一天不持有股票的最大收益。</p><h3 id="【实现代码】-23"><a href="#【实现代码】-23" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">//dp[第i天]【0：持有，1：不持有】的最大利润</span></span><br><span class="line">n := <span class="built_in">len</span>(prices)</span><br><span class="line">dp := <span class="built_in">make</span>([][<span class="number">2</span>]<span class="type">int</span>, n)</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>]</span><br><span class="line"><span class="comment">//卖出, 冷冻期, 买入</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;n;i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">1</span> &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = max(dp[<span class="number">0</span>][<span class="number">0</span>], -prices[<span class="number">1</span>])</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-2</span>][<span class="number">1</span>]-prices[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>]+prices[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">prices := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;Max profit:&quot;</span>, maxProfit(prices))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714 买卖股票的最佳时机含手续费"></a>714 买卖股票的最佳时机含手续费</h2><h3 id="【题目描述】-23"><a href="#【题目描述】-23" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个整数数组 <code>prices</code>，其中第 <code>i</code> 个元素代表了第 <code>i</code> 天的股票价格；非负整数 <code>fee</code> 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要支付手续费。如果你已经购买了一个股票，在你卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><h3 id="【解题思路】-24"><a href="#【解题思路】-24" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>使用动态规划，并采用二维数组来表示状态。在这个问题中，我们定义 <code>dp[i][j]</code>，其中 <code>i</code> 表示第 <code>i</code> 天，<code>j</code> 有两种状态，0 和 1：</p><ul><li><code>j = 0</code> 表示第 <code>i</code> 天结束时不持有股票。</li><li><code>j = 1</code> 表示第 <code>i</code> 天结束时持有股票。</li></ul><p>状态转移方程如下：</p><ul><li>当不持有股票时（<code>j = 0</code>），<code>dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</code>，即前一天也不持有股票，或者前一天持有股票但在第 <code>i</code> 天卖出。</li><li>当持有股票时（<code>j = 1</code>），<code>dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i] - fee)</code>，即前一天也持有股票，或者前一天不持有股票但在第 <code>i</code> 天买入并支付手续费 <code>fee</code>。</li></ul><p>初始状态：</p><ul><li><code>dp[0][0] = 0</code>，第一天结束时不持有股票。</li><li><code>dp[0][1] = -prices[0] - fee</code>，第一天买入股票并支付手续费。</li></ul><p>最终答案是 <code>dp[n-1][0]</code>，表示最后一天结束时不持有股票的最大利润。</p><h3 id="【实现代码】-24"><a href="#【实现代码】-24" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>, fee <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(prices)</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dp := <span class="built_in">make</span>([][<span class="number">2</span>]<span class="type">int</span>, n)</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>] - fee</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i]-fee)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">prices := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">9</span>&#125;</span><br><span class="line">fee := <span class="number">2</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Max profit:&quot;</span>, maxProfit(prices, fee))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300 最长递增子序列"></a>300 最长递增子序列</h2><h3 id="【题目描述】-24"><a href="#【题目描述】-24" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你一个整数数组 <code>nums</code>，找到其中最长严格递增子序列的长度。子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><h3 id="【解题思路】-25"><a href="#【解题思路】-25" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题可以通过动态规划（Dynamic Programming，DP）来解决。基本思路是，创建一个和输入数组 <code>nums</code> 同样长度的数组 <code>dp</code>，其中 <code>dp[i]</code> 表示以 <code>nums[i]</code> 结尾的最长递增子序列的长度。对于数组中的每个元素，我们都遍历它之前的元素，找到一个可以追加当前元素形成更长递增子序列的最长序列。</p><ol><li>初始化 <code>dp</code> 数组，所有元素值为 <code>1</code>，因为最短的递增子序列至少包含它自己。</li><li>遍历 <code>nums</code> 数组，对于每个 <code>nums[i]</code>，再遍历 <code>0</code> 到 <code>i-1</code> 的所有元素 <code>nums[j]</code>。如果 <code>nums[j] &lt; nums[i]</code>，说明 <code>nums[i]</code> 可以跟在 <code>nums[j]</code> 后面形成一个更长的递增子序列，此时更新 <code>dp[i]</code> 为 <code>dp[j] + 1</code> 的最大值。</li><li>遍历完所有元素后，<code>dp</code> 数组中的最大值即为最长递增子序列的长度。</li></ol><h3 id="【实现代码】-25"><a href="#【实现代码】-25" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLIS</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(nums)</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dp := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">dp[i] = <span class="number">1</span> <span class="comment">// 最短的递增子序列至少包含它自己</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">maxLen := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums[j] &lt; nums[i] &#123;</span><br><span class="line">dp[i] = max(dp[i], dp[j]+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">maxLen = max(maxLen, dp[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> maxLen</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">nums := []<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">101</span>, <span class="number">18</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;Length of LIS:&quot;</span>, lengthOfLIS(nums))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="674 最长连续递增序列"></a>674 最长连续递增序列</h2><h3 id="【题目描述】-25"><a href="#【题目描述】-25" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个未经排序的整数数组，找到最长且连续递增的子序列，并返回该序列的长度。连续递增的子序列可以由两个下标 <code>l</code> 和 <code>r</code>（<code>l &lt; r</code>）确定，如果对于每个 <code>l &lt;= i &lt; r</code>，都有 <code>nums[i] &lt; nums[i + 1]</code>，那么子序列 <code>[nums[l], nums[l + 1], ..., nums[r-1], nums[r]]</code> 就是连续递增子序列。</p><h3 id="【解题思路】-26"><a href="#【解题思路】-26" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>虽然这个问题可以不使用动态规划直接通过一次遍历解决，但是为了遵循任务要求，我们可以考虑使用一维动态规划的方式来实现。一维数组 <code>dp</code> 用来记录以 <code>nums[i]</code> 结尾的最长连续递增序列的长度。对于数组中的每个元素，如果 <code>nums[i]</code> 比 <code>nums[i-1]</code> 大，则说明可以延续之前的连续递增序列，否则，这个位置的连续递增序列长度重新开始计数。</p><ol><li>初始化一个和输入数组 <code>nums</code> 同样长度的数组 <code>dp</code>，所有元素值初始化为 <code>1</code>，因为最短的连续递增序列至少包含它自己。</li><li>从第二个元素开始遍历数组 <code>nums</code>，如果 <code>nums[i]</code> 大于 <code>nums[i-1]</code>，则 <code>dp[i] = dp[i-1] + 1</code>，意味着以 <code>nums[i]</code> 结尾的最长连续递增序列长度可以基于前一个元素的长度加一。</li><li>遍历过程中记录 <code>dp</code> 数组的最大值，即为最长连续递增序列的长度。</li></ol><h3 id="【实现代码】-26"><a href="#【实现代码】-26" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findLengthOfLCIS</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">//贪心</span></span><br><span class="line">res := <span class="number">1</span></span><br><span class="line">start := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums[i] &lt;= nums[i<span class="number">-1</span>] &#123;</span><br><span class="line">start = i</span><br><span class="line">&#125;</span><br><span class="line">res = max(res, i-start+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态规划</span></span><br><span class="line">n := <span class="built_in">len</span>(nums)</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dp := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">dp[i] = <span class="number">1</span> <span class="comment">// 每个元素至少可以构成长度为1的连续递增序列</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">maxLength := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums[i] &gt; nums[i<span class="number">-1</span>] &#123;</span><br><span class="line">dp[i] = dp[i<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">maxLength = max(maxLength, dp[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> maxLength</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;Length of LCIS:&quot;</span>, findLengthOfLCIS(nums))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718 最长重复子数组"></a>718 最长重复子数组</h2><h3 id="【题目描述】-26"><a href="#【题目描述】-26" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给两个整数数组 <code>A</code> 和 <code>B</code>，返回两个数组中公共的、长度最长的子数组的长度(<strong>需要连续</strong>)。</p><h3 id="【解题思路】-27"><a href="#【解题思路】-27" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题可以用动态规划（Dynamic Programming，DP）来解决。我们可以创建一个二维数组 <code>dp</code>，其中 <code>dp[i][j]</code> 表示以 <code>A[i]</code> 和 <code>B[j]</code> 结尾的最长重复子数组的长度。如果 <code>A[i]</code> 和 <code>B[j]</code> 相等，那么 <code>dp[i][j]</code> 应该是 <code>dp[i-1][j-1] + 1</code>。否则，如果它们不相等，<code>dp[i][j]</code> 应该是 <code>0</code>，因为我们是在寻找连续的、重复的子数组。</p><ol><li>初始化一个 <code>(len(A)+1) * (len(B)+1)</code> 的二维数组 <code>dp</code>，所有元素值为 <code>0</code>。</li><li>遍历数组 <code>A</code> 和 <code>B</code>，对于每一对 <code>i</code> 和 <code>j</code>，如果 <code>A[i-1] == B[j-1]</code>，则更新 <code>dp[i][j] = dp[i-1][j-1] + 1</code>。</li><li>在遍历的过程中，记录 <code>dp</code> 数组中的最大值，这个最大值就是两个数组中公共的、长度最长的子数组的长度。</li></ol><h3 id="【实现代码】-27"><a href="#【实现代码】-27" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findLength</span><span class="params">(nums1 []<span class="type">int</span>, nums2 []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">res := <span class="number">0</span></span><br><span class="line">m, n := <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line"><span class="comment">//nums1[i],nums2[j]对应的最长子数组长度</span></span><br><span class="line">dp := <span class="built_in">make</span>([][]<span class="type">int</span>, m)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums1[<span class="number">0</span>] == nums2[i] &#123;</span><br><span class="line">dp[<span class="number">0</span>][i] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums1[i] == nums2[<span class="number">0</span>] &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//i，j需要从0开始，不然res=max(res, dp[i][j])可能执行不到</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums1[i] == nums2[j] &amp;&amp; i&gt;<span class="number">0</span> &amp;&amp; j&gt;<span class="number">0</span> &#123;</span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] +<span class="number">1</span></span><br><span class="line">&#125; <span class="comment">//要求连续，else就是0，不需要写</span></span><br><span class="line">res = max(res, dp[i][j])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143 最长公共子序列"></a>1143 最长公共子序列</h2><h3 id="【题目描述】-27"><a href="#【题目描述】-27" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长公共子序列的长度。一个字符串的子序列是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。两个字符串的公共子序列是这两个字符串所共同拥有的子序列。</p><h3 id="【解题思路】-28"><a href="#【解题思路】-28" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>解决这个问题的一个有效方法是使用动态规划。我们可以定义一个二维数组 <code>dp</code>，其中 <code>dp[i][j]</code> 表示 <code>text1</code> 中前 <code>i</code> 个字符和 <code>text2</code> 中前 <code>j</code> 个字符的最长公共子序列的长度。基于这个定义，我们可以得出以下状态转移方程：</p><ul><li>如果 <code>text1[i-1] == text2[j-1]</code>，那么 <code>dp[i][j] = dp[i-1][j-1] + 1</code>，因为最后一个字符匹配，我们可以在之前的最长公共子序列的基础上加上这个匹配的字符。</li><li>如果 <code>text1[i-1] != text2[j-1]</code>，那么 <code>dp[i][j] = max(dp[i-1][j], dp[i][j-1])</code>，因为最后一个字符不匹配，我们需要从 <code>text1</code> 的前 <code>i-1</code> 个字符和 <code>text2</code> 的前 <code>j</code> 个字符的最长公共子序列，以及 <code>text1</code> 的前 <code>i</code> 个字符和 <code>text2</code> 的前 <code>j-1</code> 个字符的最长公共子序列中找到最长的那一个。</li></ul><p>初始化时，<code>dp[0][j]</code> 和 <code>dp[i][0]</code> 都应该为 <code>0</code>，因为一个字符串与一个空字符串的最长公共子序列长度显然为 <code>0</code>。</p><h3 id="【实现代码】-28"><a href="#【实现代码】-28" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意和718题的区别</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestCommonSubsequence</span><span class="params">(text1 <span class="type">string</span>, text2 <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">m, n := <span class="built_in">len</span>(text1), <span class="built_in">len</span>(text2)</span><br><span class="line">dp := <span class="built_in">make</span>([][]<span class="type">int</span>, m)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line"><span class="comment">//if equal ,after is 1</span></span><br><span class="line"><span class="keyword">if</span> text2[i] == text1[<span class="number">0</span>] &#123;</span><br><span class="line"><span class="keyword">for</span> j:=i;j&lt;n;j++ &#123;</span><br><span class="line">dp[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> text1[i] == text2[<span class="number">0</span>] &#123;</span><br><span class="line"><span class="keyword">for</span> j:=i;j&lt;m;j++ &#123;</span><br><span class="line">dp[j][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; m; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> text1[i] == text2[j] &#123;</span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">//不要求连续了</span></span><br><span class="line">dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数，返回两个整数的较大值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1035-不相交的线"><a href="#1035-不相交的线" class="headerlink" title="1035 不相交的线"></a>1035 不相交的线</h2><h3 id="【题目描述】-28"><a href="#【题目描述】-28" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>在两条独立的水平线上分别给定两个数组 <code>nums1</code> 和 <code>nums2</code>，<code>nums1</code> 和 <code>nums2</code> 中的数互不相同，且只存在于一条线上。现在，我们可以绘制一些连接两个数 <code>nums1[i]</code> 和 <code>nums2[j]</code> 的直线，这些直线需要同时满足满足 <code>i &lt; j</code> 且 <code>nums1[i] == nums2[j]</code>。请找出这样的直线的最大数量，使得这些直线之间不会相交。请注意，即使 <code>nums1[i] == nums2[j]</code> 且 <code>i &lt; j</code>，直线 <code>(nums1[i], nums2[j])</code> 与线段 <code>(i, j)</code> 不相交。也就是说，它们在水平方向上相互不重叠，且在垂直方向上也是如此。</p><h3 id="【解题思路】-29"><a href="#【解题思路】-29" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题可以转化为求两个数组的最长公共子序列问题。因为题目要求找出最多的不相交的直线，这等价于在两个数组中找到最长的相同值序列，且这些值的相对顺序在两个数组中是一致的。</p><p>我们可以使用动态规划的方法来求解这个问题：</p><ol><li>定义一个二维数组 <code>dp</code>，其中 <code>dp[i][j]</code> 表示 <code>nums1</code> 的前 <code>i</code> 个元素（即0-i-1）和 <code>nums2</code> 的前 <code>j</code> 个（即0-j-1）元素可以形成的最长公共子序列的长度。不定义为第0-i的原因是为了简化在$dp[0][i]$处的赋值。</li><li>遍历 <code>nums1</code> 和 <code>nums2</code>，对于每一对 <code>i</code> 和 <code>j</code>，如果 <code>nums1[i-1] == nums2[j-1]</code>，则 <code>dp[i][j] = dp[i-1][j-1] + 1</code>；否则，<code>dp[i][j] = max(dp[i-1][j], dp[i][j-1])</code>。</li><li>最终，<code>dp[m][n]</code>（其中 <code>m</code> 和 <code>n</code> 分别是 <code>nums1</code> 和 <code>nums2</code> 的长度）就是最长公共子序列的长度，也就是最多的不相交直线数量。</li><li></li></ol><h3 id="【实现代码】-29"><a href="#【实现代码】-29" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxUncrossedLines</span><span class="params">(nums1 []<span class="type">int</span>, nums2 []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">m, n := <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">dp := <span class="built_in">make</span>([][]<span class="type">int</span>, m+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= m; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= n; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums1[i<span class="number">-1</span>] == nums2[j<span class="number">-1</span>] &#123;</span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[m][n]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53 最大子数组和"></a>53 最大子数组和</h2><h3 id="【题目描述】-29"><a href="#【题目描述】-29" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你一个整数数组 <code>nums</code>，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。子数组是数组中的一个连续部分。</p><h3 id="【解题思路】-30"><a href="#【解题思路】-30" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题可以用动态规划（DP）来解决。DP的思想是将大问题分解成小问题，然后解决小问题，逐步得到大问题的解。</p><ol><li><p><strong>状态定义</strong>：设 <code>dp[i]</code> 表示以 <code>nums[i]</code> 结尾的最大子数组和。注意，这里的子数组是指以 <code>nums[i]</code> 结尾的，并不是整个数组的任意子数组，这是为了保证状态的转移是可行的。</p></li><li><p><strong>状态转移方程</strong>：要找到以 <code>nums[i]</code> 结尾的最大子数组和，我们有两种选择：要么加上前面的数组得到更大的和，要么不加（如果前面的数组和小于0，加上反而会让和变小），自己单独成为一个子数组。因此，状态转移方程为：<code>dp[i] = max(nums[i], dp[i-1] + nums[i])</code>。</p></li><li><p><strong>初始化</strong>：<code>dp[0] = nums[0]</code>，因为当数组只有一个元素时，最大子数组和就是它自己。</p></li><li><p><strong>答案</strong>：遍历 <code>dp</code> 数组，找到最大的 <code>dp[i]</code>，这就是整个数组的最大子数组和。</p></li></ol><h3 id="【实现代码】-30"><a href="#【实现代码】-30" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化dp数组，dp[i]表示以nums[i]结尾的最大子数组和</span></span><br><span class="line">dp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">maxSum := dp[<span class="number">0</span>] <span class="comment">// 初始化最大和为第一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态规划填表</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">dp[i] = max(nums[i], dp[i<span class="number">-1</span>]+nums[i])</span><br><span class="line">maxSum = max(maxSum, dp[i]) <span class="comment">// 更新最大子数组和</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> maxSum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数，返回两个整数中的较大值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392 判断子序列"></a>392 判断子序列</h2><h3 id="【题目描述】-30"><a href="#【题目描述】-30" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定字符串 <code>s</code> 和 <code>t</code>，判断 <code>s</code> 是否为 <code>t</code> 的子序列。你可以认为 <code>s</code> 和 <code>t</code> 中仅包含英文小写字母。字符串 <code>t</code> 可能会非常长（长度 ~&#x3D; 500,000），而 <code>s</code> 是个短字符串（长度 &lt;&#x3D;100）。</p><p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，<code>&quot;ace&quot;</code>是<code>&quot;abcde&quot;</code>的一个子序列，而<code>&quot;aec&quot;</code>不是）。</p><h3 id="【解题思路】-31"><a href="#【解题思路】-31" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题可以通过贪心算法来解决，但由于要求使用动态规划，我们也可以通过动态规划的方式来思考。动态规划通常不是解决这类问题的最优解，但是为了满足题目要求，我们可以尝试构建一个解决方案。</p><p>然而，直接应用动态规划到这个问题上并不直观，因为通常动态规划用于计算最优解的问题，如最短路径、最大子序列和等，而这个问题是一个判断问题。不过，我们可以将问题转化为求 <code>s</code> 和 <code>t</code> 的最长公共子序列，如果最长公共子序列的长度等于 <code>s</code> 的长度，则说明 <code>s</code> 是 <code>t</code> 的子序列。</p><ol><li><strong>状态定义</strong>：设 <code>dp[i][j]</code> 表示 <code>s</code> 的前 <code>i</code> 个字符和 <code>t</code> 的前 <code>j</code> 个字符的最长公共子序列的长度。</li><li><strong>状态转移方程</strong>：如果 <code>s[i-1] == t[j-1]</code>，则 <code>dp[i][j] = dp[i-1][j-1] + 1</code>；否则，<code>dp[i][j] = max(dp[i-1][j], dp[i][j-1])</code>。</li><li><strong>初始化</strong>：初始化 <code>dp</code> 数组为0。</li><li><strong>答案</strong>：如果 <code>dp[len(s)][len(t)] == len(s)</code>，则 <code>s</code> 是 <code>t</code> 的子序列。</li></ol><h3 id="【实现代码】-31"><a href="#【实现代码】-31" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSubsequence</span><span class="params">(s <span class="type">string</span>, t <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">m, n := <span class="built_in">len</span>(s), <span class="built_in">len</span>(t)</span><br><span class="line">dp := <span class="built_in">make</span>([][]<span class="type">int</span>, m+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= m; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= n; j++ &#123;</span><br><span class="line"><span class="comment">//关于两个序列比较时dp[i][j]表示的都是【i-1】【j-1】时比较，这样能简化【0】【0】处的初始化操作</span></span><br><span class="line"><span class="keyword">if</span> s[i<span class="number">-1</span>] == t[j<span class="number">-1</span>] &#123;</span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[m][n] == m</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSubsequence</span><span class="params">(s <span class="type">string</span>, t <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">i, j := <span class="number">0</span>, <span class="number">0</span> <span class="comment">// 初始化双指针</span></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="built_in">len</span>(s) &amp;&amp; j &lt; <span class="built_in">len</span>(t) &#123;</span><br><span class="line"><span class="keyword">if</span> s[i] == t[j] &#123;</span><br><span class="line">i++ <span class="comment">// 找到匹配的字符，移动指针 i</span></span><br><span class="line">&#125;</span><br><span class="line">j++ <span class="comment">// 无论是否匹配，都移动指针 j</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i == <span class="built_in">len</span>(s) <span class="comment">// 如果 i 移动到了 s 的末尾，说明 s 是 t 的子序列</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="115-不同的子序列"><a href="#115-不同的子序列" class="headerlink" title="115 不同的子序列"></a>115 不同的子序列</h2><h3 id="【题目描述】-31"><a href="#【题目描述】-31" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你两个字符串 <code>s</code> 和 <code>t</code> ，统计并返回在 <code>s</code> 的 <strong>子序列</strong> 中 <code>t</code> 出现的个数。<br>题目数据保证答案符合 32 位带符号整数范围。<br><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;rabbbit&quot;, t = &quot;rabbit&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">如下所示, 有 3 种可以从 s 中得到 &quot;rabbit&quot; 的方案。</span><br><span class="line">rabbbit</span><br><span class="line">rabbbit</span><br><span class="line">rabbbit</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;babgbag&quot;, t = &quot;bag&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">如下所示, 有 5 种可以从 s 中得到 &quot;bag&quot; 的方案。 </span><br><span class="line">babgbag</span><br><span class="line">babgbag</span><br><span class="line">babgbag</span><br><span class="line">babgbag</span><br><span class="line">babgbag</span><br></pre></td></tr></table></figure><h3 id="【解题思路】-32"><a href="#【解题思路】-32" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>在这个实现中，<code>dp[i][j]</code> 表示从 <code>s</code> 的第 <code>i</code> 个字符到第 <code>j</code> 个字符的不同子序列的数量。我们从对角线上的元素开始填充 <code>dp</code> 数组，因为这些元素表示单个字符的子序列数量，始终为 <code>1</code>。然后，我们从右上角开始填充数组的其余部分，使用以下递推关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i+1][j] (if s[i] != s[j])</span><br><span class="line">dp[i][j] = dp[i+1][j] + dp[i][j-1] (if s[i] == s[j])</span><br></pre></td></tr></table></figure><p>最终，<code>dp[0][n]</code> 将包含 <code>s</code> 的所有不同子序列的数量。</p><h3 id="【实现代码】-32"><a href="#【实现代码】-32" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numDistinct</span><span class="params">(s <span class="type">string</span>, t <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">m,n:=<span class="built_in">len</span>(s),<span class="built_in">len</span>(t)</span><br><span class="line"><span class="comment">//以i-1为结尾的s子序列中出现以j-1为结尾的t的个数</span></span><br><span class="line">dp := <span class="built_in">make</span>([][]<span class="type">int</span>, m+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;=m;i++ &#123;</span><br><span class="line">dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;=m;i++ &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] =<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=m;i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">1</span>;j&lt;=n;j++ &#123;</span><br><span class="line"><span class="comment">//使用i-1结尾的元素，不使用i-1结尾的元素</span></span><br><span class="line"><span class="comment">//一部分是用s[i - 1]来匹配，那么个数为dp[i - 1][j - 1]</span></span><br><span class="line"><span class="comment">//一部分是不用s[i - 1]来匹配，个数为dp[i - 1][j]</span></span><br><span class="line"><span class="keyword">if</span> s[i<span class="number">-1</span>] == t[j<span class="number">-1</span>] &#123;</span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + dp[i<span class="number">-1</span>][j]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//当s[i - 1] 与 t[j - 1]不相等时，dp[i][j]只有一部分组成，不用s[i - 1]来匹配（就是模拟在s中删除这个元素），即：dp[i - 1][j]</span></span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[m][n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="583-两个字符串的删除操作"><a href="#583-两个字符串的删除操作" class="headerlink" title="583 两个字符串的删除操作"></a>583 两个字符串的删除操作</h2><h3 id="【题目描述】-32"><a href="#【题目描述】-32" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定两个字符串 <code>word1</code> 和 <code>word2</code>，返回使 <code>word1</code> 和 <code>word2</code> 相同所需的最小删除操作次数。</p><h3 id="【解题思路】-33"><a href="#【解题思路】-33" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>我们可以使用动态规划来解决这个问题。我们创建一个二维数组 <code>dp</code>，其中 <code>dp[i][j]</code> 表示删除 <code>word1</code> 的前 <code>i</code> 个字符和 <code>word2</code> 的前 <code>j</code> 个字符后，使剩余字符串相同的最小删除操作次数。</p><p>我们从 <code>dp[0][0] = 0</code> 开始，因为空字符串不需要任何删除操作即可变成相等。对于 <code>word1</code> 的每个字符，我们检查它是否与 <code>word2</code> 的当前字符匹配。如果匹配，则 <code>dp[i][j]</code> 等于 <code>dp[i-1][j-1]</code>（不进行任何删除操作）。如果不匹配，则 <code>dp[i][j]</code> 等于 <code>dp[i-1][j]</code>（删除 <code>word1</code> 的当前字符）和 <code>dp[i][j-1]</code>（删除 <code>word2</code> 的当前字符）中的最小值加上 <code>1</code>。</p><h3 id="【实现代码】-33"><a href="#【实现代码】-33" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minDistance</span><span class="params">(word1 <span class="type">string</span>, word2 <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    m, n := <span class="built_in">len</span>(word1), <span class="built_in">len</span>(word2)</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="type">int</span>, m+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>] &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = min(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]) + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72 编辑距离"></a>72 编辑距离</h2><h3 id="【题目描述】-33"><a href="#【题目描述】-33" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定两个字符串 <code>word1</code> 和 <code>word2</code>，计算将 <code>word1</code> 编辑成 <code>word2</code> 所需的最小操作次数。<br>允许的编辑操作包括：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><h3 id="【解题思路】-34"><a href="#【解题思路】-34" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>我们可以使用动态规划来解决这个问题。我们创建一个二维数组 <code>dp</code>，其中 <code>dp[i][j]</code> 表示将 <code>word1</code> 的前 <code>i</code> 个字符编辑成 <code>word2</code> 的前 <code>j</code> 个字符所需的最小操作次数。</p><p>我们从 <code>dp[0][0] = 0</code> 开始，因为空字符串不需要任何编辑操作即可变成相等。对于 <code>word1</code> 的每个字符，我们检查它是否与 <code>word2</code> 的当前字符匹配。如果匹配，则 <code>dp[i][j]</code> 等于 <code>dp[i-1][j-1]</code>（不进行任何编辑操作）。如果 <code>word1</code> 的当前字符不匹配 <code>word2</code> 的当前字符，则 <code>dp[i][j]</code> 等于 <code>dp[i-1][j]</code>（删除 <code>word1</code> 的当前字符）、<code>dp[i][j-1]</code>（插入 <code>word2</code> 的当前字符）和 <code>dp[i-1][j-1]</code>（替换 <code>word1</code> 的当前字符）中的最小值加上 <code>1</code>。</p><h3 id="【实现代码】-34"><a href="#【实现代码】-34" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(arr ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">res := arr[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="built_in">len</span>(arr);i++ &#123;</span><br><span class="line"><span class="keyword">if</span> arr[i] &lt; res &#123;</span><br><span class="line">res = arr[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minDistance</span><span class="params">(word1 <span class="type">string</span>, word2 <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">m, n := <span class="built_in">len</span>(word1), <span class="built_in">len</span>(word2)</span><br><span class="line"><span class="comment">//其中 dp[i][j] 表示将 word1 的前 i 个字符编辑成 word2 的前 j 个字符所需的最小操作次数</span></span><br><span class="line">dp := <span class="built_in">make</span>([][]<span class="type">int</span> ,m +<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;=m;i++ &#123;</span><br><span class="line">dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// word2为空的情况，编辑次数为i</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=m;i++ &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=n;i++ &#123;</span><br><span class="line">dp[<span class="number">0</span>][i] = i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=m;i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">1</span>;j&lt;=n;j++ &#123;</span><br><span class="line"><span class="keyword">if</span> word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>] &#123;</span><br><span class="line"><span class="comment">//如果相等，则不需要操作</span></span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//不相等</span></span><br><span class="line"><span class="comment">// 1. 删除word1 dp[i-1][j]+1</span></span><br><span class="line"><span class="comment">// 2. 删除word2 dp[i][j-1]+1</span></span><br><span class="line"><span class="comment">// 3. 替换word1或word2，dp[i-1][j-1] + 1</span></span><br><span class="line"><span class="comment">// 4. 添加，word1添加等于word2删除，所以不需要写添加的代码</span></span><br><span class="line">dp[i][j] = min(dp[i<span class="number">-1</span>][j]+<span class="number">1</span>, dp[i][j<span class="number">-1</span>]+<span class="number">1</span>, dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[m][n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647 回文子串"></a>647 回文子串</h2><h3 id="【题目描述】-34"><a href="#【题目描述】-34" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。具体来说，就是找出有多少个子串是回文的，这里的回文定义与标准回文字符串相同，即正着读和反着读都一样。</p><h3 id="【解题思路】-35"><a href="#【解题思路】-35" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题可以通过动态规划的方式来解决。动态规划是一种解决问题的方法，它将问题分解成更小的子问题，通过解决子问题来解决原问题。</p><p>对于这个问题，我们可以定义一个二维的动态规划数组<code>dp[i][j]</code>，其中<code>i</code>和<code>j</code>是字符串中字符的索引，<code>i</code>&lt;&#x3D;<code>j</code>。如果子字符串<code>s[i...j]</code>是回文，则<code>dp[i][j]</code>为真，否则为假。</p><p>以下是解题的步骤：</p><ol><li>初始化长度为<code>n</code>的字符串<code>s</code>的二维动态规划数组<code>dp</code>，<code>n</code>是字符串<code>s</code>的长度。所有的<code>dp[i][j]</code>初始值为假。</li><li>对于每个字符<code>s[i]</code>，我们都将<code>dp[i][i]</code>设为真，因为每个单独的字符都是回文子串。</li><li>对于长度为2的子串，如果<code>s[i] == s[i+1]</code>，则<code>dp[i][i+1]</code>为真。</li><li>对于长度大于2的子串，如果<code>s[i] == s[j]</code>并且<code>dp[i+1][j-1]</code>为真（即去掉头尾的子串也是回文），则<code>dp[i][j]</code>为真。</li><li>通过上面的步骤，我们可以填满动态规划数组。最后，我们遍历这个数组，计算<code>dp[i][j]</code>为真的个数，即为答案。</li></ol><h3 id="【实现代码】-35"><a href="#【实现代码】-35" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countSubstrings</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(s)</span><br><span class="line"><span class="comment">// dp[i][j]表示的是s[i][j]是否为回文串 [i,j]是闭区间</span></span><br><span class="line">dp := <span class="built_in">make</span>([][]<span class="type">bool</span>, n)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;n;i++ &#123;</span><br><span class="line">dp[i] = <span class="built_in">make</span>([]<span class="type">bool</span>, n)</span><br><span class="line">&#125;</span><br><span class="line">res := <span class="number">0</span></span><br><span class="line"><span class="comment">//注意遍历顺序，[i][j]由[i+1][j-1]推出，所以i由左下到左上遍历</span></span><br><span class="line"><span class="keyword">for</span> i:=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i-- &#123;</span><br><span class="line"><span class="keyword">for</span> j:=i;j&lt;n;j++ &#123;</span><br><span class="line"><span class="keyword">if</span> s[i] == s[j] &#123;</span><br><span class="line"><span class="comment">//i == j</span></span><br><span class="line"><span class="keyword">if</span> i == j &#123;</span><br><span class="line">dp[i][j] = <span class="literal">true</span></span><br><span class="line">res++</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> i == j<span class="number">-1</span> &#123;</span><br><span class="line">dp[i][j] = <span class="literal">true</span></span><br><span class="line">res++</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> i+<span class="number">1</span>&lt;n &amp;&amp; j<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; dp[i+<span class="number">1</span>][j<span class="number">-1</span>] &#123;</span><br><span class="line">dp[i][j] = <span class="literal">true</span></span><br><span class="line">res++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双指针实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countSubstrings</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">    <span class="comment">//回文串 需要分以一个单词为中心如 bab，和两个单词为中心如baab来区分</span></span><br><span class="line">        <span class="comment">// 奇数长度的回文</span></span><br><span class="line">        count += expandAroundCenter(s, i, i)</span><br><span class="line">        <span class="comment">// 偶数长度的回文</span></span><br><span class="line">        count += expandAroundCenter(s, i, i+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从left和right开始向外扩展，计算回文子串的数量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">expandAroundCenter</span><span class="params">(s <span class="type">string</span>, left, right <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> left &gt;= <span class="number">0</span> &amp;&amp; right &lt; <span class="built_in">len</span>(s) &amp;&amp; s[left] == s[right] &#123;</span><br><span class="line">        count++</span><br><span class="line">        left--</span><br><span class="line">        right++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516 最长回文子序列"></a>516 最长回文子序列</h2><h3 id="【题目描述】-35"><a href="#【题目描述】-35" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个字符串<code>s</code>，找到其中最长的回文子序列，并返回该序列的长度。可以假设<code>s</code>的最大长度为<code>1000</code>。</p><h3 id="【解题思路】-36"><a href="#【解题思路】-36" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>要解决这个问题，我们可以使用动态规划。动态规划是一种算法思想，它将大问题分解为小问题，通过解决小问题来解决大问题。</p><p>对于这个问题，我们定义一个二维数组<code>dp</code>，其中<code>dp[i][j]</code>表示字符串<code>s</code>中第<code>i</code>到第<code>j</code>个字符组成的子串中，最长回文子序列的长度。根据定义，我们想要的最终答案就是<code>dp[0][len(s)-1]</code>。</p><p>状态转移方程如下：</p><ul><li>如果<code>s[i] == s[j]</code>，那么<code>dp[i][j] = dp[i+1][j-1] + 2</code>。这是因为如果两端的字符相等，那么它们可以构成回文的一部分，并且加上中间部分的最长回文子序列长度。</li><li>如果<code>s[i] != s[j]</code>，那么<code>dp[i][j] = max(dp[i+1][j], dp[i][j-1])</code>。这是因为两端的字符不能同时作为回文的一部分，我们需要在不包含<code>s[i]</code>和不包含<code>s[j]</code>的子串中找到最长的回文子序列。</li></ul><p>初始化时，当<code>i == j</code>时，<code>dp[i][j]</code>显然等于<code>1</code>，因为任何单个字符都是一个回文子序列。</p><h3 id="【实现代码】-36"><a href="#【实现代码】-36" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindromeSubseq</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(s)</span><br><span class="line"><span class="comment">// dp[i][j]标识s[i][j]之间的最长回文子序列的长度</span></span><br><span class="line">dp := <span class="built_in">make</span>([][]<span class="type">int</span>, n)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;n;i++ &#123;</span><br><span class="line">dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i:=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i-- &#123;</span><br><span class="line"><span class="keyword">for</span> j:=i;j&lt;n;j++ &#123;</span><br><span class="line"><span class="keyword">if</span> s[i] != s[j] &#123;</span><br><span class="line">dp[i][j] = max(dp[i+<span class="number">1</span>][j], dp[i][j<span class="number">-1</span>])</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> i == j &#123;</span><br><span class="line">dp[i][j] = <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> i+<span class="number">1</span> == j &#123;</span><br><span class="line">dp[i][j] = <span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>]+<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数，用于取两个整数中的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">&quot;bbbab&quot;</span></span><br><span class="line">    fmt.Println(longestPalindromeSubseq(s)) <span class="comment">// 输出应为 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42 接雨水"></a>42 接雨水</h2><h3 id="【题目描述】-36"><a href="#【题目描述】-36" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定<code>n</code>个非负整数表示每个宽度为<code>1</code>的柱子的高度图，计算下雨后能接多少雨水。</p><h3 id="【解题思路】-37"><a href="#【解题思路】-37" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>这个问题可以通过动态规划的方式来解决。动态规划的核心思想是将一个复杂问题分解成子问题来逐个击破，并存储已经解决的子问题的答案，在需要时直接使用，从而减少计算量。</p><p>对于接雨水这个问题，我们可以分别计算每个位置左边和右边最高的柱子。然后，对于每个位置，能接的雨水量等于左右两边最高的柱子中较矮那个减去当前位置的高度（如果结果是负数，则当前位置不接雨水，也就是雨水量为0）。</p><ol><li>首先，创建两个数组<code>leftMax</code>和<code>rightMax</code>。<code>leftMax[i]</code>存储位置<code>i</code>左边最高柱子的高度，<code>rightMax[i]</code>存储位置<code>i</code>右边最高柱子的高度。</li><li>从左到右遍历高度图填充<code>leftMax</code>，从右到左遍历高度图填充<code>rightMax</code>。</li><li>再次遍历每个位置，使用<code>min(leftMax[i], rightMax[i]) - height[i]</code>计算每个位置的接水量，如果结果大于0，则累加到总接水量中。</li></ol><h3 id="【实现代码】-37"><a href="#【实现代码】-37" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trap</span><span class="params">(height []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(height) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n := <span class="built_in">len</span>(height)</span><br><span class="line">    leftMax := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    rightMax := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    water := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    leftMax[<span class="number">0</span>] = height[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        leftMax[i] = max(leftMax[i<span class="number">-1</span>], height[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rightMax[n<span class="number">-1</span>] = height[n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">for</span> i := n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        rightMax[i] = max(rightMax[i+<span class="number">1</span>], height[i])</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//两端的列不会存储水</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n<span class="number">-1</span>; i++ &#123;</span><br><span class="line">        water += min(leftMax[i], rightMax[i]) - height[i]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> water</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单调栈实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trap</span><span class="params">(height []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// stack有栈顶到栈底是 小到大   [ 3 2 1</span></span><br><span class="line">stack := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">stack = <span class="built_in">append</span>(stack, <span class="number">0</span>)</span><br><span class="line">water := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i, h := <span class="keyword">range</span> height &#123;</span><br><span class="line"><span class="keyword">if</span> h &lt; height[stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]] &#123;<span class="comment">//比栈顶元素小，入栈</span></span><br><span class="line">stack = <span class="built_in">append</span>(stack, i)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> h == height[stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]] &#123;<span class="comment">//相等，更新栈顶元素</span></span><br><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">stack = <span class="built_in">append</span>(stack, i)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">//小于</span></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &amp;&amp; h &gt; height[stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]] &#123;</span><br><span class="line"><span class="comment">// 当前元素</span></span><br><span class="line">mid := height[stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]]</span><br><span class="line"><span class="comment">// 当前元素出栈</span></span><br><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 计算高度</span></span><br><span class="line">h := min(h, height[stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]]) - mid</span><br><span class="line"><span class="comment">// 计算宽度</span></span><br><span class="line">w := i - stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] - <span class="number">1</span></span><br><span class="line">water += h * w</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">stack = <span class="built_in">append</span>(stack, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> water</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    height := []<span class="type">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>&#125;</span><br><span class="line">    fmt.Println(trap(height)) <span class="comment">// 输出应为 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84 柱状图中最大的矩形"></a>84 柱状图中最大的矩形</h2><h3 id="【题目描述】-37"><a href="#【题目描述】-37" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><h3 id="【解题思路】-38"><a href="#【解题思路】-38" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>本题的关键是找到每根柱子左右两边第一个小于该柱子高度的柱子，这样我们就能确定该柱子能够扩展的最大宽度，从而计算出以该柱子高度为矩形的最大面积。</p><p>为了高效找到每根柱子左右两边的界限，我们可以使用单调栈的数据结构。单调栈可以保证栈内元素保持单调递增或递减，这样当我们遇到一个新的柱子时，就可以通过栈顶元素迅速知道前一个比当前柱子小的柱子，同理，当新的柱子比栈顶元素小，那么我们就找到了栈顶元素右边第一个比它小的柱子。</p><p>具体步骤如下：</p><ol><li>初始化一个栈，为了简化计算，我们在柱状图的两端各添加一个高度为0的柱子。</li><li>从左到右遍历柱状图，对于每根柱子：<ul><li>当前柱子的高度大于栈顶柱子的高度时，将当前柱子的下标入栈。</li><li>当前柱子的高度小于栈顶柱子的高度时，说明找到了栈顶柱子右边第一个比它小的柱子。此时，将栈顶柱子出栈，并计算以该柱子为高度的矩形的面积，直到栈顶柱子的高度小于当前柱子的高度。然后，将当前柱子的下标入栈。</li></ul></li><li>最后，栈中剩余的柱子，它们的右边界都是柱状图的最右边，可以按照步骤2同样的方法计算面积。</li></ol><h3 id="【实现代码】-38"><a href="#【实现代码】-38" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largestRectangleArea</span><span class="params">(heights []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">//防止严格递增或递减的情况，收尾都加上0</span></span><br><span class="line">heights = <span class="built_in">append</span>([]<span class="type">int</span>&#123;<span class="number">0</span>&#125;, heights...)</span><br><span class="line">heights = <span class="built_in">append</span>(heights, <span class="number">0</span>)</span><br><span class="line">stack := []<span class="type">int</span>&#123;<span class="number">0</span>&#125;</span><br><span class="line">res := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i,height := <span class="keyword">range</span> heights &#123;</span><br><span class="line"><span class="keyword">if</span> height &gt; heights[stack[<span class="built_in">len</span>(stack) <span class="number">-1</span>]] &#123;</span><br><span class="line">stack = <span class="built_in">append</span>(stack, i)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> height ==  heights[stack[<span class="built_in">len</span>(stack) <span class="number">-1</span>]] &#123;</span><br><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">stack = <span class="built_in">append</span>(stack, i)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &amp;&amp; height &lt;  heights[stack[<span class="built_in">len</span>(stack) <span class="number">-1</span>]]&#123;</span><br><span class="line">mid := stack[<span class="built_in">len</span>(stack) <span class="number">-1</span>]</span><br><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">l := stack[<span class="built_in">len</span>(stack) <span class="number">-1</span>]</span><br><span class="line">width := i-l<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">res = max(res, width * heights[mid])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">stack = <span class="built_in">append</span>(stack, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数，求两个整数的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心</title>
      <link href="/2024/03/08/leetcode/%E8%B4%AA%E5%BF%83/"/>
      <url>/2024/03/08/leetcode/%E8%B4%AA%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<h1 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h1><p>从局部最优推全局最优，通常需要回溯配合对已做的选择做撤销</p><h1 id="能解决的问题"><a href="#能解决的问题" class="headerlink" title="能解决的问题"></a>能解决的问题</h1><h2 id="135-Candy"><a href="#135-Candy" class="headerlink" title="135. Candy"></a>135. Candy</h2><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>N个小孩排成一排，每个小孩有一个评级值ratings[i]。每个小孩至少要得到一颗糖果。</p><ul><li>评分更高的孩子比邻近的评分较低的孩子获得更多的糖果。</li><li>评分相同的孩子获得相同数量的糖果。</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：ratings = [1,0,2]</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">- 孩子 1 的评分比左右的评分低，所以获得 1 颗糖果。</span><br><span class="line">- 孩子 0 的评分比左右的评分低，所以获得 1 颗糖果。</span><br><span class="line">- 孩子 2 的评分比左边的评分高，所以获得 2 颗糖果。</span><br></pre></td></tr></table></figure><h3 id="【解题思路】"><a href="#【解题思路】" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p><strong>贪心算法</strong></p><ol><li>首先，每个孩子至少要得到一颗糖果，所以我们可以初始化一个数组 <code>candies</code>，每个元素都为 1。</li><li>然后，从左到右遍历数组 <code>ratings</code>：<ul><li>如果当前孩子的评分比左边的孩子高，则当前孩子获得的糖果数为 <code>candies[i] = candies[i - 1] + 1</code>。</li><li>否则，当前孩子获得的糖果数为 <code>candies[i] = 1</code>。</li></ul></li><li>再从右到左遍历数组 <code>ratings</code>：<ul><li>如果当前孩子的评分比右边的孩子高，并且当前孩子获得的糖果数比右边孩子少，则更新当前孩子获得的糖果数为 <code>candies[i] = max(candies[i], candies[i + 1] + 1)</code>。</li></ul></li><li>最后，所有孩子获得的糖果总数为 <code>sum(candies)</code>。</li></ol><p><strong>改进的贪心算法</strong></p><ul><li>我们可以将步骤 2 和步骤 3 合并为一个步骤，从左到右遍历数组 <code>ratings</code>：<ul><li>如果当前孩子的评分比左边的孩子高，则当前孩子获得的糖果数为 <code>candies[i] = max(candies[i - 1] + 1, candies[i])</code>。</li><li>否则，当前孩子获得的糖果数为 <code>candies[i] = 1</code>。</li></ul></li></ul><p><strong>证明：</strong></p><p>假设当前孩子的评分比左边的孩子高，并且当前孩子获得的糖果数为 <code>candies[i] = candies[i - 1] + 1</code>。如果从右到左遍历时，当前孩子获得的糖果数会被更新为 <code>candies[i] = candies[i + 1] + 1</code>，那么说明 <code>candies[i + 1] + 1 &gt; candies[i - 1] + 1</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ratings[i - 1] &lt; ratings[i] &lt; ratings[i + 1]</span><br><span class="line">candies[i - 1] + 1 &lt; candies[i + 1] + 1</span><br></pre></td></tr></table></figure><p>因此，从左到右遍历时，直接将当前孩子获得的糖果数更新为 <code>candies[i] = max(candies[i - 1] + 1, candies[i])</code> 即可保证最终结果正确。</p><h3 id="【实现代码】"><a href="#【实现代码】" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><p>Go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">candy</span><span class="params">(ratings []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(ratings)</span><br><span class="line">    candies := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> candies &#123;</span><br><span class="line">        candies[i] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> ratings[i] &gt; ratings[i<span class="number">-1</span>] &#123;</span><br><span class="line">            candies[i] = max(candies[i<span class="number">-1</span>]+<span class="number">1</span>, candies[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum(candies)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(arr []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">        sum += v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码首先初始化了一个数组 <code>candies</code>，每个元素都为 1。然后，从左到右遍历数组 <code>ratings</code>，根据孩子们的评分比较，更新 <code>candies</code> 数组中的值。最后，计算所有孩子获得的糖果总数并返回。</p><h2 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134. 加油站"></a>134. 加油站</h2><h3 id="【题目描述】-1"><a href="#【题目描述】-1" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>环形道路上有 n 个加油站，每个加油站都存有一定量汽油。你有一辆车，油箱容量无限，但初始时油箱为空。</p><p>你需要从某个加油站出发，沿环形道路行驶，并尽可能多地访问加油站。每当你到达一个加油站时，你可以选择加油或不加油。</p><p><strong>输入：</strong></p><ul><li><code>gas</code>：一个长度为 <code>n</code> 的数组，表示每个加油站的汽油量</li><li><code>cost</code>：一个长度为 <code>n</code> 的数组，表示从一个加油站到相邻加油站的汽油消耗</li></ul><p><strong>输出：</strong></p><ul><li>如果可以环绕一周回到出发点，则返回出发加油站的索引。否则，返回 <code>-1</code></li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入：gas = [1,2,3,4,5], cost = [3,4,5,1,2]</span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">- 从加油站 3 出发，可以获得 4 单位汽油。</span><br><span class="line">- 行驶到加油站 4，消耗 1 单位汽油，剩余 3 单位汽油。</span><br><span class="line">- 行驶到加油站 0，消耗 5 单位汽油，剩余 -2 单位汽油。</span><br><span class="line">- 加油 5 单位汽油，剩余 3 单位汽油。</span><br><span class="line">- 行驶到加油站 1，消耗 4 单位汽油，剩余 -1 单位汽油。</span><br><span class="line">- 加油 4 单位汽油，剩余 3 单位汽油。</span><br><span class="line">- 行驶到加油站 2，消耗 5 单位汽油，剩余 -2 单位汽油。</span><br><span class="line">- 加油 5 单位汽油，剩余 3 单位汽油。</span><br><span class="line">- 行驶到加油站 3，消耗 1 单位汽油，剩余 2 单位汽油。</span><br><span class="line"></span><br><span class="line">最终，可以回到出发加油站 3。</span><br></pre></td></tr></table></figure><h3 id="【解题思路】-1"><a href="#【解题思路】-1" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p><strong>贪心算法</strong></p><ol><li>首先，定义两个变量 <code>total_gas</code> 和 <code>total_cost</code>，分别表示所有加油站的汽油总量和所有路段的汽油消耗总量。</li><li>然后，从某个加油站出发，沿环形道路行驶，并不断更新 <code>total_gas</code> 和 <code>total_cost</code> 的值。</li><li>如果 <code>total_gas &lt; total_cost</code>，则说明无法环绕一周回到出发点，返回 <code>-1</code>。</li><li>如果 <code>total_gas &gt;= total_cost</code>，则说明可以环绕一周回到出发点，返回出发加油站的索引。</li></ol><p><strong>证明：</strong></p><p>如果 <code>total_gas &lt; total_cost</code>，则说明在某个路段，消耗的汽油比该路段提供的汽油更多。因此，不可能从任何加油站出发，环绕一周回到出发点。</p><p>如果 <code>total_gas &gt;= total_cost</code>，则说明总的汽油量足够支持环绕一周。根据贪心算法，我们应该尽可能选择汽油量更多的加油站加油，这样可以减少加油次数，提高效率。因此，从任何加油站出发，最终都可以环绕一周回到出发点。</p><h3 id="【实现代码】-1"><a href="#【实现代码】-1" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><p>Go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canCompleteCircuit</span><span class="params">(gas []<span class="type">int</span>, cost []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(gas)</span><br><span class="line">    total_gas := <span class="number">0</span></span><br><span class="line">    total_cost := <span class="number">0</span></span><br><span class="line">    start := <span class="number">0</span></span><br><span class="line">    current_gas := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        total_gas += gas[i]</span><br><span class="line">        total_cost += cost[i]</span><br><span class="line">        current_gas += gas[i] - cost[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> current_gas &lt; <span class="number">0</span> &#123;</span><br><span class="line">            current_gas = <span class="number">0</span></span><br><span class="line">            start = i + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> total_gas &lt; total_cost &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> start</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1005-K-次取反后最大化的数组和"><a href="#1005-K-次取反后最大化的数组和" class="headerlink" title="1005. K 次取反后最大化的数组和"></a>1005. K 次取反后最大化的数组和</h2><h3 id="【题目描述】-2"><a href="#【题目描述】-2" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：</p><ul><li>选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。</li><li>重复这个过程恰好 k 次。</li><li>可以多次选择同一个下标 i 。</li></ul><p>以这种方式修改数组后，返回数组可能的最大和。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,2,3], k = 1</span><br><span class="line">输出：5</span><br><span class="line">解释：选择下标 1 ，nums 变为[4,-2,3] 。</span><br><span class="line"></span><br><span class="line">输入：nums = [3,-1,0,2], k = 3</span><br><span class="line">输出：6</span><br><span class="line">解释：选择下标 0、1 和 2 ，nums 变为[6,1,0,2] 。</span><br></pre></td></tr></table></figure><h3 id="【解题思路】-2"><a href="#【解题思路】-2" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p><strong>贪心算法</strong></p><ol><li><p>首先，将数组按照绝对值大小从大到小排序，这样可以保证每次取反后，数组和都会增加。</p></li><li><p>然后，从前向后遍历数组：</p><ul><li>如果遇到负数，则将其取反，并将 k 减 1。</li><li>如果 k 为 0，则停止遍历。</li></ul></li><li><p>最后，计算数组的和并返回。</p></li></ol><p><strong>证明：</strong></p><p>由于数组已经按照绝对值大小从大到小排序，因此每次取反后，数组和都会增加。如果 k 为 0，则说明已经取反了 k 次，无法再进行取反操作。因此，此时数组的和就是最大的。</p><h3 id="【实现代码】-2"><a href="#【实现代码】-2" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><p>Go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largestSumAfterKNegations</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">//由大到小排序</span></span><br><span class="line">sort.Slice(nums, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Abs(<span class="type">float64</span>(nums[i])) &gt; math.Abs(<span class="type">float64</span>(nums[j]))</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums) ; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums[i] &lt; <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span>&#123;</span><br><span class="line">nums[i] = -nums[i]</span><br><span class="line">k--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// k还没有用完</span></span><br><span class="line"><span class="keyword">if</span> k &gt; <span class="number">0</span> &amp;&amp; (k&amp;<span class="number">1</span>) == <span class="number">1</span> &#123;</span><br><span class="line">nums[<span class="built_in">len</span>(nums)<span class="number">-1</span>] = -nums[<span class="built_in">len</span>(nums)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">res := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(nums); j++ &#123;</span><br><span class="line">res += nums[j]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码首先将数组按照绝对值大小从大到小排序。然后，从前向后遍历数组，根据 k 的值，决定是否对负数进行取反。最后，计算数组的和并返回。</p><h2 id="45-Jump-Game-II"><a href="#45-Jump-Game-II" class="headerlink" title="45 Jump Game II"></a>45 Jump Game II</h2><h3 id="【题目描述】-3"><a href="#【题目描述】-3" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个非负整数数组 <code>nums</code>，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：2</span><br><span class="line">解释：从下标为 0 跳到下标为 1，然后从下标为 1 跳到下标为 4。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3,0,1,4]</span><br><span class="line">输出：2</span><br><span class="line">解释：从下标为 0 跳到下标为 1，然后从下标为 1 跳到下标为 4。</span><br></pre></td></tr></table></figure><h3 id="【解题思路】-3"><a href="#【解题思路】-3" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>我们可以使用贪心算法来解决这个问题。</p><p>具体步骤如下：</p><ol><li>初始化一个变量 <code>jumps</code> 为 0，表示当前的跳跃次数。</li><li>初始化一个变量 <code>current_end</code> 为 0，表示当前可以到达的最远位置。</li><li>初始化一个变量 <code>next_end</code> 为 0，表示下一跳可以到达的最远位置。</li><li>遍历数组 <code>nums</code>，对于每个位置 <code>i</code>：<ul><li>更新 <code>next_end</code> 为 <code>max(next_end, i + nums[i])</code>，表示下一跳可以到达的最远位置。</li><li>如果 <code>i</code> 等于 <code>current_end</code>，表示需要进行一次跳跃：<ul><li>将 <code>jumps</code> 加 1。</li><li>将 <code>current_end</code> 更新为 <code>next_end</code>。</li><li>将 <code>next_end</code> 更新为 0。</li></ul></li></ul></li><li>如果 <code>current_end</code> 大于或等于数组的最后一个位置，表示已经到达终点。</li></ol><h3 id="【实现代码】-3"><a href="#【实现代码】-3" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123; </span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">res := <span class="number">0</span></span><br><span class="line"><span class="comment">//curDistance在当前节点不动，能覆盖的范围</span></span><br><span class="line"><span class="comment">//nextDistance如果在当前节点移动，能覆盖的范围</span></span><br><span class="line">curDistance, nextDistance := <span class="number">0</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(nums);i++ &#123;</span><br><span class="line">nextDistance = max(nextDistance, i+nums[i])</span><br><span class="line"><span class="comment">//到了需要移动的节点了</span></span><br><span class="line"><span class="keyword">if</span> curDistance == i &#123;</span><br><span class="line">res++</span><br><span class="line">curDistance = nextDistance</span><br><span class="line"><span class="comment">//当前节点覆盖的最大距离大于数组长度了</span></span><br><span class="line"><span class="keyword">if</span> curDistance &gt;= <span class="built_in">len</span>(nums) <span class="number">-1</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="55-Jump-Game"><a href="#55-Jump-Game" class="headerlink" title="55 Jump Game"></a>55 Jump Game</h2><h3 id="【题目描述】-4"><a href="#【题目描述】-4" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个非负整数数组 <code>nums</code>，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达数组的最后一个位置。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 1 步，然后跳 3 步，再跳 1 步，最后跳 1 步到达最后一个位置。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,1,0,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：无论怎样，总会卡在第三个位置。</span><br></pre></td></tr></table></figure><h3 id="【解题思路】-4"><a href="#【解题思路】-4" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>我们可以使用贪心算法来解决这个问题。</p><p>具体步骤如下：</p><ol><li>初始化一个变量 <code>max_reach</code> 为 0，表示当前可以到达的最远位置。</li><li>遍历数组 <code>nums</code>：<ul><li>如果 <code>i</code> 大于 <code>max_reach</code>，表示无法到达当前位置，返回 <code>false</code>。</li><li>更新 <code>max_reach</code> 为 <code>max(max_reach, i + nums[i])</code>，表示当前可以到达的最远位置。</li></ul></li><li>如果 <code>max_reach</code> 大于或等于数组的最后一个位置，表示可以到达终点，返回 <code>true</code>。</li></ol><h3 id="【实现代码】-4"><a href="#【实现代码】-4" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canJump</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">canCover := <span class="number">0</span></span><br><span class="line">maxCover := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++ &#123;</span><br><span class="line">canCover = i + nums[i]</span><br><span class="line"><span class="keyword">if</span> maxCover &lt; canCover &#123;</span><br><span class="line">maxCover = canCover</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> maxCover == i &amp;&amp; i != <span class="built_in">len</span>(nums) <span class="number">-1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122 Best Time to Buy and Sell Stock II"></a>122 Best Time to Buy and Sell Stock II</h2><h3 id="【题目描述】-5"><a href="#【题目描述】-5" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个数组 <code>prices</code>，其中 <code>prices[i]</code> 是某一天的股票价格。</p><p>设计一个算法来计算你所能获得的最大利润。你可以尽可能地完成多次交易。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [7,1,5,3,6,4]</span><br><span class="line">输出：7</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出，这笔交易获得利润为 5-1 = 4 。</span><br><span class="line">随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，这笔交易获得利润为 6-3 = 3 。</span><br><span class="line">总利润为 4 + 3 = 7 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [1,2,3,4,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出，这笔交易获得利润为 5-1 = 4 。</span><br><span class="line">总利润为 4 。</span><br></pre></td></tr></table></figure><h3 id="【解题思路】-5"><a href="#【解题思路】-5" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>我们可以使用贪心算法来解决这个问题。</p><p>具体步骤如下：</p><ol><li>初始化一个变量 <code>profit</code> 为 0，表示当前的利润。</li><li>遍历数组 <code>prices</code>：<ul><li>如果 <code>prices[i]</code> 大于 <code>prices[i-1]</code>，表示股票价格上涨，则将 <code>profit</code> 加上 <code>prices[i] - prices[i-1]</code>。</li></ul></li></ol><h3 id="【实现代码】-5"><a href="#【实现代码】-5" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    profit := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(prices); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> prices[i] &gt; prices[i<span class="number">-1</span>] &#123;</span><br><span class="line">            profit += prices[i] - prices[i<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> profit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="53-Maximum-Subarray"><a href="#53-Maximum-Subarray" class="headerlink" title="53 Maximum Subarray"></a>53 Maximum Subarray</h2><h3 id="【题目描述】-6"><a href="#【题目描述】-6" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个整数数组 <code>nums</code>，请你找出数组中连续的一个子数组，返回其中元素和最大。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 `[4,-1,2,1]` 的和最大，为 6。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,4,-1,7,8]</span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure><h3 id="【解题思路】-6"><a href="#【解题思路】-6" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>我们可以使用贪心算法来解决这个问题。</p><h3 id="【实现代码】-6"><a href="#【实现代码】-6" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">res := <span class="number">-10000</span></span><br><span class="line">count := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++ &#123;</span><br><span class="line">count += nums[i]</span><br><span class="line"><span class="keyword">if</span> count &gt; res &#123;</span><br><span class="line">res = count</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重新计数</span></span><br><span class="line"><span class="keyword">if</span> count&lt;<span class="number">0</span> &#123;</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="376-摆动序列"><a href="#376-摆动序列" class="headerlink" title="376 摆动序列"></a>376 摆动序列</h2><h3 id="【题目描述】-7"><a href="#【题目描述】-7" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>如果一个序列的第一个元素比第二个元素大，第二个元素比第三个元素小，以此类推，则该序列称为摆动序列。</p><p>给定一个整数序列，返回其最长的摆动子序列的长度。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,7,4,9,2,5]</span><br><span class="line">输出：6</span><br><span class="line">解释：子序列 [1, 7, 4, 9, 2, 5] 是一个有效的摆动序列，其长度为 6。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,17,5,10,13,15,10,5,16,8]</span><br><span class="line">输出：7</span><br><span class="line">解释：这里有多个有效的摆动子序列，其长度为 7，例如：[1, 17, 10, 13, 10, 8]。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,4,5,6,7,8,9]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><h3 id="【解题思路】-7"><a href="#【解题思路】-7" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>我们可以使用贪心算法来解决这个问题。</p><p>具体步骤如下：</p><ol><li>初始化一个变量 <code>prevDiff</code> 为 0，表示前一个摆动的差值（正数表示上升，负数表示下降）。</li><li>初始化一个变量 <code>maxLength</code> 为 1，表示当前最长的摆动序列长度。</li><li>遍历数组 <code>nums</code>：<ul><li>如果 <code>nums[i]</code> 与 <code>nums[i-1]</code> 相等，则跳过。</li><li>如果 <code>nums[i]</code> 大于 <code>nums[i-1]</code> 且 <code>prevDiff</code> 小于等于 0，或者 <code>nums[i]</code> 小于 <code>nums[i-1]</code> 且 <code>prevDiff</code> 大于等于 0，则更新 <code>prevDiff</code> 为 <code>nums[i] - nums[i-1]</code>，并将 <code>maxLength</code> 加 1。</li></ul></li></ol><h3 id="【实现代码】-7"><a href="#【实现代码】-7" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wiggleMaxLength</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">prevDiff := nums[<span class="number">1</span>]-nums[<span class="number">0</span>]</span><br><span class="line">res := <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> prevDiff != <span class="number">0</span> &#123;</span><br><span class="line">res = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">2</span>;i&lt;<span class="built_in">len</span>(nums);i++ &#123;</span><br><span class="line">curDiff := nums[i]-nums[i<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">if</span> (prevDiff&lt;=<span class="number">0</span> &amp;&amp; curDiff&gt;<span class="number">0</span>) </span><br><span class="line">|| (prevDiff&gt;=<span class="number">0</span> &amp;&amp; curDiff&lt;<span class="number">0</span>) &#123;</span><br><span class="line">res++</span><br><span class="line"><span class="comment">//这个不能放在外层</span></span><br><span class="line">prevDiff = curDiff</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455 分发饼干"></a>455 分发饼干</h2><h3 id="【题目描述】-8"><a href="#【题目描述】-8" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个数组 <code>g</code>，其中 <code>g[i]</code> 表示第 <code>i</code> 个孩子吃的饼干数，以及一个数组 <code>s</code>，其中 <code>s[j]</code> 表示第 <code>j</code> 个饼干的大小。两个数组的长度都是 <code>n</code>。</p><p>你需要给每个孩子分配一个饼干，使得满足以下条件：</p><ul><li>每个孩子只能得到一个饼干。</li><li>每个饼干只能给一个孩子。</li><li>孩子们获得的饼干大小总和必须尽可能大。</li></ul><p>返回可以满足上述条件的最大饼干总和。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：g = [1,2,3], s = [1,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：孩子 1 和孩子 2 分别得到饼干 1 和饼干 2，总和为 3。孩子 3 没有得到饼干。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：g = [1,2], s = [1,2,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：孩子 1 和孩子 2 分别得到饼干 1 和饼干 2，总和为 2。</span><br></pre></td></tr></table></figure><h3 id="【解题思路】-8"><a href="#【解题思路】-8" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>我们可以使用贪心算法来解决这个问题。</p><p>具体步骤如下：</p><ol><li>将 <code>g</code> 和 <code>s</code> 数组分别排序。</li><li>从头开始遍历两个数组。</li><li>如果 <code>g[i]</code> 小于等于 <code>s[j]</code>，则将 <code>g[i]</code> 和 <code>s[j]</code> 匹配，并更新饼干总和。</li><li>否则，跳过 <code>g[i]</code>，继续遍历 <code>s</code> 数组。</li></ol><h3 id="【实现代码】-8"><a href="#【实现代码】-8" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findContentChildren</span><span class="params">(g []<span class="type">int</span>, s []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    sort.Ints(g)</span><br><span class="line">    sort.Ints(s)</span><br><span class="line"></span><br><span class="line">    i, j, count := <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="built_in">len</span>(g) &amp;&amp; j &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">        <span class="keyword">if</span> g[i] &lt;= s[j] &#123;</span><br><span class="line">            count++</span><br><span class="line">            i++</span><br><span class="line">            j++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="860-柠檬水找零"><a href="#860-柠檬水找零" class="headerlink" title="860 柠檬水找零"></a>860 柠檬水找零</h2><h3 id="【题目描述】-9"><a href="#【题目描述】-9" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>在柠檬水摊上，顾客只用 5 元、10 元和 20 元的钞票来购买柠檬水，而你只有无限量的 5 元钞票。</p><p>给你一个整数数组 <code>bills</code>，其中 <code>bills[i]</code> 表示第 <code>i</code> 个顾客付的钞票面额。</p><p>请你计算可能的最大利润，即卖出柠檬水后你获得的净收入。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：bills = [5,5,5,10,20]</span><br><span class="line">输出：15</span><br><span class="line">解释：</span><br><span class="line">第 1 个顾客给了 5 元，我们找零 0 元。</span><br><span class="line">第 2 个顾客给了 5 元，我们找零 0 元。</span><br><span class="line">第 3 个顾客给了 5 元，我们找零 0 元。</span><br><span class="line">第 4 个顾客给了 10 元，我们找零 5 元。</span><br><span class="line">第 5 个顾客给了 20 元，我们找零 15 元。</span><br><span class="line">总利润为 15 + 5 + 0 + 0 + 0 = 15 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：bills = [5,5,10]</span><br><span class="line">输出：10</span><br><span class="line">解释：</span><br><span class="line">第 1 个顾客给了 5 元，我们找零 0 元。</span><br><span class="line">第 2 个顾客给了 5 元，我们找零 0 元。</span><br><span class="line">第 3 个顾客给了 10 元，我们找零 5 元。</span><br><span class="line">总利润为 5 + 5 + 0 = 10 。</span><br></pre></td></tr></table></figure><h3 id="【解题思路】-9"><a href="#【解题思路】-9" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>我们可以使用贪心算法来解决这个问题。</p><p>具体步骤如下：</p><ol><li>初始化一个变量 <code>change</code>，表示当前找零的金额。</li><li>初始化一个变量 <code>profit</code>，表示当前利润。</li><li>遍历 <code>bills</code> 数组中的每个面额：<ul><li>如果面额是 5 元，则将 <code>change</code> 加 5。</li><li>如果面额是 10 元，则将 <code>change</code> 加 10，并检查是否可以找零 5 元。如果可以，则将 <code>change</code> 减 5，并将 <code>profit</code> 加 5。否则，返回 -1，表示无法找零。</li><li>如果面额是 20 元，则将 <code>change</code> 加 20，并检查是否可以找零 15 元。如果可以，则将 <code>change</code> 减 15，并将 <code>profit</code> 加 5。否则，检查是否可以找零 10 元和 5 元。如果可以，则将 <code>change</code> 减 10，并将 <code>profit</code> 加 5。否则，返回 -1，表示无法找零。</li></ul></li><li>遍历结束后，返回 <code>profit</code>。</li></ol><h3 id="【实现代码】-9"><a href="#【实现代码】-9" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lemonadeChange</span><span class="params">(bills []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">fiveCount := <span class="number">0</span></span><br><span class="line">tenCount := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, bill := <span class="keyword">range</span> bills &#123;</span><br><span class="line"><span class="keyword">if</span> bill == <span class="number">5</span> &#123;</span><br><span class="line">fiveCount++</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> bill == <span class="number">10</span> &#123;</span><br><span class="line"><span class="keyword">if</span> fiveCount &gt;= <span class="number">1</span> &#123;</span><br><span class="line">fiveCount--</span><br><span class="line">tenCount++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> bill == <span class="number">20</span> &#123;</span><br><span class="line"><span class="keyword">if</span> tenCount&gt;=<span class="number">1</span> &amp;&amp; fiveCount&gt;=<span class="number">1</span> &#123;</span><br><span class="line">tenCount--</span><br><span class="line">fiveCount--</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> fiveCount&gt;=<span class="number">3</span> &#123;</span><br><span class="line">fiveCount-=<span class="number">3</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406 根据身高重建队列"></a>406 根据身高重建队列</h2><h3 id="【题目描述】-10"><a href="#【题目描述】-10" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>有 <code>n</code> 个人站成一排，按从后往前依次编号为 <code>0</code> 到 <code>n-1</code>。每个人有自己的身高，现在每个人想按照身高重新排列成一排，并且 <strong>不允许</strong> 其他人移动。</p><p>某人可以站在队列的 <strong>任意位置</strong>，并且 <strong>其他人为此可能需要向前或向后移动</strong>。</p><p>给你一个数组 <code>people</code>，其中 <code>people[i] = [hi, ki]</code> 表示第 <code>i</code> 个人的身高 <code>hi</code> 和该人前面必须排放的 <strong>至少</strong> 人数 <code>ki</code>。</p><p>请你重新排列队列，使得 <strong>满足上述条件</strong> 下，<strong>队列人员的站位数量最多</strong>。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</span><br><span class="line">输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]</span><br><span class="line">输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]</span><br></pre></td></tr></table></figure><h3 id="【解题思路】-10"><a href="#【解题思路】-10" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>我们可以使用贪心算法来解决这个问题。</p><p>具体步骤如下：</p><ol><li>将 <code>people</code> 数组按身高降序排序。</li><li>初始化一个空队列 <code>queue</code>。</li><li>遍历排序后的 <code>people</code> 数组：<ul><li>如果 <code>queue</code> 为空，则直接将当前人员添加到 <code>queue</code> 的末尾。</li><li>否则，从 <code>queue</code> 的头部开始遍历，直到找到一个满足 <code>ki</code> 条件的位置。</li><li>将当前人员插入到该位置后，将 <code>queue</code> 中该位置之后的所有人员向后移动一位。</li></ul></li><li>返回排列好的 <code>queue</code>。</li></ol><h3 id="【实现代码】-10"><a href="#【实现代码】-10" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reconstructQueue</span><span class="params">(people [][]<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// 高个子先排好</span></span><br><span class="line">sort.Slice(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">if</span> people[i][<span class="number">0</span>] == people[j][<span class="number">0</span>] &#123;</span><br><span class="line"><span class="keyword">return</span> people[i][<span class="number">1</span>] &lt; people[j][<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> people[i][<span class="number">0</span>] &gt; people[j][<span class="number">0</span>]</span><br><span class="line">&#125;)</span><br><span class="line">res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, p := <span class="keyword">range</span> people &#123;</span><br><span class="line">index := p[<span class="number">1</span>]</span><br><span class="line">res = <span class="built_in">append</span>(res[:index], <span class="built_in">append</span>([][]<span class="type">int</span>&#123;p&#125;, res[index:]...)...)</span><br><span class="line"><span class="comment">// copy(res[index+1:], res[index:])</span></span><br><span class="line"><span class="comment">// res[index] = p</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452 用最少数量的箭引爆气球"></a>452 用最少数量的箭引爆气球</h2><h3 id="【题目描述】-11"><a href="#【题目描述】-11" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>有 <code>n</code> 个气球，每个气球都位于一条数轴上，位置为 <code>xi</code>。每个气球都有一定的半径 <code>ri</code>。</p><p>现在需要用弓箭爆破气球。弓箭的射程有限，只能射中 <code>x</code> 轴上某一点，并且只能引爆与该点距离不超过其射程的 <strong>所有</strong> 气球。</p><p>求引爆所有气球需要的最少弓箭数。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[10,16],[2,8],[1,6],[7,12]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[1,2],[3,4],[5,6],[7,8]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><h3 id="【解题思路】-11"><a href="#【解题思路】-11" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>我们可以使用贪心算法来解决这个问题。</p><h3 id="【实现代码】-11"><a href="#【实现代码】-11" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMinArrowShots</span><span class="params">(points [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(points) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按左边界排序</span></span><br><span class="line">sort.Slice(points, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> points[i][<span class="number">0</span>] &lt; points[j][<span class="number">0</span>]</span><br><span class="line">&#125;)</span><br><span class="line">res := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(points); i++ &#123;</span><br><span class="line"><span class="comment">//如果不想交，则需要一支箭</span></span><br><span class="line"><span class="keyword">if</span> points[i][<span class="number">0</span>] &gt; points[i<span class="number">-1</span>][<span class="number">1</span>] &#123;</span><br><span class="line">res++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//相交，则维护当前的右边界</span></span><br><span class="line">points[i][<span class="number">1</span>] = min(points[i][<span class="number">1</span>], points[i<span class="number">-1</span>][<span class="number">1</span>])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435 无重叠区间"></a>435 无重叠区间</h2><h3 id="【题目描述】-12"><a href="#【题目描述】-12" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,2],[2,3],[3,4],[1,3]]</span><br><span class="line">输出：1</span><br><span class="line">解释：可以移除区间 [1,3]，得到无重叠区间集合 [[1,2],[2,3],[3,4]]。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,2],[1,2],[1,2]]</span><br><span class="line">输出：2</span><br><span class="line">解释：可以移除两个区间 [1,2]，得到无重叠区间集合 []。</span><br></pre></td></tr></table></figure><h3 id="【解题思路】-12"><a href="#【解题思路】-12" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>我们可以使用贪心算法来解决这个问题。<br>解题思路同 452 </p><h3 id="【实现代码】-12"><a href="#【实现代码】-12" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eraseOverlapIntervals</span><span class="params">(intervals [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">sort.Slice(intervals, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> intervals[i][<span class="number">0</span>] &lt; intervals[j][<span class="number">0</span>]</span><br><span class="line">&#125;)</span><br><span class="line">res := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(intervals); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> intervals[i][<span class="number">0</span>] &lt; intervals[i<span class="number">-1</span>][<span class="number">1</span>] &#123;</span><br><span class="line">res++</span><br><span class="line">intervals[i][<span class="number">1</span>] = min(intervals[i][<span class="number">1</span>], intervals[i<span class="number">-1</span>][<span class="number">1</span>])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763 划分字母区间"></a>763 划分字母区间</h2><p>给你一个字符串 <code>s</code> 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。<br>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 <code>s</code> 。<br>返回一个表示每个字符串片段的长度的列表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ababcbacadefegdehijhklij&quot;</span><br><span class="line">输出：[9,7,8]</span><br><span class="line">解释：</span><br><span class="line">划分结果为 &quot;ababcbaca&quot;、&quot;defegde&quot;、&quot;hijhklij&quot; 。</span><br><span class="line">每个字母最多出现在一个片段中。</span><br><span class="line">像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 这样的划分是错误的，因为划分的片段数较少。</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partitionLabels</span><span class="params">(s <span class="type">string</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">mp := <span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 维护当前字母的最右边界</span></span><br><span class="line"><span class="keyword">for</span> index, element := <span class="keyword">range</span> s &#123;</span><br><span class="line">mp[element] = index</span><br><span class="line">&#125;</span><br><span class="line">left,right := <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">res := []<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> index, element := <span class="keyword">range</span> s &#123;</span><br><span class="line"><span class="comment">// 当前区间的最右边界</span></span><br><span class="line">right = max(right, mp[element])</span><br><span class="line"><span class="comment">// 打到最右边界</span></span><br><span class="line"><span class="keyword">if</span> right == index &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, index-left+<span class="number">1</span>)</span><br><span class="line">left = index+<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53 最大子序和"></a>53 最大子序和</h2><h3 id="【题目描述】-13"><a href="#【题目描述】-13" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个整数数组 nums ，找到一个连续子数组，该子数组具有最大的和。</p><h3 id="【解题思路】-13"><a href="#【解题思路】-13" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>使用贪心算法，从左到右遍历数组，维护当前子数组的和和全局最大子数组和。</p><ol><li>如果当前子数组和为负数，则重置当前子数组和为 0。</li><li>如果当前子数组和大于全局最大子数组和，则更新全局最大子数组和。</li><li>继续遍历数组，重复上述步骤。</li></ol><h3 id="【实现代码】-13"><a href="#【实现代码】-13" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// curSum 为当前子数组的和</span></span><br><span class="line">    curSum := <span class="number">0</span></span><br><span class="line">    <span class="comment">// maxSum 为全局最大子数组和</span></span><br><span class="line">    maxSum := math.MinInt32</span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="comment">// 将当前元素加入子数组</span></span><br><span class="line">        curSum += num</span><br><span class="line">        <span class="comment">// 更新全局最大子数组和</span></span><br><span class="line">        <span class="keyword">if</span> curSum &gt; maxSum &#123;</span><br><span class="line">            maxSum = curSum</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">// 如果当前子数组和为负数，则重置为 0</span></span><br><span class="line">        <span class="keyword">if</span> curSum &lt; <span class="number">0</span> &#123;</span><br><span class="line">            curSum = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="738-单调递增的数字"><a href="#738-单调递增的数字" class="headerlink" title="738. 单调递增的数字"></a>738. 单调递增的数字</h2><h3 id="【题目描述】-14"><a href="#【题目描述】-14" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个非负整数 <code>N</code>，找出小于或等于 <code>N</code> 的最大的整数，同时该整数需要满足其各个位数上的数字是单调递增的。<br>（当且仅当每个相邻位数上的数字 <code>x</code> 和 <code>y</code> 满足 <code>x &lt;= y</code> 时，我们称这个整数是单调递增的。）</p><h3 id="【实现代码】-14"><a href="#【实现代码】-14" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">s := strconv.Itoa(n)</span><br><span class="line">ss := []<span class="type">byte</span>(s)</span><br><span class="line">length := <span class="built_in">len</span>(ss)</span><br><span class="line"><span class="keyword">if</span> length &lt;= <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line"><span class="keyword">if</span> ss[i] &lt; ss[i<span class="number">-1</span>] &#123;</span><br><span class="line"><span class="keyword">for</span> j:=i;j&lt;length;j++ &#123;</span><br><span class="line">ss[j] = <span class="string">&#x27;9&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">ss[i<span class="number">-1</span>]--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r, _ := strconv.Atoi(<span class="type">string</span>(ss))</span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="968-监控二叉树"><a href="#968-监控二叉树" class="headerlink" title="968 监控二叉树"></a>968 监控二叉树</h2><h3 id="【题目描述】-15"><a href="#【题目描述】-15" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个二叉树，我们在树的每个节点上放置一个监控摄像头。每个节点都可以看到它所有的子节点。树的根节点可以看到整个树。请你找出所需的最小摄像头数量，以便监视树上的所有节点。</p><h3 id="【解题思路】-14"><a href="#【解题思路】-14" class="headerlink" title="【解题思路】"></a>【解题思路】</h3><p>使用贪心算法：</p><ol><li>从根节点开始遍历二叉树。</li><li>对于每个节点，有以下三种情况：<ul><li>节点没有被监控，则放置一个摄像头。</li><li>节点的父节点没有被监控，则放置一个摄像头。</li><li>节点和节点的父节点都被监控，则不需要放置摄像头。</li></ul></li><li>返回放置摄像头的最小数量。</li></ol><h3 id="【实现代码】-15"><a href="#【实现代码】-15" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minCameraCover</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">res := <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">NONE   = <span class="number">0</span></span><br><span class="line">CAMERA = <span class="number">1</span></span><br><span class="line">COVER  = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span></span><br><span class="line">dfs = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// 如果把摄像头放在叶子节点上，就浪费的一层的覆盖。</span></span><br><span class="line"><span class="comment">// nil节点算覆盖的，则叶子结点才能不安装</span></span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> COVER</span><br><span class="line">&#125;</span><br><span class="line">left := dfs(root.Left)</span><br><span class="line">right := dfs(root.Right)</span><br><span class="line"><span class="comment">// 左右都被覆盖，不需要安装</span></span><br><span class="line"><span class="keyword">if</span> left == COVER &amp;&amp; right == COVER &#123;</span><br><span class="line"><span class="keyword">return</span> NONE</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左右只要有一个没有覆盖，就需要安装摄像头</span></span><br><span class="line"><span class="keyword">if</span> left == NONE || right == NONE &#123;</span><br><span class="line">res++</span><br><span class="line"><span class="keyword">return</span> CAMERA</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左右有一个摄像头，当前为被覆盖状态</span></span><br><span class="line"><span class="keyword">if</span> left == CAMERA || right == CAMERA &#123;</span><br><span class="line"><span class="keyword">return</span> COVER</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//跟节点没有被覆盖</span></span><br><span class="line"><span class="keyword">if</span> (dfs(root) == NONE) &#123;</span><br><span class="line">res++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>差分数组技巧</title>
      <link href="/2024/03/08/leetcode/0%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84%E6%8A%80%E5%B7%A7/"/>
      <url>/2024/03/08/leetcode/0%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 差分数组工具类</span></span><br><span class="line"><span class="keyword">type</span> Difference <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 差分数组</span></span><br><span class="line">    diff []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输入一个初始数组，区间操作将在这个数组上进行 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDifference</span><span class="params">(nums []<span class="type">int</span>)</span></span> *Difference &#123;</span><br><span class="line">   diff := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    <span class="comment">// 根据初始数组构造差分数组</span></span><br><span class="line">    diff[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        diff[i] = nums[i] - nums[i<span class="number">-1</span>]</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> &amp;Difference&#123;diff: diff&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 给闭区间 [i, j] 增加 val（可以是负数）*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Difference)</span></span> Increment(i, j, val <span class="type">int</span>) &#123;</span><br><span class="line">    d.diff[i] += val</span><br><span class="line">    <span class="keyword">if</span> j+<span class="number">1</span> &lt; <span class="built_in">len</span>(d.diff) &#123;</span><br><span class="line">        d.diff[j+<span class="number">1</span>] -= val</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回结果数组 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Difference)</span></span> Result() []<span class="type">int</span> &#123;</span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(d.diff))</span><br><span class="line">    <span class="comment">// 根据差分数组构造结果数组</span></span><br><span class="line">    res[<span class="number">0</span>] = d.diff[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(d.diff); i++ &#123;</span><br><span class="line">        res[i] = res[i<span class="number">-1</span>] + d.diff[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 差分数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找的变种总结</title>
      <link href="/2024/03/08/leetcode/0%E5%8F%98%E7%A7%8D%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2024/03/08/leetcode/0%E5%8F%98%E7%A7%8D%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="查找第一个值等于给定值的元素"><a href="#查找第一个值等于给定值的元素" class="headerlink" title="查找第一个值等于给定值的元素"></a>查找第一个值等于给定值的元素</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public <span class="type">int</span> bsearch(<span class="type">int</span>[] a, <span class="type">int</span> n, <span class="type">int</span> value) &#123;</span><br><span class="line">  <span class="type">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">  while (low &lt;= high) &#123;</span><br><span class="line">    <span class="type">int</span> mid =  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt; value) &#123;</span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">//mid == 0是第一个元素， 不能再往左了</span></span><br><span class="line">     <span class="comment">//a[mid - 1] != value 也不需要往左了</span></span><br><span class="line">      <span class="keyword">if</span> ((mid == <span class="number">0</span>) || (a[mid - <span class="number">1</span>] != value)) <span class="keyword">return</span> mid;</span><br><span class="line">      <span class="keyword">else</span> high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="查找最后一个值等于给定值的元素"><a href="#查找最后一个值等于给定值的元素" class="headerlink" title="查找最后一个值等于给定值的元素"></a>查找最后一个值等于给定值的元素</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public <span class="type">int</span> bsearch(<span class="type">int</span>[] a, <span class="type">int</span> n, <span class="type">int</span> value) &#123;</span><br><span class="line">  <span class="type">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">  while (low &lt;= high) &#123;</span><br><span class="line">    <span class="type">int</span> mid =  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt; value) &#123;</span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//mid == n - 1是最后一个元素了， 不能往右了</span></span><br><span class="line">        <span class="comment">//a[mid + 1] != value， 也不需要往右了</span></span><br><span class="line">      <span class="keyword">if</span> ((mid == n - <span class="number">1</span>) || (a[mid + <span class="number">1</span>] != value)) <span class="keyword">return</span> mid;</span><br><span class="line">      <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>子序列问题总结</title>
      <link href="/2024/03/08/leetcode/0%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/"/>
      <url>/2024/03/08/leetcode/0%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>子序列问题是动态规划解决的经典问题</p><h2 id="300-最长递增子序列-不需要连续"><a href="#300-最长递增子序列-不需要连续" class="headerlink" title="300.最长递增子序列(不需要连续)"></a>300.最长递增子序列(不需要连续)</h2><blockquote><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p></blockquote><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,0,3,2,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [7,7,7,7,7,7,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><h3 id="dp定义"><a href="#dp定义" class="headerlink" title="dp定义"></a>dp定义</h3><p>dp[i]代表在i的位置时的最长递增子序列</p><h3 id="递推公式"><a href="#递推公式" class="headerlink" title="递推公式"></a>递推公式</h3><p><code>if num[j] &lt; num[i] dp[i] = max(dp[i], dp[j]+1)</code></p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>dp[i]至少为1，所有dp[i]&#x3D;1</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLIS</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(nums)</span><br><span class="line"><span class="comment">// dp[i]代表在i的位置时的最长递增子序列</span></span><br><span class="line">dp := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">dp[i] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">res := dp[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums[j] &lt; nums[i] &#123;</span><br><span class="line">dp[i] = max(dp[i], dp[j]+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> dp[i] &gt; res &#123;</span><br><span class="line">res = dp[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="674. 最长连续递增序列"></a>674. 最长连续递增序列</h2><blockquote><p>给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;&#x3D; i &lt; r，都有 num&gt;[i] &lt; nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], …, nums[r - 1],nums[r]] 就是连续递增子序列。</p></blockquote><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,5,4,7]</span><br><span class="line">输出：3</span><br><span class="line">解释：最长连续递增序列是 [1,3,5], 长度为3。</span><br><span class="line">尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。</span><br></pre></td></tr></table></figure><h3 id="dp定义-1"><a href="#dp定义-1" class="headerlink" title="dp定义"></a>dp定义</h3><p>dp[i] 第i时的最长长度</p><h3 id="递推公式-1"><a href="#递推公式-1" class="headerlink" title="递推公式"></a>递推公式</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> nums[i]&gt;nums[i<span class="number">-1</span>] &#123;</span><br><span class="line">dp[i] = dp[i<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><p>dp[index] &#x3D; 1</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findLengthOfLCIS</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="comment">//dp[i] 第i时的最长长度</span></span><br><span class="line">res := <span class="number">1</span></span><br><span class="line">dp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line"><span class="keyword">for</span> index, _ := <span class="keyword">range</span> dp &#123;</span><br><span class="line">dp[index] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="built_in">len</span>(nums);i++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums[i]&gt;nums[i<span class="number">-1</span>] &#123;</span><br><span class="line">dp[i] = dp[i<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">res = max(res, dp[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="贪心实现"><a href="#贪心实现" class="headerlink" title="贪心实现"></a>贪心实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findLengthOfLCIS</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">res := <span class="number">0</span></span><br><span class="line">start := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i&gt;<span class="number">0</span> &amp;&amp; nums[i] &lt;= nums[i<span class="number">-1</span>] &#123;</span><br><span class="line">start=i</span><br><span class="line">&#125; </span><br><span class="line">res = max(res, i-start+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718.最长重复子数组"></a>718.最长重复子数组</h2><blockquote><p>给两个整数数组 nums1 和 nums2 ，返回 两个数组中 公共的 、长度最长的子数组的长度 。</p></blockquote><p>子数组 是要求<strong>连续</strong>的，这点是和下面1143子序列最本质的区别<br><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]</span><br><span class="line">输出：3</span><br><span class="line">解释：长度最长的公共子数组是 [3,2,1] 。</span><br></pre></td></tr></table></figure><h3 id="dp定义-2"><a href="#dp定义-2" class="headerlink" title="dp定义"></a>dp定义</h3><p><code>dp[i][j]表示nums1[i-1]和nums2[j-1]对应的最长长度</code><br><code>为什么dp[i][j]不定义为nums[i],nums[j]时对应的长度，因为这样需要初始化dp[i][0] 和dp[0][j]的值</code></p><h3 id="递推公式-2"><a href="#递推公式-2" class="headerlink" title="递推公式"></a>递推公式</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> nums1[i<span class="number">-1</span>] == nums2[j<span class="number">-1</span>] &#123;</span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h3><p>默认都为0</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findLength</span><span class="params">(nums1 []<span class="type">int</span>, nums2 []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">m, n := <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line"><span class="comment">// dp[i][j]表示nums1[i-1]和nums2[j-1]对应的最长长度</span></span><br><span class="line"><span class="comment">// 为什么dp[i][j]不定义为nums[i],nums[j]时对应的长度，因为这样需要初始化dp[i][0] 和dp[0][j]的值，</span></span><br><span class="line">dp := <span class="built_in">make</span>([][]<span class="type">int</span>, m+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= m; i++ &#123;</span><br><span class="line">dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">res := <span class="number">0</span></span><br><span class="line"><span class="comment">// dp[i][0],dp[0][j]没有意义，所以i，j都从1开始</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= m; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= n; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums1[i<span class="number">-1</span>] == nums2[j<span class="number">-1</span>] &#123;</span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">res = max(res, dp[i][j])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143.最长公共子序列"></a>1143.最长公共子序列</h2><blockquote><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p></blockquote><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; </span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：最长公共子序列是 &quot;abc&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure><h3 id="dp定义-3"><a href="#dp定义-3" class="headerlink" title="dp定义"></a>dp定义</h3><p>$dp[i][j]$表示nums1[i-1]和nums2[j-1]对应的最长长度<br>为什么$dp[i][j]$不定义为nums[i],nums[j]时对应的长度，因为这样需要初始化$dp[i][0]$和$dp[0][j]$的值</p><h3 id="递推公式-3"><a href="#递推公式-3" class="headerlink" title="递推公式"></a>递推公式</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>] &#123;</span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 不同于上面的数组，要求完全对应</span></span><br><span class="line">dp[i][j] = max(dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化-3"><a href="#初始化-3" class="headerlink" title="初始化"></a>初始化</h3><p>默认都为0</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestCommonSubsequence</span><span class="params">(text1 <span class="type">string</span>, text2 <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// dp[i][j] 表示i-1,j-1时的最长长度</span></span><br><span class="line">m, n := <span class="built_in">len</span>(text1), <span class="built_in">len</span>(text2)</span><br><span class="line">dp := <span class="built_in">make</span>([][]<span class="type">int</span>, m+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= m; i++ &#123;</span><br><span class="line">dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= m; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= n; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>] &#123;</span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j] = max(dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[m][n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1035-不相交的线"><a href="#1035-不相交的线" class="headerlink" title="1035.不相交的线"></a>1035.不相交的线</h2><blockquote><p>在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足满足：nums1[i] &#x3D;&#x3D; nums2[j]且绘制的直线不与任何其他连线（非水平线）相交。请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。以这种方法绘制线条，并返回可以绘制的最大连线数。</p></blockquote><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>这个题目的解法和最长公共子序列一模一样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxUncrossedLines</span><span class="params">(nums1 []<span class="type">int</span>, nums2 []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// 这个题目和最长公共子序列是一模一样的</span></span><br><span class="line"><span class="comment">// dp[i][j]定义是在nums1[i-1],nums2[j-1]时的最长公共子序列长度</span></span><br><span class="line">m, n := <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">dp := <span class="built_in">make</span>([][]<span class="type">int</span>, m+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= m; i++ &#123;</span><br><span class="line">dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= m; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= n; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums1[i<span class="number">-1</span>] == nums2[j<span class="number">-1</span>] &#123;</span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[m][n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="53-最大子数组的和"><a href="#53-最大子数组的和" class="headerlink" title="53. 最大子数组的和"></a>53. 最大子数组的和</h2><blockquote><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。子数组 是数组中的一个连续部分。</p></blockquote><h3 id="dp定义-4"><a href="#dp定义-4" class="headerlink" title="dp定义"></a>dp定义</h3><p>dp[i]为下标为i的最大和</p><h3 id="递推公式-4"><a href="#递推公式-4" class="headerlink" title="递推公式"></a>递推公式</h3><p>dp[i] &#x3D; max(dp[i-1] + nums[i], nums[i])</p><h3 id="初始值"><a href="#初始值" class="headerlink" title="初始值"></a>初始值</h3><p>dp[0] &#x3D; nums[0]</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// dp[i]为下标为i的最大和</span></span><br><span class="line">dp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">res := dp[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="built_in">len</span>(nums);i++ &#123;</span><br><span class="line">dp[i] = max(dp[i<span class="number">-1</span>] + nums[i], nums[i])</span><br><span class="line"><span class="keyword">if</span> res &lt;dp[i] &#123;</span><br><span class="line">res = dp[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392.判断子序列"></a>392.判断子序列</h2><blockquote><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>和最长公共子序列一模一样</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSubsequence</span><span class="params">(s <span class="type">string</span>, t <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">m, n := <span class="built_in">len</span>(s), <span class="built_in">len</span>(t)</span><br><span class="line">dp := <span class="built_in">make</span>([][]<span class="type">int</span>, m+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= m; i++ &#123;</span><br><span class="line">dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= m; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= n; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> s[i<span class="number">-1</span>] == t[j<span class="number">-1</span>] &#123;</span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[m][n] == m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="115-不同的子序列"><a href="#115-不同的子序列" class="headerlink" title="115.不同的子序列"></a>115.不同的子序列</h2><blockquote><p>给你两个字符串 s 和 t ，统计并返回在 s 的 子序列 中 t 出现的个数。</p></blockquote><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;rabbbit&quot;, t = &quot;rabbit&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">如下所示, 有 3 种可以从 s 中得到 &quot;rabbit&quot; 的方案。</span><br><span class="line">rabbbit</span><br><span class="line">rabbbit</span><br><span class="line">rabbbit</span><br></pre></td></tr></table></figure><h3 id="dp定义-5"><a href="#dp定义-5" class="headerlink" title="dp定义"></a>dp定义</h3><p>$dp[i][j]$以i-1为结尾的s子序列中出现以j-1为结尾的t的个数</p><h3 id="递推公式-5"><a href="#递推公式-5" class="headerlink" title="递推公式"></a>递推公式</h3><p>$s[i-1] &#x3D;&#x3D; t[j-1]$<br>使用$s[i-1]$匹配为$dp[i-1][j-1]$<br>不使用$s[i-1]$匹配为$dp[i-1][j]$<br>$s[i-1] !&#x3D; t[j-1]$为$dp[i-1][j]$</p><h3 id="初始值-1"><a href="#初始值-1" class="headerlink" title="初始值"></a>初始值</h3><p>那么$dp[i][0]$一定都是1，因为也就是把以i-1为结尾的s，删除所有元素，出现空字符串的个数就是1</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numDistinct</span><span class="params">(s <span class="type">string</span>, t <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">m,n := <span class="built_in">len</span>(s),<span class="built_in">len</span>(t)</span><br><span class="line">dp := <span class="built_in">make</span>([][]<span class="type">int</span>, m+<span class="number">1</span>)</span><br><span class="line"><span class="comment">//dp[i][j]以i-1为结尾的s子序列中出现以j-1为结尾的t的个数</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;=m;i++ &#123;</span><br><span class="line">dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// dp[i][0]即t不选时为1</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;=m;i++ &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=m;i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">1</span>;j&lt;=n;j++ &#123;</span><br><span class="line"><span class="keyword">if</span> s[i<span class="number">-1</span>] == t[j<span class="number">-1</span>] &#123;</span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + dp[i<span class="number">-1</span>][j]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[m][n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 子序列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>股票买卖总结</title>
      <link href="/2024/03/08/leetcode/0%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8/"/>
      <url>/2024/03/08/leetcode/0%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="121-买卖股票的最佳时机-只能进行一次买入卖出"><a href="#121-买卖股票的最佳时机-只能进行一次买入卖出" class="headerlink" title="121. 买卖股票的最佳时机 (只能进行一次买入卖出)"></a>121. 买卖股票的最佳时机 (只能进行一次买入卖出)</h1><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。<br>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。<br>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><h2 id="dp数组定义"><a href="#dp数组定义" class="headerlink" title="dp数组定义"></a>dp数组定义</h2><p>$dp[i][0]$第i天持有股票所得的最多利润<br>$dp[i][1]$第i天不持有股票所得的最多利润</p><h2 id="递推公式"><a href="#递推公式" class="headerlink" title="递推公式"></a>递推公式</h2><p>$dp[i][0] &#x3D; max(dp[i-1][0], -prices[i])$<br>$dp[i][1] &#x3D; max(dp[i-1][1], dp[i-1][0]+prices[i])$</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>$dp[0][0] &#x3D; -prices[0]$<br>$dp[0][1] &#x3D; 0$</p><h2 id="遍历顺序"><a href="#遍历顺序" class="headerlink" title="遍历顺序"></a>遍历顺序</h2><p>由前往后遍历</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">dp := <span class="built_in">make</span>([][<span class="number">2</span>]<span class="type">int</span>, <span class="built_in">len</span>(prices))</span><br><span class="line"><span class="comment">// 持有股票的利润</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// 不持有股票的利润</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="built_in">len</span>(prices);i++ &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], -prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>]+prices[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="built_in">len</span>(prices)<span class="number">-1</span>][<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="122-买卖股票的最佳时机II-可多次买票"><a href="#122-买卖股票的最佳时机II-可多次买票" class="headerlink" title="122.买卖股票的最佳时机II(可多次买票)"></a>122.买卖股票的最佳时机II(可多次买票)</h1><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。<br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><h2 id="递推公式-1"><a href="#递推公式-1" class="headerlink" title="递推公式"></a>递推公式</h2><p>第i天持有股票的收益：$dp[i][0] &#x3D; max(dp[i-1][0], dp[i-1][1]-prices[i])$<br>第i天不持有股票的收益：$dp[i][1] &#x3D; max(dp[i-1][1], dp[i-1][0]+prices[i])$</p><h2 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h2><p>$dp[0][0] &#x3D; -prices[0]$<br>$dp[0][1] &#x3D; 0$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">dp := <span class="built_in">make</span>([][<span class="number">2</span>]<span class="type">int</span>, <span class="built_in">len</span>(prices))</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">n := <span class="built_in">len</span>(prices)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;n;i++ &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>]-prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>]+prices[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="123-买卖股票的最佳时机III-最多进行两次交易"><a href="#123-买卖股票的最佳时机III-最多进行两次交易" class="headerlink" title="123.买卖股票的最佳时机III (最多进行两次交易)"></a>123.买卖股票的最佳时机III (最多进行两次交易)</h1><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。<br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><h2 id="递推公式-2"><a href="#递推公式-2" class="headerlink" title="递推公式"></a>递推公式</h2><p>第i天开始第k次交易持有股票的利润$dp[i][k][0] &#x3D; max(dp[i-1][k][0], dp[i-1][k-1][1]-prices[i])$<br>第i天开始第k次交易不持有股票的利润 $dp[i][k][1] &#x3D; max(dp[i-1][k][1], dp[i-1][k][0]+prices[i])$</p><h2 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第0天开始第j次交易都是-prices[0]</span></span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">1</span>;j&lt;=<span class="number">2</span>;j++ &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j][<span class="number">0</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">dp := <span class="built_in">make</span>([][<span class="number">3</span>][<span class="number">2</span>]<span class="type">int</span>, <span class="built_in">len</span>(prices))</span><br><span class="line"><span class="keyword">for</span> index := <span class="keyword">range</span> prices &#123;</span><br><span class="line">dp[index] = [<span class="number">3</span>][<span class="number">2</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">1</span>;j&lt;=<span class="number">2</span>;j++ &#123;</span><br><span class="line">dp[<span class="number">0</span>][j][<span class="number">0</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="built_in">len</span>(prices);i++ &#123;</span><br><span class="line"><span class="keyword">for</span> k:=<span class="number">1</span>;k&lt;=<span class="number">2</span>;k++ &#123;</span><br><span class="line">dp[i][k][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">0</span>], dp[i<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">1</span>]-prices[i])</span><br><span class="line">dp[i][k][<span class="number">1</span>] =  max(dp[i<span class="number">-1</span>][k][<span class="number">1</span>], dp[i<span class="number">-1</span>][k][<span class="number">0</span>]+prices[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="built_in">len</span>(prices)<span class="number">-1</span>][<span class="number">2</span>][<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="309含有冷冻期的股票买卖"><a href="#309含有冷冻期的股票买卖" class="headerlink" title="309含有冷冻期的股票买卖"></a>309含有冷冻期的股票买卖</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// dp[第i天][0持有1不持有]的最大利润</span></span><br><span class="line">dp := <span class="built_in">make</span>([][<span class="number">2</span>]<span class="type">int</span>, <span class="built_in">len</span>(prices))</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(prices); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">1</span> &#123;</span><br><span class="line"><span class="comment">// 第一天持有的状态，是第0天持有和第1天持有收益的最大值</span></span><br><span class="line">dp[<span class="number">1</span>][<span class="number">0</span>] = max(dp[<span class="number">0</span>][<span class="number">0</span>], -prices[i])</span><br><span class="line"><span class="comment">// 第一天不持有，就能是第0天买入，第一天卖出和0的最大值</span></span><br><span class="line">dp[<span class="number">1</span>][<span class="number">1</span>] = max(<span class="number">0</span>, prices[<span class="number">1</span>]-prices[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// i-2因为i-1为冷冻期</span></span><br><span class="line">dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-2</span>][<span class="number">1</span>]-prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>]+prices[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[<span class="built_in">len</span>(prices)<span class="number">-1</span>][<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="714-股票买卖含有手续费"><a href="#714-股票买卖含有手续费" class="headerlink" title="714.股票买卖含有手续费"></a>714.股票买卖含有手续费</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>, fee <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">//dp[第i天][0持有1不持有]的最大利润</span></span><br><span class="line">dp := <span class="built_in">make</span>([][<span class="number">2</span>]<span class="type">int</span>, <span class="built_in">len</span>(prices))</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>]-fee</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="built_in">len</span>(prices);i++ &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]-prices[i]-fee)</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">0</span>]+prices[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="built_in">len</span>(prices)<span class="number">-1</span>][<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 股票买卖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题总结</title>
      <link href="/2024/03/08/leetcode/0%E8%83%8C%E5%8C%85/"/>
      <url>/2024/03/08/leetcode/0%E8%83%8C%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="01背包问题是将背包中重量与价值的物品放在某个容量的包中，求所放价值的最大值"><a href="#01背包问题是将背包中重量与价值的物品放在某个容量的包中，求所放价值的最大值" class="headerlink" title="01背包问题是将背包中重量与价值的物品放在某个容量的包中，求所放价值的最大值"></a>01背包问题是将背包中重量与价值的物品放在某个容量的包中，求所放价值的最大值</h1><h2 id="二维数组的实现方式"><a href="#二维数组的实现方式" class="headerlink" title="二维数组的实现方式"></a>二维数组的实现方式</h2><p>$dp[i][j]$表示的是在0-i之间选择物品放在容量为j的包中，价值的最大值<br>递推公式 $dp[i][j] &#x3D; max(dp[i-1][j], dp[i-1][j-weight[i]]+value[i])$;<br>数据初始化，由于$dp[i][j]$的值有$dp[i-1][j]$推倒出来，所以需要初始$dp[0$][j]与$dp[i][0]$的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">knapsack01</span><span class="params">(capacity <span class="type">int</span>, weights <span class="type">int</span>[], values []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="built_in">len</span>(weight))</span><br><span class="line">    <span class="keyword">for</span> i, v := dp &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, capacity+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">   <span class="keyword">for</span> j:=weights[<span class="number">0</span>];j&lt;=capacity;j++&#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = values[<span class="number">0</span>]</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">// 先遍历背包，再遍历容量， 二者顺序可以颠倒</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt; <span class="built_in">len</span>(weights);i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span>;j&lt;=capacity;j++&#123;</span><br><span class="line">            <span class="keyword">if</span> weights[i] &gt; j &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-weights[i]] + values[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="built_in">len</span>(weights)<span class="number">-1</span>][capacity]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一维数组的实现方式"><a href="#一维数组的实现方式" class="headerlink" title="一维数组的实现方式"></a>一维数组的实现方式</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">knapsack</span><span class="params">(capacity <span class="type">int</span>, weights []<span class="type">int</span>, values []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// dp数组使用一维的</span></span><br><span class="line">dp := <span class="built_in">make</span>([]<span class="type">int</span>, capacity+<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 遍历的顺序只能是先物品再容量</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(weights); i++ &#123;</span><br><span class="line">        <span class="comment">// 只能由后往前遍历，否则出现重复计算</span></span><br><span class="line">        <span class="comment">//由于一位数组是根据二维优化而来的，因此如果仍然从前向后遍历，遍历到后面的时候前面的元素可能已经被修改过了，此时dp[i - weight[j]]再获取到的就不是上一行的值了，因此需要倒叙遍历，以确保dp[i - weight[j]]获取到的仍是上一行的值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//假如枚举到：i = 3, j = 8, v[3] = 5, w[3] = 1</span></span><br><span class="line"><span class="comment">//二维：dp[3][8] = max(dp[2][8], dp[2][3] + w[3])   此时的dp[2][8]和dp[2][3]都是上一轮的状态值</span></span><br><span class="line"><span class="comment">//一维：dp[8] = max(dp[8], dp[3] + w[3])      我们要保证dp[8]和dp[3]都是上一轮的状态值</span></span><br><span class="line"><span class="comment">//按照逆序的顺序，一维dp数组的更新顺序为：dp[8], dp[7], dp[6], ... , dp[3]</span></span><br><span class="line"><span class="comment">//也就是说，在本轮更新的值，不会影响本轮中其他未更新的值！较小的index对应的状态是上一轮的状态值！</span></span><br><span class="line"><span class="comment">//如果按照顺序进行更新，dp[3] = max(dp[3], dp[0] + w[0])，对dp[3]的状态进行了更新，那么在更新dp[8]时，用到的dp[3]</span></span><br><span class="line"><span class="comment">//就不是上一轮的状态了，不满足动态规划的要求。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j := capacity; j &gt;= weights[i]; j-- &#123;</span><br><span class="line">dp[j] = max(dp[j], dp[j-weights[i]]+values[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[capacity]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h1><blockquote><p>没中物品有无限个，即可以无限放入背包中</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">knapsack</span><span class="params">(capacity <span class="type">int</span>, weights []<span class="type">int</span>, values []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// dp数组使用一维的</span></span><br><span class="line">dp := <span class="built_in">make</span>([]<span class="type">int</span>, capacity+<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 纯背包问题即算总和的问题，i，j的遍历顺序无影响</span></span><br><span class="line">    <span class="comment">// 但是对于变种背包，需要求的是有多少种类型，涉及到排列和组合的问题</span></span><br><span class="line">    <span class="comment">// 组合（不强调顺序）使用外层物品，内层背包的方式</span></span><br><span class="line">    <span class="comment">// 排列（强调顺序）使用外层背包，，内层物品的方式遍历</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(weights); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := weights[i]; j &lt;= capacity; j++ &#123;</span><br><span class="line">dp[j] = max(dp[j], dp[j-weights[i]]+values[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[capacity]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="递推公式总结"><a href="#递推公式总结" class="headerlink" title="递推公式总结"></a>递推公式总结</h1><ol><li>问能否能装满背包（或者最多装多少）$dp[j] &#x3D; max(dp[j],dp[j-nums[i]]+nums[i])$</li><li>问装满背包有几种方法 $dp[j] &#x3D; dp[j] + dp[j-nums[i]]$</li><li>问装满背包所有物品的最小个数 $dp[j] &#x3D; min(dp[j],dp[j-nums[i]]+1)$</li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络</title>
      <link href="/2024/02/04/read/%E7%BD%91%E7%BB%9C/"/>
      <url>/2024/02/04/read/%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><p>url格式<br><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/3.jpg"><br>报文格式<br><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/4.jpg"></p><h3 id="tcp"><a href="#tcp" class="headerlink" title="tcp"></a>tcp</h3><h4 id="tcp报文格式"><a href="#tcp报文格式" class="headerlink" title="tcp报文格式"></a>tcp报文格式</h4><p><a href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E5%A4%B4%E6%A0%BC%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B">字段说明</a><br><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/8.jpg"></p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li><strong>面向连接</strong>：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</li><li><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</li><li><strong>字节流</strong>：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。</li></ul><h4 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h4><blockquote><p>分为 超时重传， 快速重传，SACK， D-SACK</p></blockquote><h5 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a><a href="https://xiaolincoding.com/network/3_tcp/tcp_feature.html">超时重传</a></h5><p>设定一个定时器，当超过指定的时间后，没有收到对方的 <code>ACK</code> 确认应答报文，就会重发该数据<br>时间阈值称为RTO（Retransmission Timeout），是通过计算RTT的平均值来计算的</p><h5 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h5><p>不以时间为驱动，而是以数据驱动重传<br>也就是某个中间的数据包没有收到，会在超时重传前进行快速重传</p><h5 id="SACK（Selective-Acknowledgment）"><a href="#SACK（Selective-Acknowledgment）" class="headerlink" title="SACK（Selective Acknowledgment）"></a>SACK（Selective Acknowledgment）</h5><p>由于快速重传的时候不确定只重传当前数据包，还是把后面的数据包都重传，所以引入SACK<br>这种方式需要在 TCP 头部「选项」字段里加一个 <code>SACK</code> 的东西，它<strong>可以将已收到的数据的信息发送给「发送方」</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。<br>SACK字段放在【选项】中</p><h5 id="D-SACK-Duplicate-SACK"><a href="#D-SACK-Duplicate-SACK" class="headerlink" title="D SACK (Duplicate SACK)"></a>D SACK (Duplicate SACK)</h5><p>使用了 SACK 来告诉「发送方」有哪些数据被重复接收了</p><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a><a href="https://xiaolincoding.com/network/3_tcp/tcp_feature.html#duplicate-sack">滑动窗口</a></h4><p>TCP 引入了<strong>窗口</strong>这个概念。即使在往返时间较长的情况下，它也不会降低网络通信的效率。<br>窗口大小就是指<strong>无需等待确认应答，而可以继续发送数据的最大值</strong>。</p><p>TCP 头里有一个字段叫 <code>Window</code>，也就是窗口大小。<br>这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。</p><p>通常窗口的大小是由接收方的窗口大小来决定的。<br>发送方的窗口<br><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/16.jpg"></p><ul><li>#1 是已发送并收到 ACK确认的数据：1~31 字节</li><li>#2 是已发送但未收到 ACK确认的数据：32~45 字节</li><li>#3 是未发送但总大小在接收方处理范围内（接收方还有空间）：46~51字节</li><li>#4 是未发送但总大小超过接收方处理范围（接收方没有空间）：52字节以后</li></ul><p>接收方的窗口<br><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/20.jpg"></p><ul><li>#1 + #2 是已成功接收并确认的数据（等待应用进程读取）；</li><li>#3 是未收到数据但可以接收的数据；</li><li>#4 未收到数据并不可以接收的数据</li></ul><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a><a href="https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">流量控制</a></h4><p>TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制<br>避免「发送方」的数据填满「接收方」的缓存。</p><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a><a href="https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6">拥塞控制</a></h4><p>控制的目的就是<strong>避免「发送方」的数据填满整个网络</strong><br><strong>拥塞窗口 cwnd</strong>是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong><br>发送窗口是拥塞窗口和接收窗口中的最小值: swnd &#x3D; min(cwnd, rwnd)<br>拥塞窗口 <code>cwnd</code> 变化的规则：</p><ul><li>只要网络中没有出现拥塞，<code>cwnd</code> 就会增大；</li><li>但网络中出现了拥塞，<code>cwnd</code> 就减少；</li></ul><p>如何知道拥塞了：只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是发生了超时重传，就会认为网络出现了拥塞。</p><p>拥塞控制主要是四个算法：慢启动，拥塞避免，拥塞发生，快速恢复<br><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F-%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0"></p><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>查看网络连接 <code>netstat -napt</code><br><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/10.jpg"></p><p>三次握手<br>&#x3D;&#x3D;tcp 的握手和挥手中ACK的报文丢失是不会重传的，都是有对方重传&#x3D;&#x3D;<br><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png"></p><p>四次挥手<br>第一次：客户端FIN，表示不再发送数据了，但是还能收<br>第二次：服务端收到FIN，响应ACK，表示服务端可能还需要收发，等到不需要发时才会发送FIN给客户端<br>第三次：服务端FIN，服务端不再发送了<br>第四次：客户端ACK 进入time_wait,过两个MSL(max segment lifetime)后状态变成close</p><p>time_wait 2msl 是一个报文来回的时间<br>time_wait 存在的意义</p><ol><li>防止历史连接中的数据，被后面相同四元组的连接错误的接收（序列号和初始化序列号并不是无限递增的，会发生回绕为初始值的情况，这意味着无法根据序列号来判断新老数据）</li><li>保证「被动关闭连接」的一方，能被正确的关闭</li></ol><p>time_wait过多的危害</p><ol><li>占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等</li><li>占用端口资源</li></ol><p>服务端大量time_wait的原因（也极速服务端主动关闭连接的可能原因）</p><ol><li>没有使用长连接</li><li>长连接超时</li><li>长连接的请求数量达到上限（后主动关闭链接）</li></ol><p>服务端大量CLOSE_WAIT原因</p><ol><li>服务端没有调用 close 函数关闭连接（无法发送FIN的ACK）</li></ol><p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230614791.png"></p><h3 id="udp"><a href="#udp" class="headerlink" title="udp"></a>udp</h3><p>udp是面向报文的意思是UDP不会对消息做拆分，每个 UDP 报文就是一个用户消息的边界。</p><h4 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h4><ul><li>服务端和客户端初始化 <code>socket</code>，得到文件描述符；</li><li>服务端调用 <code>bind</code>，将 socket 绑定在指定的 IP 地址和端口;</li><li>服务端调用 <code>listen</code>，进行监听；</li><li>服务端调用 <code>accept</code>，等待客户端连接, 成功了会返回一个已完成连接的 socket</li><li>客户端调用 <code>connect</code>，向服务端的地址和端口发起连接请求，对应的服务端的accept，调用时阻塞，调用完后代表三次握手完成；</li><li>服务端 <code>accept</code> 返回用于传输的 <code>socket</code> 的文件描述符；</li><li>客户端调用 <code>write</code> 写入数据；服务端调用 <code>read</code> 读取数据；</li><li>客户端断开连接时，会调用 <code>close</code>，那么服务端 <code>read</code> 读取数据的时候，就会读取到了 <code>EOF</code>，待处理完数据后，服务端调用 <code>close</code>，表示连接关闭。<br><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230545997.png"></li></ul><p>与三次握手的关系<br><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/socket%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png"></p><p>ISN的计算方式<br>ISN &#x3D; M + F(localhost, localport, remotehost, remoteport)</p><ul><li><code>M</code> 是一个计时器，这个计时器每隔 4 微秒加 1。</li><li><code>F</code> 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。要保证 Hash 算法不能被外部轻易推算得出，用 MD5 算法是一个比较好的选择</li></ul><p>MSS(Maximum Segment Size) 最大TCP分段大小<br>MTU(Maximum Transmit Unit)  即物理接口（数据链路层）提供给其上层最大一次传输数据的大小, 缺省MTU&#x3D;1500<br>为啥有了MTU还要MSS<br>如果tcp的报文长度大于了ip的mtu，就需要在ip层进行分片，但是如果ip层的数据包丢失后ip是没有重传机制的，所以可能会存在丢失的可能。所以，为了达到最佳的传输效能 TCP 协议在<strong>建立连接的时候通常要协商双方的 MSS 值</strong>，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，自然也就不用 IP 分片了。</p><p>完整报文<br><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/11.jpg"></p><h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>报文格式<br><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/14.jpg"></p><h3 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h3><p>mac报文<br>arp ,rarp<br><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/21.jpg"></p><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>交换机工作在 MAC 层，也称为<strong>二层网络设备</strong>，的 MAC 地址表主要包含两个信息：</p><ul><li>一个是设备的 MAC 地址，</li><li>另一个是该设备连接在交换机的哪个端口上。<br><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/23.jpg"></li></ul><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p><strong>路由器</strong>是基于 IP 设计的，俗称<strong>三层</strong>网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址<br>首先，电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 <code>FCS</code> 进行错误校验。<br>如果没问题则检查 MAC 头部中的<strong>接收方 MAC 地址</strong>，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。<br>总的来说，路由器的端口都具有 MAC 地址，只接收与自身地址匹配的包，遇到不匹配的包则直接丢弃。<br>完成包接收操作之后，路由器就会<strong>去掉</strong>包开头的 MAC 头部。接下来，路由器会根据 MAC 头部后方的 <code>IP</code> 头部中的内容进行包的转发操作。<br>在网络包传输的过程中，<strong>源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址</strong>，因为需要 MAC 地址在以太网内进行<strong>两个设备</strong>之间的包传输</p><h3 id="http2"><a href="#http2" class="headerlink" title="http2"></a>http2</h3><h4 id="http1-1存在的缺陷"><a href="#http1-1存在的缺陷" class="headerlink" title="http1.1存在的缺陷"></a>http1.1存在的缺陷</h4><ol><li>文本格式</li><li>header数据重</li><li>1.1引入pipeline解决了一个TCP不能同时发多个请求的问题，但是由于响应还是按照请求顺序依次响应，存在响应队头阻塞的问题</li></ol><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><code>帧 frame</code>: http2的最小单位消息，总共定义了 10 种类型的帧，一般分为<strong>数据帧</strong>和<strong>控制帧</strong>两类，数据帧常见的类型有Data帧，header帧, 帧的头部有流id，来组装消息<br><code>流 stream</code>：虚拟通道，可以承载双向消息，每个流都有唯一的整数ID，多个流复用同一个tcp连接，达到并发请求<br><code>消息 message</code>：映射到逻辑请求或响应消息的完整帧序列。每个消息（可以是请求或响应）都被分解为多个二进制帧</p><p>也就是：</p><ol><li>一个tcp连接可以跑多个流，</li><li>一个流可以包含一个或多个消息（请求）</li><li>同一请求的数据放在一个流中</li><li>消息由多个frame组成</li></ol><p>帧格式<br><img src="https://cdn.xiaolincoding.com//picgo/image-20240105143208962.png"><br><img src="https://i.postimg.cc/DyjmXYYg/Pasted-image-20240204164223.png"></p><h4 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h4><h5 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h5><ul><li>同域名下通信在单个连接上</li><li>单个连接承载任意数量的双向数据流</li></ul><h5 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h5><h5 id="头部压缩-hpack"><a href="#头部压缩-hpack" class="headerlink" title="头部压缩(hpack)"></a>头部压缩(hpack)</h5><ul><li>两端维护头部索引表，只需发送索引即可</li><li>hpack主要包括三个部分：<ul><li>静态字典：在http2的框架的写死的常用的61组头部</li><li>动态字典</li><li>Huffman编码</li></ul></li></ul><h3 id="http3-quic"><a href="#http3-quic" class="headerlink" title="http3&#x2F;quic"></a>http3&#x2F;quic</h3><p>http2的缺陷</p><ol><li>由于tcp的原因（序列号低的消息丢失高的消息也不能被读取）导致的服务端对头阻塞</li><li>TCP 与 TLS 的握手时延迟</li><li>网络迁移需要重新连接</li></ol><h3 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h3><p>http1.1是半双工的协议，websocket是全双工的协议，tcp也是全双工的协议</p><h4 id="建立连接过程"><a href="#建立连接过程" class="headerlink" title="建立连接过程"></a>建立连接过程</h4><p>使用http协议进行tcp的三次握手, 加上升级协议头</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#请求头</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Upgrade: WebSocket</span><br><span class="line">Sec-WebSocket-Key: T2a6wZlAwhgQNqruZ2YUyg==\r\n</span><br><span class="line"></span><br><span class="line">#响应头</span><br><span class="line">HTTP/1.1 101 Switching Protocols\r\n</span><br><span class="line">Sec-WebSocket-Accept: iBJKv/ALIW2DobfoA4dmr3JHBCY=\r\n</span><br><span class="line">Upgrade: WebSocket\r\n</span><br><span class="line">Connection: Upgrade\r\n</span><br></pre></td></tr></table></figure><p><img src="https://cdn.xiaolincoding.com//mysql/other/f4edd3018914fe6eb38fad6aa3fd2d65.png"></p><h4 id="协议格式"><a href="#协议格式" class="headerlink" title="协议格式"></a>协议格式</h4><p><img src="https://cdn.xiaolincoding.com//mysql/other/690f5a4deda2de50f3a35eddf0be4d75.png"><br><strong>opcode字段</strong>：这个是用来标志这是个<strong>什么类型</strong>的数据帧。比如。</p><ul><li>等于 1 ，是指text类型（<code>string</code>）的数据包</li><li>等于 2 ，是二进制数据类型（<code>[]byte</code>）的数据包</li><li>等于 8 ，是关闭连接的信号<br><strong>payload字段</strong>：存放的是我们<strong>真正想要传输的数据的长度</strong>，单位是<strong>字节</strong></li></ul><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><h4 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h4><p>如何才能鉴别服务端给客户端的公钥是对的，引入第三方ca机构颁发证书（包含公钥，所有者，有效期，颁发机构等），并内置在浏览器内进行验证</p><h4 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h4><p>认证过程分为单向认证和双向认证，如果服务单校验客户端证书则为双向认证，否则为单向认证<br><img src="https://i.postimg.cc/RZWhQQkz/Pasted-image-20240204170107.png"><br>ssl的四次握手<br><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/tls%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B.png"></p><h3 id="无类型域间选路（CIDR）"><a href="#无类型域间选路（CIDR）" class="headerlink" title="无类型域间选路（CIDR）"></a>无类型域间选路（CIDR）</h3><p>废弃调ABCD的分类方式，通过数字将网络分为网络号和主机号两部分，例 10.100.122.2&#x2F;24</p><h3 id="各层的主流协议"><a href="#各层的主流协议" class="headerlink" title="各层的主流协议"></a>各层的主流协议</h3><p><img src="https://i.postimg.cc/B6BnQhK2/Pasted-image-20240304200433.png"></p><h3 id="请求优化方法"><a href="#请求优化方法" class="headerlink" title="请求优化方法"></a>请求优化方法</h3><ol><li>减少发送http请求<ol><li>使用缓存</li><li>合并请求<ol><li>小资源合并成大资源（多张小图转一张大图，webpack压缩，img转成base64等）</li></ol></li><li>懒加载</li></ol></li><li>减少响应数据大小<ol><li>无损压缩（霍夫曼编码)</li><li>有损压缩</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 八股 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang</title>
      <link href="/2024/01/26/read/golang/"/>
      <url>/2024/01/26/read/golang/</url>
      
        <content type="html"><![CDATA[<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://golang.design/go-questions/"># Go 程序员面试笔试宝典</a></p><h1 id="语法特性"><a href="#语法特性" class="headerlink" title="语法特性"></a>语法特性</h1><h2 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> f <span class="type">int</span> <span class="comment">//定义了新类型，底层类型是int %T 是 f</span></span><br><span class="line"><span class="keyword">type</span> g = <span class="type">int</span> <span class="comment">//没有定义新类型，g只是int的别名 %T 仍是 int</span></span><br></pre></td></tr></table></figure><h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><blockquote><p>context 用来解决 goroutine 之间<code>退出通知</code>、<code>元数据传递</code>的功能</p></blockquote><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口 DDEV</span></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">Err() <span class="type">error</span></span><br><span class="line">Value(key any) any</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造方式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span></span> Context</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Todo</span><span class="params">()</span></span> Context</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, deadline time.Time)</span></span> (Context, CancelFunc)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span></span> Context</span><br><span class="line"></span><br><span class="line">c := context.Background()<span class="comment">//空context</span></span><br></pre></td></tr></table></figure><p><img src="https://i.postimg.cc/sx31YFrn/Pasted-image-20240130142217.png"><br>ValueContext value的寻找路径<br>它会顺着链路一直往上找，比较当前节点的 key 是否是要找的 key，如果是，则直接返回 value。否则，一直顺着 context 往前，最终找到根节点（一般是 emptyCtx），直接返回一个 nil。所以用 Value 方法的时候要判断结果是否为 nil。<br>因为查找方向是往上走的，所以，父节点没法获取子节点存储的值，子节点却可以获取父节点的值。</p><h3 id="reflect"><a href="#reflect" class="headerlink" title="reflect"></a>reflect</h3><blockquote><p>Go 语言提供了一种机制在运行时更新变量和检查它们的值、调用它们的方法，但是在编译时并不知道这些变量的具体类型，这称为反射机制</p></blockquote><h4 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Type </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Value</span><br></pre></td></tr></table></figure><p><code>reflect.Type</code> 主要提供关于类型相关的信息，所以它和 <code>_type</code> 关联比较紧密<br><code>reflect.Value</code> 则结合 <code>_type</code> 和 <code>data</code> 两者，因此程序员可以获取甚至改变类型的值<br><img src="https://i.postimg.cc/XNgrVvft/Pasted-image-20240130201836.png"></p><h3 id="unsafe"><a href="#unsafe" class="headerlink" title="unsafe"></a>unsafe</h3><blockquote><p>将任意的指针类型转成unsafe.Pointer ，所指向的数据不能被垃圾回收，不能进行指针运算<br>uintptr 所指向的数据可以被垃圾回收，可以进行指针预算。</p></blockquote><ol><li>任何类型的指针和 unsafe.Pointer 可以相互转换。</li><li>uintptr 类型和 unsafe.Pointer 可以相互转换。<br><img src="https://i.postimg.cc/gj4j4McG/Pasted-image-20240130202050.png"></li></ol><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h2><ul><li>白色对象（可能死亡）：未被回收器访问到的对象。在回收开始阶段，所有对象均为白色，当回收结束后，白色对象均不可达。</li><li>灰色对象（波面）：已被回收器访问到的对象，但回收器需要对其中的一个或多个指针进行扫描，因为他们可能还指向白色对象。</li><li>黑色对象（确定存活）：已被回收器访问到的对象，其中所有字段都已被扫描，黑色对象中任何一个指针都不可能直接指向白色对象。</li></ul><h2 id="回收过程"><a href="#回收过程" class="headerlink" title="回收过程"></a>回收过程</h2><p>Go语言的垃圾回收（GC）过程是相对现代和高效的，设计上致力于减少应用程序的暂停时间。Go的垃圾回收器是一个并发的、三色标记清除（mark-sweep）垃圾回收器。下面是垃圾回收过程的大致步骤：</p><ol><li><strong>STW（Stop-The-World）开始阶段</strong>：<ul><li>垃圾回收过程开始时，首先会有一个非常短暂的STW暂停，以便垃圾回收器可以执行一些初始化工作，这包括停止所有的Goroutine，确保它们都处于一个已知的、一致的状态。会标记所有的根对象</li></ul></li><li><strong>标记（Mark）阶段</strong>：<ul><li>垃圾回收器首先会标记所有根对象。根对象通常包括全局变量和当前执行堆栈中的变量。</li><li>然后，垃圾回收器并发运行，遍历所有的根对象，标记所有从这些根能够达到的对象，根对象会被标记成灰色。这个过程使用的是三色标记法，通过灰色对象不断地发现新的白色对象，并将它们标记为灰色，最终变成黑色。</li><li>在标记阶段，写屏障（write barrier）确保任何写操作都会被正确处理，以维持垃圾回收的数据一致性。</li></ul></li><li><strong>STW结束阶段</strong>：<ul><li>一旦标记阶段完成，将会有另一个非常短暂的STW暂停。在这个阶段，写屏障会被禁用，并且垃圾回收器会完成最后的标记工作。</li></ul></li><li><strong>清除（Sweep）阶段</strong>：<ul><li>清除阶段通常是并发进行的，不需要停止程序的执行。在这个阶段，垃圾回收器遍历堆内存，释放那些在标记阶段最终仍然标记为白色的对象所占用的内存。</li></ul></li><li><strong>内存整理</strong>：<ul><li>Go的垃圾回收器不是一个压缩型的回收器，所以它不会移动对象来消除碎片。然而，Go使用了大小分级的空闲列表来减少内存碎片的影响。</li></ul></li><li><strong>结束</strong>： <ul><li>垃圾回收循环结束，应用程序继续其正常执行，直到下一个GC周期启动</li></ul></li></ol><h2 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h2><p>在标记阶段，为了避免停止整个程序（Stop-The-World, STW），Go的垃圾回收器会并发运行，与程序的其他部分一起执行。在这个并发执行期间，程序的执行线程可能会修改堆上的对象，这就可能导致一些问题，例如：</p><ul><li>程序可能会将一个黑色对象的引用赋值给一个白色对象，但是如果这个白色对象后来没有被扫描到，它就会在清扫（Sweep）阶段被错误地回收，这就破坏了垃圾回收器的正确性。<br>为了解决这个问题，Go引入了写屏障。写屏障是一个在内存写操作期间自动执行的检查，它确保在垃圾回收期间的内存写操作不会破坏垃圾回收器的不变性。具体来说，当程序试图写入一个指针（例如，将一个对象的引用赋值给另一个对象的字段时），写屏障会介入并执行以下操作：</li><li>如果写操作是把一个黑色对象的引用赋给一个白色对象，写屏障会将那个白色对象标记为灰色（或直接标记为黑色，取决于具体的实现）。这样，即使是在并发标记阶段，新的引用关系也会被正确处理，从而保证了垃圾回收的正确性。<br>写屏障的存在保证了即使在并发标记阶段，程序的正常运行也不会影响垃圾回收器的标记过程，使得并发垃圾回收成为可能，同时减少了程序的暂停时间。写屏障是实现高效垃圾回收机制的关键技术之一。在Go的实现中，写屏障通常只在垃圾回收的标记阶段启用，以减少其对程序性能的影响。</li></ul><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/slice.go</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">array unsafe.Pointer <span class="comment">// 元素指针</span></span><br><span class="line"><span class="built_in">len</span>   <span class="type">int</span> <span class="comment">// 长度 </span></span><br><span class="line"><span class="built_in">cap</span>   <span class="type">int</span> <span class="comment">// 容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩容策略"><a href="#扩容策略" class="headerlink" title="扩容策略"></a>扩容策略</h3><ol><li>version &lt;1.18: 当原 slice 容量小于 <code>1024</code> 的时候，新 slice 容量变成原来的 <code>2</code> 倍；原 slice 容量超过 <code>1024</code>，新 slice 容量变成原来的<code>1.25</code>倍</li><li>version &gt;&#x3D; 1.18:当原slice容量(oldcap)小于256的时候，新slice(newcap)容量为原来的2倍；原slice容量超过256，新slice容量$newcap &#x3D; oldcap+(oldcap+3*256)&#x2F;4$<br>在扩容后会有一个内存对齐的操作，所以扩容后的大小会大于等于上面计算出来的</li></ol><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="如何设计一个哈希表"><a href="#如何设计一个哈希表" class="headerlink" title="如何设计一个哈希表"></a>如何设计一个哈希表</h3><ol><li>好的hash函数：结果均匀分布</li><li>解决哈希冲突：开放地址法，链表法</li><li>缩扩容</li></ol><h3 id="申明方式"><a href="#申明方式" class="headerlink" title="申明方式"></a>申明方式</h3><h3 id="key类型"><a href="#key类型" class="headerlink" title="key类型"></a>key类型</h3><blockquote><p>必须支持 !&#x3D; 和 &#x3D;&#x3D; 比较，也就是 slice，func，map类型不支持</p></blockquote><h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">count     <span class="type">int</span> <span class="comment">//表示当前哈希表中的元素数量</span></span><br><span class="line">flags     <span class="type">uint8</span> <span class="comment">// iterator、oldlterator、hashWriting和 sameSizeGrow</span></span><br><span class="line">B         <span class="type">uint8</span><span class="comment">//当前哈希表持有的buckets 数量, 2^B个桶</span></span><br><span class="line">noverflow <span class="type">uint16</span> <span class="comment">//overflow bucket的大约数量</span></span><br><span class="line">hash0     <span class="type">uint32</span> <span class="comment">//哈希的种子</span></span><br><span class="line"></span><br><span class="line">buckets    unsafe.Pointer <span class="comment">//指向的是bmap[],每个bmap存储8个键值对</span></span><br><span class="line">oldbuckets unsafe.Pointer  <span class="comment">//在扩容时用于保存之前buckets`的字段</span></span><br><span class="line">nevacuate  <span class="type">uintptr</span> <span class="comment">//在map扩容阶段充当扩容进度计数器，所有下标号小于nevacuate的bucket都已经完成了</span></span><br><span class="line"></span><br><span class="line">extra *mapextra</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mapextra <span class="keyword">struct</span> &#123;</span><br><span class="line">overflow    *[]*bmap<span class="comment">//指向overflow bucket的指针</span></span><br><span class="line">oldoverflow *[]*bmap</span><br><span class="line">nextOverflow *bmap</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    topbits  [<span class="number">8</span>]<span class="type">uint8</span> <span class="comment">//存储哈希建的高8位</span></span><br><span class="line">    keys     [<span class="number">8</span>]keytype <span class="comment">//key， value分存储，减少了因内存对齐带来的内存浪费</span></span><br><span class="line">    values   [<span class="number">8</span>]valuetype</span><br><span class="line">    pad      <span class="type">uintptr</span></span><br><span class="line">    overflow <span class="type">uintptr</span> <span class="comment">//溢出后的指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://i.postimg.cc/K8Cz93b3/Pasted-image-20240126100429.png"></p><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><ol><li>装载因子已经超过 6.5；$\frac{count}{2^{B}}&gt;LoadFactor$</li><li>哈希使用了太多溢出桶；</li></ol><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol><li>如果是因为overflow bucket过多导致的“扩容”，实际上运行时会新建一个和现有规模<strong>一样</strong>的bucket数组–等量扩容 <code>sameSizeGrow</code>，然后在assign(插入)和delete(删除)时做排空和迁移</li><li>如果是因为当前数据数量超出LoadFactor指定水位而进行的扩容，那么运行时会建立一个<strong>两倍</strong>于现有规模的bucket数组–翻倍扩容，但真正的排空和迁移工作也是在assign和delete时逐步进行的。原bucket数组会挂在hmap的oldbuckets指针下面，直到原buckets数组中所有数据都迁移到新数组后，原buckets数组才会被释放(Go运行时可能会在某个点上主动完成剩余的迁移)</li></ol><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><blockquote><p>iface代表的是有方法的接口，eface代表的是无方法的接口，当时都包含data和_type的数据</p></blockquote><p>iface</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">tab  *itab</span><br><span class="line">data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">inter  *interfacetype</span><br><span class="line">_type  *_type</span><br><span class="line">link   *itab</span><br><span class="line">hash   <span class="type">uint32</span> <span class="comment">// copy of _type.hash. Used for type switches.</span></span><br><span class="line">bad    <span class="type">bool</span>   <span class="comment">// type does not implement interface</span></span><br><span class="line">inhash <span class="type">bool</span>   <span class="comment">// has this itab been added to hash?</span></span><br><span class="line">unused [<span class="number">2</span>]<span class="type">byte</span></span><br><span class="line">fun    [<span class="number">1</span>]<span class="type">uintptr</span> <span class="comment">// variable sized</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>eface</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">    _type *_type</span><br><span class="line">    data  unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口实现</p><blockquote><p>接收者是值类型的方法，相当于自动实现了接收者是指针类型的方法  值类型&#x3D;&#x3D; 值类型 + 指针类型的实现<br>接收者是指针类型的方法，不会自动生成对应接收者是值类型的方法  指针类型&#x3D;&#x3D; 指针类型</p></blockquote><p>是否实现接口检测</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ io.Writer = (*myWriter)(<span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">var</span> _ io.Writer = myWriter&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// chan 里元素数量</span></span><br><span class="line">qcount   <span class="type">uint</span></span><br><span class="line"><span class="comment">// chan 底层循环数组的长度</span></span><br><span class="line">dataqsiz <span class="type">uint</span></span><br><span class="line"><span class="comment">// 指向底层循环数组的指针</span></span><br><span class="line"><span class="comment">// 只针对有缓冲的 channel</span></span><br><span class="line">buf unsafe.Pointer</span><br><span class="line"><span class="comment">// chan 中元素大小</span></span><br><span class="line">elemsize <span class="type">uint16</span></span><br><span class="line"><span class="comment">// chan 是否被关闭的标志</span></span><br><span class="line">closed   <span class="type">uint32</span></span><br><span class="line"><span class="comment">// chan 中元素类型</span></span><br><span class="line">elemtype *_type <span class="comment">// element type</span></span><br><span class="line"><span class="comment">// 已发送元素在循环数组中的索引</span></span><br><span class="line">sendx    <span class="type">uint</span>   <span class="comment">// send index</span></span><br><span class="line"><span class="comment">// 已接收元素在循环数组中的索引</span></span><br><span class="line">recvx    <span class="type">uint</span>   <span class="comment">// receive index</span></span><br><span class="line"><span class="comment">// 等待接收的 goroutine 队列</span></span><br><span class="line">recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line"><span class="comment">// 等待发送的 goroutine 队列</span></span><br><span class="line">sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 保护 hchan 中所有字段</span></span><br><span class="line">lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.postimg.cc/G2w4p8Sn/Pasted-image-20240129162057.png"></p><h3 id="发送数据流程"><a href="#发送数据流程" class="headerlink" title="发送数据流程"></a>发送数据流程</h3><ol><li>首先，Go语言会检查channel是否已经关闭。如果channel已关闭，那么发送数据会直接触发panic。</li><li>判断channel是否为nil，如果是这挂起当前goroutine</li><li>然后，Go语言会检查是否有goroutine正在等待接收数据。如果有，那么发送数据会直接将数据发送给等待的goroutine，然后唤醒这个goroutine。</li><li>如果没有等待的goroutine，Go语言会尝试将数据存储到channel的缓冲区。如果缓冲区已满，那么发送数据的goroutine会被挂起，直到有空间将数据存储到缓冲区。</li><li>如果channel没有缓冲区（也就是非缓冲channel），那么发送数据的goroutine会被挂起，直到有goroutine来接收数据。</li><li>在数据被成功发送后，Go语言会唤醒所有等待在该channel上的goroutine，让它们有机会接收新的数据。</li></ol><h3 id="数据接收流程"><a href="#数据接收流程" class="headerlink" title="数据接收流程"></a>数据接收流程</h3><ol><li>首先，Go语言会检查发送队列是否有goroutine存在。如果有并且是非缓冲队列，那么接收数据会直接从channel的发送队列中取出数据。如果是缓冲队列，接收到循环数组头部的元素，并将发送者的元素放到循环数组尾部</li><li>如果发送队列没有goroutine存在，但是channel有缓冲区并且缓冲区中有数据，那么接收数据会从缓冲区中取出数据。</li><li>如果channel没有等待发送的数据，且channel的缓冲区为空或者没有缓冲区（也就是非缓冲channel），那么接收数据的goroutine会被挂起，直到有数据被发送到channel。</li><li>在数据被成功接收后，Go语言会唤醒所有等待在该channel上的goroutine，让它们有机会发送新的数据。</li><li>如果channel已经被关闭，并且channel中没有等待被接收的数据，那么接收操作会立即返回一个零值和一个可选的布尔值（如果使用了两值接收形式）。这个布尔值表示是否成功接收到数据，如果channel已经关闭，那么这个值将为false。</li></ol><h3 id="操作channel情况"><a href="#操作channel情况" class="headerlink" title="操作channel情况"></a>操作channel情况</h3><table><thead><tr><th>操作</th><th>nil channel</th><th>closed channel</th><th>not nil, not closed channel</th></tr></thead><tbody><tr><td>close</td><td>panic</td><td>panic</td><td>正常关闭</td></tr><tr><td>读 &lt;- ch</td><td>阻塞</td><td>读到对应类型的零值</td><td>阻塞或正常读取数据。缓冲型 channel 为空或非缓冲型 channel 没有等待发送者时会阻塞</td></tr><tr><td>写 ch &lt;-</td><td>阻塞</td><td>panic</td><td>阻塞或正常写入数据。非缓冲型 channel 没有等待接收者或缓冲型 channel buf 满时会被阻塞</td></tr></tbody></table><h3 id="channel内存泄露"><a href="#channel内存泄露" class="headerlink" title="channel内存泄露"></a>channel内存泄露</h3><p>goroutine 操作 channel 后，处于发送或接收阻塞状态，而 channel 处于满或空的状态，一直得不到改变。同时，垃圾回收器也不会回收此类资源，进而导致 gouroutine 会一直处于等待队列中，不能被回收。</p><h1 id="Goroutine调度器"><a href="#Goroutine调度器" class="headerlink" title="Goroutine调度器"></a>Goroutine调度器</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>将Goroutine按照一定算法放到不同的操作系统线程中去执行</p><h2 id="GPM调度器模型"><a href="#GPM调度器模型" class="headerlink" title="GPM调度器模型"></a>GPM调度器模型</h2><h3 id="GPM"><a href="#GPM" class="headerlink" title="GPM"></a>GPM</h3><ul><li>G: 代表Goroutine，存储了Goroutine的执行栈信息、Goroutine状态以及Goroutine的任务函数等，而且G对象是可以重用的；</li><li>P: 代表逻辑processor，为 M 的执行提供“上下文”，P的数量决定了系统内最大可并行的G的数量，P的最大作用还是其拥有的各种G对象队列、链表、一些缓存和状态；一个 M 只有绑定 P 才能执行 goroutine，当 M 被阻塞时，整个 P 会被传递给其他 M</li><li>M: 它代表一个工作线程，或者说系统线程，代表着真正的执行计算资源。在绑定有效的P后，进入一个调度循环，而调度循环的机制大致是<strong>从P的本地运行队列以及全局队列中获取G，切换到G的执行栈上并执行G的函数，调用goexit做清理工作并回到M，如此反复</strong>。M并不保留G状态，这是G可以跨M调度的基础。</li></ul><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列分为全局队列和P的本地队列<br>新创建的goroutine优先放在本地队列，如果本地队列满了，就拿本地队列的一半放倒全局队列</p><h3 id="work-stealing"><a href="#work-stealing" class="headerlink" title="work stealing"></a>work stealing</h3><p>当一个 P 发现自己的 LRQ 已经没有 G 时，并且这时 GRQ 也没有 G 了。这时，P2 会随机选择一个 P（称为 P1），P2 会从 P1 的 LRQ “偷”过来一半的 G</p><h3 id="hand-off"><a href="#hand-off" class="headerlink" title="hand off"></a>hand off</h3><p>当 M 执行的 G 发生阻塞操作或者发生了系统调用，M 就会阻塞，如果当前绑定的P还有要执行的 G,  Go runtime 会把这个 P 从 M 摘除，M 进入阻塞（对应下图中的M1），P 分离给其它空闲 M 调度（对应下图中的M2）<br>当 M 系统调用（或阻塞）结束时，这个 G 会尝试获取一个空闲的 P 执行，并放入到这个 P 的本地队列，如果获取不到 P，那么这个 G 加入到全局 G 里，这个 M 会加入到空闲线程列表中，重新可以进入调度循环<br><img src="https://i.postimg.cc/d12LZszk/Pasted-image-20240126184347.png"></p><h1 id="内存分配原理"><a href="#内存分配原理" class="headerlink" title="内存分配原理"></a>内存分配原理</h1><p>Go 语言的内存分配器会根据申请分配的内存大小选择不同的处理逻辑，运行时根据对象的大小将对象分成微对象、小对象和大对象三种：</p><table><thead><tr><th>类别</th><th>大小</th></tr></thead><tbody><tr><td>微对象</td><td><code>(0, 16B)</code></td></tr><tr><td>小对象</td><td><code>[16B, 32KB]</code></td></tr><tr><td>大对象</td><td><code>(32KB, +∞)</code></td></tr></tbody></table><ol><li><strong>小对象分配</strong>：<ul><li>Go 使用了一种叫做 <code>tcmalloc</code> (Thread-Caching Malloc) 的技术，这是 Google 开发的一种内存分配技术。</li><li>对于小对象（一般是小于或等于 32KB 的对象），Go 运行时维护了多个固定大小的类别（class），每个类别对应一组大小相同的对象。</li><li>每个处理器（P）有自己的本地缓存（mcache），用于分配小对象。当一个 Goroutine 请求分配内存时，它首先检查本地 mcache 是否有可用的空间，如果有，则直接从本地缓存分配，这个操作不需要加锁，因此非常快。</li></ul></li><li><strong>大对象分配</strong>：<ul><li>对于大于 32KB 的对象，内存分配不经过 mcache，而是直接从中央堆（central heap）分配。</li><li>分配大对象时，通常需要加锁，因为中央堆是被所有处理器共享的。</li></ul></li><li><strong>内存分配器的层次结构</strong>：<ul><li><strong>Mcache</strong>：每个处理器（P）的本地缓存，用于快速分配和释放小对象。</li><li><strong>Mcentral</strong>：中央缓存，负责管理一组大小相同的 mcache。当 mcache 用完时，它会向 mcentral 请求更多的内存。</li><li><strong>Mheap</strong>：所有内存分配请求的全局堆，管理所有的 mcentral。大对象直接从 mheap 分配。<br><img src="https://i.postimg.cc/G2vbT7G9/image.png" alt="image.png"></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 八股 </tag>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux性能调优</title>
      <link href="/2024/01/24/read/linux%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
      <url>/2024/01/24/read/linux%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</url>
      
        <content type="html"><![CDATA[<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98">资料来源</a></p><h2 id="分析问题的一般步骤"><a href="#分析问题的一般步骤" class="headerlink" title="分析问题的一般步骤"></a>分析问题的一般步骤</h2><h3 id="CPU性能分析"><a href="#CPU性能分析" class="headerlink" title="CPU性能分析"></a>CPU性能分析</h3><p><img src="https://i.postimg.cc/QCDKf9pJ/Pasted-image-20240125200945.png"></p><h3 id="磁盘和文件系统I-O性能分析"><a href="#磁盘和文件系统I-O性能分析" class="headerlink" title="磁盘和文件系统I&#x2F;O性能分析"></a>磁盘和文件系统I&#x2F;O性能分析</h3><p><img src="https://i.postimg.cc/J73kGxL6/Pasted-image-20240125201146.png"></p><h3 id="网络性能分析"><a href="#网络性能分析" class="headerlink" title="网络性能分析"></a>网络性能分析</h3><p><img src="https://i.postimg.cc/8cbJ9p4Q/Pasted-image-20240125201226.png"></p><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><h3 id="进程和CPU原理"><a href="#进程和CPU原理" class="headerlink" title="进程和CPU原理"></a>进程和CPU原理</h3><p>进程与线程<br>CPU调度<br>中断系统<br>CPU缓存<br>NUMA</p><h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><h4 id="平均负载"><a href="#平均负载" class="headerlink" title="平均负载"></a>平均负载</h4><blockquote><p>系统处于<strong>可运行状态</strong>和<strong>不可中断状态</strong>的平均进程数，也就是<strong>平均活跃进程数</strong>，当平均负载大于CPU数量70%的时间需要注意</p></blockquote><p>由于负载包含了等待IO的进程，所以负载和CPU使用率不能完全划等号，如果是CPU密集型，这两者几乎是一直的，如果是IO密集型，CPU使用率不一定高</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uptime</span></span><br><span class="line">11:22:02 up 552 days, 12:47,  1 user,  load average: 4.10, 4.06, 3.79</span><br><span class="line">当前时间，已运行时间，登录用户数，每分钟，5分钟，15分钟的平均负载</span><br></pre></td></tr></table></figure><h4 id="CPU使用率"><a href="#CPU使用率" class="headerlink" title="CPU使用率"></a>CPU使用率</h4><p>用户CPU<br>系统CPU<br>iowait （等待IO的CPU使用率）<br>硬中断 （其实就是要把网卡的数据读到内存中，然后更新一下硬件寄存器的状态（表示数据已经读好了），最后再发送一个<strong>软中断</strong>信号）<br>软中断 （从内存中找到网络数据，再按照网络协议栈，对数据进行逐层解析和处理，直到把它送给应用程序 在&#x2F;proc&#x2F;softirqs可查看）<br>窃取CPU<br>客户CPU</p><h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h4><blockquote><p>CPU 上下文切换，就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务</p></blockquote><h5 id="按任务不同划分"><a href="#按任务不同划分" class="headerlink" title="按任务不同划分"></a>按任务不同划分</h5><ol><li>进程上下文切换<blockquote><p>进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态</p></blockquote></li><li>线程上下文切换<blockquote><p>因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据</p></blockquote></li><li>中断上下文切换<br>自愿上下文切换<br>非自愿上下文切换</li></ol><h4 id="CPU缓存命中率"><a href="#CPU缓存命中率" class="headerlink" title="CPU缓存命中率"></a>CPU缓存命中率</h4><h3 id="性能剖析"><a href="#性能剖析" class="headerlink" title="性能剖析"></a>性能剖析</h3><h4 id="top-ps"><a href="#top-ps" class="headerlink" title="top&#x2F;ps"></a>top&#x2F;ps</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">top - 15:26:26 up 125 days, 21:01,  1 user,  load average: 17.20, 15.05, 16.71</span><br><span class="line">Tasks:  48 total,   1 running,  47 sleeping,   0 stopped,   0 zombie</span><br><span class="line">Cpu(s): 38.0% us, 12.7% sy,  2.7% ni, 44.8% <span class="built_in">id</span>,  1.0% wa,  0.0% hi,  0.8% si</span><br><span class="line">Mem:  196170728k total, 186873632k used,  9297096k free,  2712492k buffers</span><br><span class="line">Swap:        0k total,        0k used,        0k free, 128334812k cached</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND</span><br><span class="line">45143 work      20   0 1107m 232m  13m S  5.3  0.1 237:11.44 ral-agent</span><br></pre></td></tr></table></figure><p>cpu的数据在第三行</p><ul><li>user（通常缩写为 us），代表用户态 CPU 时间。注意，它不包括下面的 nice 时间，但包括了 guest 时间。</li><li>nice（通常缩写为 ni），代表低优先级用户态 CPU 时间，也就是进程的 nice 值被调整为 1-19 之间时的 CPU 时间。这里注意，nice 可取值范围是 -20 到 19，数值越大，优先级反而越低。</li><li>system（通常缩写为sys），代表内核态 CPU 时间。</li><li>idle（通常缩写为id），代表空闲时间。注意，它不包括等待 I&#x2F;O 的时间（iowait）。</li><li>iowait（通常缩写为 wa），代表等待 I&#x2F;O 的 CPU 时间。</li><li>irq（通常缩写为 hi），代表处理硬中断的 CPU 时间。</li><li>softirq（通常缩写为 si），代表处理软中断的 CPU 时间。</li><li>steal（通常缩写为 st），代表当系统运行在虚拟机中的时候，被其他虚拟机占用的 CPU 时间。</li><li>guest（通常缩写为 guest），代表通过虚拟化运行其他操作系统的时间，也就是运行虚拟机的 CPU 时间。</li><li>guest_nice（通常缩写为 gnice），代表以低优先级运行虚拟机的时间。<br>S列的状态枚举</li><li><strong>R</strong> 是 Running 或 Runnable 的缩写，表示进程在 CPU 的就绪队列中，正在运行或者正在等待运行。</li><li><strong>D</strong> 是 Disk Sleep 的缩写，也就是不可中断状态睡眠（Uninterruptible Sleep），一般表示进程正在跟硬件交互，并且交互过程不允许被其他进程或中断打断。</li><li><strong>Z</strong> 是 Zombie 的缩写，它表示僵尸进程，也就是进程实际上已经结束了，但是父进程还没有回收它的资源（比如进程的描述符、PID 等）。</li><li><strong>S</strong> 是 Interruptible Sleep 的缩写，也就是可中断状态睡眠，表示进程因为等待某个事件而被系统挂起。当进程等待的事件发生时，它会被唤醒并进入 R 状态。</li><li><strong>I</strong> 是 Idle 的缩写，也就是空闲状态，用在不可中断睡眠的内核线程上。前面说了，硬件交互导致的不可中断进程用 D 表示，但对某些内核线程来说，它们有可能实际上并没有任何负载，用 Idle 正是为了区分这种情况。要注意，D 状态的进程会导致平均负载升高， I 状态的进程却不会</li></ul><h4 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每隔5秒输出1组数据 $ vmstat 5 </span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- --system-- ----cpu----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   <span class="keyword">in</span>    cs us sy <span class="built_in">id</span> wa</span><br><span class="line">10  0      0 18101528 2727076 128367312    0    0     0     0    0     0 35 10 53  2</span><br><span class="line">19  0      0 17971712 2727080 128359792    0    0     0     0 181662 343710 34 12 54  1</span><br></pre></td></tr></table></figure><ul><li>r（Running or Runnable）是就绪队列的长度，也就是正在运行和等待CPU的进程数。</li><li>b（Blocked）则是处于不可中断睡眠状态的进程数。</li><li>cs（context switch）是每秒上下文切换的次数。</li><li>in（interrupt）则是每秒中断的次数。</li></ul><h4 id="mpstat"><a href="#mpstat" class="headerlink" title="mpstat"></a>mpstat</h4><h4 id="sar"><a href="#sar" class="headerlink" title="sar"></a>sar</h4><h4 id="pidstat"><a href="#pidstat" class="headerlink" title="pidstat"></a>pidstat</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">03:21:26 PM       PID   cswch/s nvcswch/s  Command</span><br><span class="line">03:21:31 PM         3     99.40      0.20  matrix-init-pro</span><br><span class="line">03:21:31 PM     36399      2.00      0.00  nginx</span><br><span class="line">03:21:31 PM     36400      1.00      0.00  nginx</span><br><span class="line">03:21:31 PM     36401      2.00      0.20  nginx</span><br><span class="line">03:21:31 PM     36402      2.00      0.00  nginx</span><br></pre></td></tr></table></figure><ul><li>cswch （voluntary context switches）的次数</li><li>nvcswch（non voluntary context switches）</li></ul><h4 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h4><h4 id="perf"><a href="#perf" class="headerlink" title="perf"></a>perf</h4><h4 id="execsnoop"><a href="#execsnoop" class="headerlink" title="execsnoop"></a>execsnoop</h4><h4 id="proc文件系统"><a href="#proc文件系统" class="headerlink" title="proc文件系统"></a>proc文件系统</h4><p>&#x2F;proc&#x2F;stat<br>&#x2F;proc&#x2F;[pid]&#x2F;stat</p><h3 id="调优方法"><a href="#调优方法" class="headerlink" title="调优方法"></a>调优方法</h3><p>CPU绑定<br>进程CPU自愿限制<br>进程优先级调整<br>中断负载均衡<br>CPU缓存<br>NUMA优化 （Non-Uniform Memory Access）</p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><h3 id="内存原理"><a href="#内存原理" class="headerlink" title="内存原理"></a>内存原理</h3><p>内存地址<br>虚拟内存<br>内存分配与回收<br>缓存与缓冲区</p><ol><li>Buffers 是内核缓冲区用到的内存(对<strong>磁盘</strong>数据的缓存)，对应的是 <code>/proc/meminfo</code> 中的 Buffers 值</li><li>Cache 是内核页缓存和Slab用到的内存(对<strong>文件</strong>数据的缓存)，对应的是 <code>/proc/meminfo</code> 中的 Cached 与 SReclaimable 之和<br>SWAP</li></ol><h3 id="性能指标-1"><a href="#性能指标-1" class="headerlink" title="性能指标"></a>性能指标</h3><p>系统内存使用量<br>进程内存使用量<br>缓存与缓冲区命中率<br>swap使用量</p><h3 id="性能剖析-1"><a href="#性能剖析-1" class="headerlink" title="性能剖析"></a>性能剖析</h3><ol><li>先用free和top，查看系统整体的内存使用情况。</li><li>再用vmstat和pidstat，查看一段时间的趋势，从而判断出内存问题的类型。</li><li>最后进行详细分析，比如内存分配分析、缓存&#x2F;缓冲区分析、具体进程的内存使用分析等。</li></ol><h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:     527636740  478091560   49545180          0   34889028  356636252</span><br><span class="line">-/+ buffers/cache:   86566280  441070460</span><br><span class="line">Swap:            0          0          0</span><br></pre></td></tr></table></figure><h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">top - 20:39:01 up 552 days, 22:04,  1 user,  load average: 4.68, 4.02, 3.61</span><br><span class="line">Tasks:  46 total,   1 running,  45 sleeping,   0 stopped,   0 zombie</span><br><span class="line">Cpu(s):  4.4% us,  2.1% sy,  2.9% ni, 90.5% <span class="built_in">id</span>,  0.0% wa,  0.0% hi,  0.1% si</span><br><span class="line">Mem:  527636740k total, 478203424k used, 49433316k free, 34889028k buffers</span><br><span class="line">Swap:        0k total,        0k used,        0k free, 356744572k cached</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND</span><br><span class="line"> 7938 work      20   0 5181m 1.2g  97m S  3.0  0.2   9312:45 hhvm_bin</span><br><span class="line">    3 root      20   0 15536  404   44 S  0.0  0.0 265:43.28 matrix-init-pro</span><br><span class="line"> 7936 work      20   0  3208  392  292 S  0.0  0.0   0:00.38 supervise.hhvm</span><br><span class="line"> 7945 work      20   0 1104m 634m 2076 S  0.0  0.1   0:00.01 hhvm_bin</span><br></pre></td></tr></table></figure><ul><li>VIRT 是进程虚拟内存的大小，只要是进程申请过的内存，即便还没有真正分配物理内存，也会计算在内。</li><li>RES 是常驻内存的大小，也就是进程实际使用的物理内存大小，但不包括 Swap 和共享内存。</li><li>SHR 是共享内存的大小，比如与其他进程共同使用的共享内存、加载的动态链接库以及程序的代码段等。</li><li>%MEM 是进程使用物理内存占系统总内存的百分比。<br>sar<br>vmstat<br>cachestat<br>cahcetop<br>memleak<br>proc文件系统 &#x2F;proc&#x2F;meminfo</li></ul><h3 id="调优方法-1"><a href="#调优方法-1" class="headerlink" title="调优方法"></a>调优方法</h3><p>利用缓存与缓冲区<br>减少swap使用<br>减少动态分配内存<br>优化NUMA<br>限制进程内存志愿<br>使用HugePage</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="网络原理"><a href="#网络原理" class="headerlink" title="网络原理"></a>网络原理</h3><table><thead><tr><th></th><th></th><th></th><th>数据</th><th></th></tr></thead><tbody><tr><td></td><td></td><td>TCP头部(20 bytes)</td><td>数据</td><td></td></tr><tr><td></td><td>IP头(20 bytes)</td><td>TCP头部</td><td>数据</td><td></td></tr><tr><td>帧头</td><td>IP头</td><td>TCP头部</td><td>数据</td><td>帧尾</td></tr></tbody></table><ul><li>MTU ip包的最大传输单元<br>网络配置<br>TCP&#x2F;IP协议<br>网络收发流程</li></ul><ol><li>当一个网络帧到达网卡后，网卡会通过 DMA 方式，把这个网络包放到收包队列中；然后通过硬中断，告诉中断处理程序已经收到了网络包</li><li>网卡中断处理程序会为网络帧分配内核数据结构（sk_buff），并将其拷贝到 sk_buff 缓冲区中；然后再通过软中断，通知内核收到了新的网络帧</li><li>内核协议栈从缓冲区中取出网络帧，并通过网络协议栈，从下到上逐层处理这个网络帧<ul><li>在链路层检查报文的合法性，找出上层协议的类型（比如 IPv4 还是 IPv6），再去掉帧头、帧尾，然后交给网络层。</li><li>网络层取出 IP 头，判断网络包下一步的走向，比如是交给上层处理还是转发。当网络层确认这个包是要发送到本机后，就会取出上层协议的类型（比如 TCP 还是 UDP），去掉 IP 头，再交给传输层处理。</li><li>传输层取出 TCP 头或者 UDP 头后，根据 &lt;源 IP、源端口、目的 IP、目的端口&gt; 四元组作为标识，找出对应的 Socket，并把数据拷贝到 Socket 的接收缓存中。<br>高级路由<br>网络QoS<br>网络防火墙<br>C10K与C100K</li></ul></li><li>C10K<blockquote><p>1999年提出，对应的是早期32位操作系统，linux2.2，2GB内存，千兆网卡，对于这样的服务器，要支撑10000的请求，那么对应的单个请求，内存&#x3D;2GB&#x2F;10000&#x3D;200K, 带宽&#x3D;1000Mbit&#x2F;10000&#x3D;100Kbit。物理资源是够的，主要是软件的问题，尤其是网络IO模型的问题。C10k以前，主要是同步阻塞IO，每个请求都分配一个进程或者线程，无法满足C10K的请求。</p></blockquote></li></ol><p>要解决的问题</p><ol><li>一个线程内处理多个请求</li></ol><p>触发方式</p><ul><li>水平触发（Level-triggered）：这种模式下，只要某个条件满足（例如：数据可读、可写等），系统就会触发通知。例如，如果你注册了“数据可读”事件，那么只要有数据可读，<strong>不管你是否已经读取</strong>，系统都会不断地发出通知。这就像一种状态通知，只要满足这个状态，就会触发。</li><li>边缘触发（Edge-triggered）：这种模式下，只有在状态发生变化时（例如：从无数据可读变为有数据可读），系统才会触发通知。也就是说，如果数据已经可读，然后你读取了部分数据，剩余的数据即使仍然可读，系统也不会再发出通知。这就像一种事件通知，只有事件发生时才会触发。</li></ul><p>多路复用IO</p><ol><li><p>select 或poll</p><blockquote><p>缺点：1024限制，遍历的复杂度是o(N)</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> infds = select(maxfd + <span class="number">1</span>, &amp;tmpfdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//遍历infds</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> eventfd = <span class="number">0</span>; eventfd &lt;= maxfd; eventfd++) &#123;</span><br><span class="line"><span class="type">int</span> clientsock = accept(listensock, (<span class="keyword">struct</span> sockaddr *)&amp;client, &amp;len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>epoll (linux 2.6)</p><blockquote><p>epoll 使用红黑树，在内核中管理文件描述符的集合; epoll 使用事件驱动的机制，只关注有 I&#x2F;O 事件发生的文件描述符，不需要轮询扫描整个集合</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建eventpoll对象, size用来告诉内核这个监听的数目一共有多大</span></span><br><span class="line"><span class="comment">//int size 给一个大于0的数就行, 没有太多意义</span></span><br><span class="line"><span class="comment">// return epfd</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>；</span><br><span class="line"></span><br><span class="line"><span class="comment">//int epfd epoll_create返回的fd</span></span><br><span class="line"><span class="comment">//int op 表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD</span></span><br><span class="line"><span class="comment">//int fd  是需要监听的fd（文件描述符）</span></span><br><span class="line"><span class="comment">//struct epoll_event *event 是告诉内核需要监听什么事件</span></span><br><span class="line"><span class="comment">//return 0:success &lt;0 : error</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>；</span><br><span class="line"></span><br><span class="line"><span class="comment">//int epfd epoll_create返回的fd</span></span><br><span class="line"><span class="comment">//struct epoll_event * events 存放有事件发生的结构数组</span></span><br><span class="line"><span class="comment">//int timeout 超时时间</span></span><br><span class="line"><span class="comment">//return int &gt; 0: 就绪的文件描述符数量 0: 没有就绪的文件描述符 &lt;0: error</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event * events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure><p><img src="https://i.postimg.cc/K8jkpygw/Pasted-image-20240125170507.png"></p></li><li><p>AIO linux 2.6引入，不完善 </p></li><li><p>C100K</p><blockquote><p>可以通过加大内存和网卡来解决 </p></blockquote></li><li><p>C10M</p><blockquote><p>跳过内核协议栈的冗长路径，把网络包直接送到要处理的应用程序那里去; DPDK, XDP</p></blockquote></li></ol><p>DNS</p><ul><li>A 记录，用来把域名转换成 IP 地址；</li><li>CNAME 记录，用来创建别名；</li><li>而 NS 记录，则表示该域名对应的域名服务器地址(由顶级DNS服务器返回根DNS服务器时就是NS记录)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ping time.geekbang.org</span><br><span class="line">nslookup time.geekbang.org</span><br><span class="line">dig +trace +nodnssec time.geekbang.org</span><br></pre></td></tr></table></figure>TCP<br><img src="https://i.postimg.cc/028JmS58/Pasted-image-20240125193429.png"></li></ul><ol><li>SYN Flood攻击<ol><li>调大tcp_max_syn_backlog，调小net.ipv4.tcp_synack_retries</li><li>开启TCP SYN Cookies （不会维护半连接队列）<br>NAT</li></ol></li></ol><ul><li>静态 NAT，即内网 IP 与公网 IP 是一对一的永久映射关系；</li><li>动态 NAT，即内网 IP 从公网 IP 池中，动态选择一个进行映射；</li><li>网络地址端口转换 NAPT（Network Address and Port Translation），即把内网 IP 映射到公网 IP 的不同端口上，让多个内网 IP 可以共享同一个公网 IP 地址 <strong>✓</strong></li></ul><h3 id="性能指标-2"><a href="#性能指标-2" class="headerlink" title="性能指标"></a>性能指标</h3><p>吞吐量： 单位时间内成功传输的数据量</p><ul><li>BPS</li><li>QPS</li><li>PPS： Packet Per Second<br>延迟：从网络请求发出后，一直到收到远端响应，所需要的时间延迟<br>丢包<br>TCP重传</li></ul><h3 id="性能剖析-2"><a href="#性能剖析-2" class="headerlink" title="性能剖析"></a>性能剖析</h3><p>ethtool<br>sar<br>ping<br>netstat&#x2F;ss</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># -l 表示只显示监听套接字 </span><br><span class="line"># -n 表示显示数字地址和端口(而不是名字) </span><br><span class="line"># -t 表示只显示 TCP 套接字</span><br><span class="line"># -p 表示显示进程信息</span><br><span class="line">netstat -nlp</span><br><span class="line"></span><br><span class="line"># Recv-Q 表示套接字缓冲还没有被应用程序取走的字节数（即接收队列长度）,被 accept() 系统调用取走</span><br><span class="line"># 而 Send-Q 表示还没有被远端主机确认的字节数（即发送队列长度）</span><br><span class="line"></span><br><span class="line">(Not all processes could be identified, non-owned process info</span><br><span class="line"> will not be shown, you would have to be root to see it all.)</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address               Foreign Address             State       PID/Program name</span><br><span class="line">tcp        0      0 *:793                       *:*                         LISTEN      -</span><br><span class="line">tcp        0      0 *:8633                      *:*                         LISTEN      -</span><br><span class="line">tcp        0      0 *:409                       *:*                         LISTEN      -</span><br></pre></td></tr></table></figure><p>ifstat<br>ifconfig<br>tcpdump<br>wireshark<br>iptables<br>traceoute<br>ipcontrack<br>perf</p><h3 id="调优方法-2"><a href="#调优方法-2" class="headerlink" title="调优方法"></a>调优方法</h3><h4 id="网卡调优"><a href="#网卡调优" class="headerlink" title="网卡调优"></a>网卡调优</h4><p>MTU<br>队列长度<br>链路聚合</p><h4 id="协议调优"><a href="#协议调优" class="headerlink" title="协议调优"></a>协议调优</h4><p>HTTP<br>TCP<br>overlay</p><h4 id="资源控制"><a href="#资源控制" class="headerlink" title="资源控制"></a>资源控制</h4><p>QoS</p><h4 id="内核调优"><a href="#内核调优" class="headerlink" title="内核调优"></a>内核调优</h4><p>NAT调优<br>功能写在<br>负载均衡<br>DPDK</p><h4 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h4><h5 id="最大连接数是不是受限于-65535-个端口？"><a href="#最大连接数是不是受限于-65535-个端口？" class="headerlink" title="最大连接数是不是受限于 65535 个端口？"></a>最大连接数是不是受限于 65535 个端口？</h5><ol><li>对客户端来说，每次发起 TCP 连接请求时，都需要分配一个空闲的本地端口，去连接远端的服务器。由于这个本地端口是独占的，所以客户端最多只能发起 65535 个连接</li><li>对服务器端来说，其通常监听在固定端口上（比如 80 端口），等待客户端的连接。根据五元组结构，我们知道，客户端的IP和端口都是可变的。如果不考虑 IP 地址分类以及资源限制，服务器端的理论最大连接数，可以达到 2 的 48 次方（IP 为 32 位，端口号为 16 位），远大于65535</li></ol><h2 id="磁盘IO"><a href="#磁盘IO" class="headerlink" title="磁盘IO"></a>磁盘IO</h2><h3 id="磁盘原理"><a href="#磁盘原理" class="headerlink" title="磁盘原理"></a>磁盘原理</h3><p>磁盘管理</p><blockquote><p><strong>磁盘实际上是作为一个块设备来管理的</strong>，也就是以块为单位读写数据</p></blockquote><p>磁盘类型</p><blockquote><p>HDD SSD</p></blockquote><p>磁盘接口<br> &gt;IDE（Integrated Drive Electronics）、SCSI（Small Computer System Interface） 、SAS（Serial Attached SCSI） 、SATA（Serial ATA） 、FC（Fibre Channel）</p><p>通用块层</p><blockquote><p>处在文件系统和磁盘驱动中间的一个块设备抽象层。 第一个功能跟虚拟文件系统的功能类似。向上，为文件系统和应用程序，提供访问块设备的标准接口；向下，把各种异构的磁盘设备抽象为统一的块设备，并提供统一框架来管理这些设备的驱动程序。 第二个功能，通用块层还会给文件系统和应用程序发来的 I&#x2F;O 请求排队，并通过重新排序、请求合并等方式，提高磁盘读写的效率</p></blockquote><p>磁盘I&#x2F;O栈</p><ul><li>文件系统层，包括虚拟文件系统和其他各种文件系统的具体实现。它为上层的应用程序，提供标准的文件访问接口；对下会通过通用块层，来存储和管理磁盘数据。</li><li>通用块层，包括块设备 I&#x2F;O 队列和 I&#x2F;O 调度器。它会对文件系统的 I&#x2F;O 请求进行排队，再通过重新排序和请求合并，然后才要发送给下一级的设备层。</li><li>设备层，包括存储设备和相应的驱动程序，负责最终物理设备的I&#x2F;O操作</li></ul><h3 id="性能指标-3"><a href="#性能指标-3" class="headerlink" title="性能指标"></a>性能指标</h3><p>使用率<br>iops<br>吞吐量<br>iostat</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">iostat iostat -x</span><br><span class="line">Linux 4.14.0_1-0-0-30 (m1-sys-rpm2767e5725.m1.baidu.com) 01/25/2024 _x86_64_(48 CPU)</span><br><span class="line">avg-cpu:  %user   %<span class="built_in">nice</span> %system %iowait  %steal   %idle</span><br><span class="line">           5.36    0.94    2.44    0.30    0.00   90.95</span><br><span class="line">Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn</span><br><span class="line">nvme0n1           0.24         0.00         1.59      29294   75858240</span><br><span class="line">nvme1n1           0.22         0.00         1.43       1278   68183796</span><br><span class="line">sda              48.25        10.03      1028.90  479752447 49207812913</span><br><span class="line">sdb              38.90        11.98      1017.21  572815306 48648596420</span><br><span class="line">sdc              28.20         8.49       750.63  406106130 35899261756</span><br><span class="line">sdd              20.55         8.14       595.56  389184494 28482909728</span><br></pre></td></tr></table></figure><h3 id="性能剖析-3"><a href="#性能剖析-3" class="headerlink" title="性能剖析"></a>性能剖析</h3><p>dstat<br>sar<br>iowait<br>pidstat<br>iotop<br>iolatency<br>blktrace<br>fio 文件系统和磁盘 I&#x2F;O 性能基准测试工具<br>perf</p><h3 id="调优方法-3"><a href="#调优方法-3" class="headerlink" title="调优方法"></a>调优方法</h3><p>系统调用<br>IO资源控制<br>充分利用缓存<br>raid<br>IO隔离</p><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="文件系统原理"><a href="#文件系统原理" class="headerlink" title="文件系统原理"></a>文件系统原理</h3><p><img src="https://i.postimg.cc/TwgWjqWP/Pasted-image-20240125104300.png"><br>文件结构</p><blockquote><p>目录项(directory entry)  + 索引节点(index node) + 逻辑块 + 超级块</p></blockquote><p>虚拟文件系统</p><blockquote><p>为了支持各种不同的文件系统，Linux内核在用户进程和文件系统的中间，又引入了一个抽象层，也就是虚拟文件系统VFS（Virtual File System）</p></blockquote><p>文件系统IO栈<br>缓冲I&#x2F;O与非缓冲I&#x2F;O</p><ul><li>缓冲I&#x2F;O，是指利用标准库缓存来加速文件的访问，而标准库内部再通过系统调度访问文件。</li><li>非缓冲I&#x2F;O，是指直接通过系统调用来访问文件，不再经过标准库缓存</li></ul><p>直接I&#x2F;O与非直接I&#x2F;O</p><ul><li>直接I&#x2F;O，是指跳过操作系统的页缓存，直接跟文件系统交互来访问文件。</li><li>非直接I&#x2F;O正好相反，文件读写时，先要经过系统的页缓存，然后再由内核或额外的系统调用，真正写入磁盘</li></ul><p>同步和异步I&#x2F;O （消息响应的方式）</p><ul><li>所谓同步I&#x2F;O，是指应用程序执行I&#x2F;O操作后，要一直等到整个I&#x2F;O完成后，才能获得I&#x2F;O响应。</li><li>所谓异步I&#x2F;O，是指应用程序执行I&#x2F;O操作后，不用等待完成和完成后的响应，而是继续执行就可以。等到这次 I&#x2F;O完成后，响应会用事件通知的方式，告诉应用程序。</li></ul><p>阻塞与非阻塞IO （调用者是否被阻塞）</p><ul><li>阻塞I&#x2F;O：应用程序在执行I&#x2F;O操作后，如果没有获得响应，就会阻塞当前线程，不能执行其他任务</li><li>非阻塞I&#x2F;O：是指应用程序在执行I&#x2F;O操作后，不会阻塞当前的线程，可以继续执行其他的任务</li></ul><p>文件系统缓存<br>文件系统种类</p><h3 id="性能指标-4"><a href="#性能指标-4" class="headerlink" title="性能指标"></a>性能指标</h3><p>容量<br><code>df -h</code><br>iops<br>缓存命中率</p><h3 id="性能剖析-4"><a href="#性能剖析-4" class="headerlink" title="性能剖析"></a>性能剖析</h3><p>df<br>strace<br>vmstat<br>sar<br>perf<br>proc文件系统</p><h3 id="调优方法-4"><a href="#调优方法-4" class="headerlink" title="调优方法"></a>调优方法</h3><p>应用层</p><ol><li>追加写答题随机写</li><li>借助缓存IO</li><li>频繁读写一块磁盘，用mmap答题read&#x2F;write，减少内存拷贝<br>文件系统层</li><li>选择最合适的文件系统 ext4， xfs</li><li>进一步优化文件系统的配置选项</li><li>文件系统的缓存<br>磁盘层</li><li>ssd代替hdd</li><li>RAID</li><li>合适的IO调度算法</li></ol><h2 id="linux内核"><a href="#linux内核" class="headerlink" title="linux内核"></a>linux内核</h2><h3 id="内核原理"><a href="#内核原理" class="headerlink" title="内核原理"></a>内核原理</h3><p>内核态</p><h3 id="性能剖析-5"><a href="#性能剖析-5" class="headerlink" title="性能剖析"></a>性能剖析</h3><p>BPF<br>perf<br>proc文件系统</p><h3 id="内核调优-1"><a href="#内核调优-1" class="headerlink" title="内核调优"></a>内核调优</h3><p>内核选项</p><h2 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h2><h3 id="性能指标-5"><a href="#性能指标-5" class="headerlink" title="性能指标"></a>性能指标</h3><p>吞吐量<br>响应时间<br>资源利用率</p><h3 id="性能剖析-6"><a href="#性能剖析-6" class="headerlink" title="性能剖析"></a>性能剖析</h3><h4 id="USE方法"><a href="#USE方法" class="headerlink" title="USE方法"></a>USE方法</h4><p>使用率<br>饱和度<br>错误</p><h4 id="进程剖析"><a href="#进程剖析" class="headerlink" title="进程剖析"></a>进程剖析</h4><p>进程状态<br>资源利用率<br>IO剖析<br>系统调用<br>热点函数<br>动态追踪</p><h4 id="APM"><a href="#APM" class="headerlink" title="APM"></a>APM</h4><h3 id="调优方法-5"><a href="#调优方法-5" class="headerlink" title="调优方法"></a>调优方法</h3><p>逻辑优化<br>编程语言<br>算法调优<br>非阻塞IO<br>利用缓存与缓冲区<br>异步处理与并发<br>垃圾回收</p><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><h3 id="空间换时间"><a href="#空间换时间" class="headerlink" title="空间换时间"></a>空间换时间</h3><p>缓存<br>缓冲区<br>冗余数据</p><h3 id="时间换空间"><a href="#时间换空间" class="headerlink" title="时间换空间"></a>时间换空间</h3><p>压缩编码<br>页面交换</p><h3 id="并行处理"><a href="#并行处理" class="headerlink" title="并行处理"></a>并行处理</h3><p>多线程<br>多进程<br>分布式</p><h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><p>异步IO<br>消息队列<br>时间通知</p><h2 id="性能监控"><a href="#性能监控" class="headerlink" title="性能监控"></a>性能监控</h2><h3 id="时间序列分析"><a href="#时间序列分析" class="headerlink" title="时间序列分析"></a>时间序列分析</h3><p>历史趋势分析<br>性能模型构建<br>未来趋势预测</p><h3 id="服务调用追踪"><a href="#服务调用追踪" class="headerlink" title="服务调用追踪"></a>服务调用追踪</h3><p>服务盗用流程追踪<br>服务调用性能分析<br>服务盗用链拓扑展示</p><h3 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h3><p>趋势图<br>散点图<br>热点图<br>饼图</p><h3 id="告警通知"><a href="#告警通知" class="headerlink" title="告警通知"></a>告警通知</h3><p>阈值选择<br>报警策略<br>通知渠道</p><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><h3 id="明确需求"><a href="#明确需求" class="headerlink" title="明确需求"></a>明确需求</h3><p>系统资源需求<br>应用程序需求</p><h3 id="环境假设"><a href="#环境假设" class="headerlink" title="环境假设"></a>环境假设</h3><p>合理的假设<br>生产环境模拟<br>生产负载模拟</p><h3 id="性能测试-1"><a href="#性能测试-1" class="headerlink" title="性能测试"></a>性能测试</h3><p>基准测试<br>负载测试<br>压力测试</p><h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><p>应用程序瓶颈<br>数据集瓶颈<br>系统资源瓶颈</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 八股 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存</title>
      <link href="/2024/01/21/read/%E7%BC%93%E5%AD%98/"/>
      <url>/2024/01/21/read/%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p>缓存中的7大经典问题</p><ul><li>缓存失效</li><li>缓存穿透</li><li>缓存血崩</li><li>数据不一致</li><li>数据并发竞争</li><li>Hot Key</li><li>Big Key</li></ul><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><blockquote><p>通常见于攻击中，故意构造一个不存在的key，查询穿透到db</p></blockquote><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ol><li>对null值进行缓存 + 较短的过期时间</li><li>bloom filter （bit array + multi hash func）</li></ol><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><blockquote><p>热点key失效</p></blockquote><h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><ol><li>热点数据设置成永不失效</li><li>数据预热</li><li>请求数据库之前加互斥锁，保证只有一个请求到db</li></ol><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><blockquote><p>缓存同一时间大面积失效，导致请求都打到数据库，可能是key大面积失效或者部分缓存节点不可用导致的</p></blockquote><h3 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h3><ol><li>对于key大面积失效，设置过期时间&#x3D;baes 时间+随机时间</li><li>对于2，使用集群避免单点故障 限流等</li></ol><h2 id="数据不一致"><a href="#数据不一致" class="headerlink" title="数据不一致"></a>数据不一致</h2><h3 id="可能原因"><a href="#可能原因" class="headerlink" title="可能原因"></a>可能原因</h3><ol><li>数据库更新后，缓存更新失败 （重试）</li></ol><h2 id="数据并发竞争（缓存击穿）"><a href="#数据并发竞争（缓存击穿）" class="headerlink" title="数据并发竞争（缓存击穿）"></a>数据并发竞争（缓存击穿）</h2><h2 id="Hot-Key"><a href="#Hot-Key" class="headerlink" title="Hot Key"></a>Hot Key</h2><blockquote><p>流量比较高的key，打满缓存节点的cpu，带宽等节点资源</p></blockquote><ol><li>提前预测hot key</li><li>通过spark等流式任务发现hot key</li></ol><h3 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h3><p>在key后面加后缀 key#1，key#2方式分散请求</p><h2 id="Big-Key"><a href="#Big-Key" class="headerlink" title="Big Key"></a>Big Key</h2><blockquote><p>那些大小远远超过平均水平的键值对</p></blockquote><h3 id="可能的危害"><a href="#可能的危害" class="headerlink" title="可能的危害"></a>可能的危害</h3><ol><li>操作big key 读写需要占用更多的cpu资源，网卡带宽等</li><li>内存碎片化更严重</li><li>主从延迟增加</li></ol><h3 id="解决-4"><a href="#解决-4" class="headerlink" title="解决"></a>解决</h3><ol><li>尽量避免使用big key</li><li>数据压缩</li><li>数据拆分</li></ol><h2 id="缓存模式"><a href="#缓存模式" class="headerlink" title="缓存模式"></a>缓存模式</h2><h3 id="cache-aside-旁路缓存"><a href="#cache-aside-旁路缓存" class="headerlink" title="cache aside 旁路缓存"></a>cache aside 旁路缓存</h3><p>数据更新：更新数据库，删除缓存<br>数据读取：缓存有数据直接返回，没有数据先读数据库，再写入缓存</p><h2 id="MemCache"><a href="#MemCache" class="headerlink" title="MemCache"></a>MemCache</h2><h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><ol><li>预分配内存池：在启动时，Memcached 会预先分配一大块连续的内存空间作为内存池，其大小由启动参数指定（例如使用 <code>-m</code> 参数）。这个内存池不会在运行时扩展，因此 Memcached 的内存使用上限是固定的。</li><li>划分Slab Class：内存池被划分成多个 slab class，每个 class 用于存储特定大小范围的对象。一个 slab class 包含多个大小相等的 slab 页面（通常是1MB大小），每个 slab 页面又被切分成固定大小的 chunk，用于存储实际的数据项。</li><li>根据大小分配对象：当一个新的数据项需要被缓存时，Memcached 根据其大小选择适当的 slab class，并在该 class 的一个 slab 页面中找到一个空闲的 chunk 来存放这个数据项。这样，大小相似的数据项就会被存储在同一个 slab class 中。不同 slabclass 的 chunk size 按递增因子依次增加，满足不同大小的数据进行存储</li><li>内存满时的处理：当所有的 slab 页面都被占用时，Memcached 将使用LRU（最近最少使用）算法，或者其他过期策略来淘汰旧的数据项，为新的数据项腾出空间。 </li><li>自动调整Slab 页面：Memcached 会监控各个 slab class 的使用情况，如果发现某些 slab class 的页面使用率很高，而其他 class 的页面使用率很低，它可以通过自动调整算法将低使用率 class 的页面分配给高使用率的 class，以优化内存使用。<br><img src="https://i.postimg.cc/XvyZ3cLg/Pasted-image-20240121173418.png"></li></ol><h3 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h3><ol><li>惰性删除，获取时</li><li>内存不足时回收</li><li>LRU维护线程</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 八股 </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2024/01/18/read/mysql/"/>
      <url>/2024/01/18/read/mysql/</url>
      
        <content type="html"><![CDATA[<h2 id="三大log"><a href="#三大log" class="headerlink" title="三大log"></a>三大log</h2><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><ol><li>write ahead logging, 提高写并发 ，acid中的d</li><li>innodb_io_capacity， flush_log_at_trx_commit 0,1,2</li></ol><h3 id="bin-log"><a href="#bin-log" class="headerlink" title="bin log"></a>bin log</h3><ol><li>server层的日志</li><li>用于主从同步</li><li>用户数据恢复（row）</li><li>sync_bin_log 0,1,N</li></ol><h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><ol><li>事物回滚</li><li>mvcc实现多版本并发控制</li></ol><h2 id="B-Tree中的N路搜索树"><a href="#B-Tree中的N路搜索树" class="headerlink" title="B+Tree中的N路搜索树"></a>B+Tree中的N路搜索树</h2><p>N取决于页大小，innodb默认页大小为16k，<br>17亿数据只需三次磁盘访问<br>在B+Tree的非叶子结点中，存的是值和下个节点的指针。以bigint 8字节为例，指针为6字节，一个单位大概是14字节，每个页大概是16K，大约能存放 16000&#x2F;(8+6) &#x3D; 1142 ~ 1200<br>$1200^{3} &#x3D; 17亿$</p><h3 id="B-Tree与B-Tree的区别"><a href="#B-Tree与B-Tree的区别" class="headerlink" title="B-Tree与B+Tree的区别"></a>B-Tree与B+Tree的区别</h3><ol><li>B树允许在任何节点存储数据，而B+树仅在叶子节点存储数据。</li><li>由于B+树的叶子节点形成了一个有序链表，因此B+树在进行范围查询时更加高效。</li></ol><h2 id="myisam与innodb的区别"><a href="#myisam与innodb的区别" class="headerlink" title="myisam与innodb的区别"></a>myisam与innodb的区别</h2><p>下面是一个简单的表格，总结了MyISAM和InnoDB两种存储引擎的主要区别：</p><table><thead><tr><th>特性</th><th>MyISAM</th><th>InnoDB</th></tr></thead><tbody><tr><td>事务支持</td><td>不支持</td><td>支持</td></tr><tr><td>锁定机制</td><td>表级锁</td><td>行级锁，支持MVCC</td></tr><tr><td>外键支持</td><td>不支持</td><td>支持</td></tr><tr><td>崩溃恢复</td><td>支持较差，崩溃后恢复比较复杂</td><td>支持较好，通过事务日志和缓冲池恢复</td></tr><tr><td>全文索引支持</td><td>支持</td><td>MySQL 5.6开始支持</td></tr><tr><td>存储限制</td><td>单个表文件大小可以达到256TB</td><td>单个表文件大小依据操作系统的文件大小限制而定</td></tr><tr><td>并发性</td><td>读操作不阻塞其他读操作，写操作阻塞所有读写操作</td><td>使用MVCC支持更高级别的并发</td></tr><tr><td>适用场景</td><td>适合读密集型应用，不需要事务的场景</td><td>适合写密集型和需要高并发事务处理的应用</td></tr><tr><td>《MySQL 高性能》上面有一句话这样写到:</td><td></td><td></td></tr></tbody></table><blockquote><p>不要轻易相信“MyISAM 比 InnoDB 快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB 的速度都可以让 MyISAM 望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。</p></blockquote><h2 id="索引的名词"><a href="#索引的名词" class="headerlink" title="索引的名词"></a>索引的名词</h2><h3 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h3><blockquote><p>只需要访问索引即可查到所有的数据，不需要回表，效率高 Using index</p></blockquote><h3 id="索引下推-（Index-Condition-Pushdown-ICP）-5-6"><a href="#索引下推-（Index-Condition-Pushdown-ICP）-5-6" class="headerlink" title="索引下推 （Index Condition Pushdown ICP）&gt;&#x3D;5.6"></a>索引下推 （Index Condition Pushdown ICP）&gt;&#x3D;5.6</h3><blockquote><p>在条件查询中 where a &#x3D; b and c&#x3D;d，通过索引内容评估该记录是否满足，而不是回表去判断  Using index condition</p></blockquote><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>select count(distinct left(field, 6))&#x2F;select count(*) 来测试区分度</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>通过加锁范围分类</p><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>flush tables with read&#x2F;write lock;</p><h3 id="表级锁，表锁"><a href="#表级锁，表锁" class="headerlink" title="表级锁，表锁"></a>表级锁，表锁</h3><p>meta data lock (ddl加写锁，其他加读锁)<br>表锁：lock tables .. read&#x2F;write</p><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p>innodb的锁</p><h2 id="两阶段锁协议"><a href="#两阶段锁协议" class="headerlink" title="两阶段锁协议"></a>两阶段锁协议</h2><ol><li>锁不是在执行begin的时候加的，是在第一个执行语句才加</li><li>在执行commit的时候释放</li></ol><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>更新是先读后写，读是当前读</p><h2 id="有危险的刷脏页行为"><a href="#有危险的刷脏页行为" class="headerlink" title="有危险的刷脏页行为"></a>有危险的刷脏页行为</h2><ol><li>redo log文件写满</li><li>内存不足（要淘汰的脏页数量太多）</li></ol><h2 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h2><ol><li>全字段排序<ol><li>通过max_length_for_sort_buffer判断是否能使用全字段排序</li></ol></li><li>row id排序<br>如果sort buffer不够的话，会使用文件排序</li></ol><h2 id="查询慢可能导致的情况"><a href="#查询慢可能导致的情况" class="headerlink" title="查询慢可能导致的情况"></a>查询慢可能导致的情况</h2><ol><li>索引失效（使用函数，不满足最左原则）</li><li>隐式的类型转换（string转int ）</li><li>隐式的编码转换</li></ol><h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><blockquote><p>rr的隔离通过next key lock（gap lock + 行锁）解决解决了幻读的问题，但是当前读除外（update， select for update &#x2F;in share mode）<br>幻读指的是新插入的行</p></blockquote><h2 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h2><h3 id="复制过程"><a href="#复制过程" class="headerlink" title="复制过程"></a>复制过程</h3><ol><li>master dump thread 将bin log传给slave</li><li>slave的io_thread 将bin log转成relay log，sql_thread执行数据同步操作</li></ol><h3 id="延迟的原因"><a href="#延迟的原因" class="headerlink" title="延迟的原因"></a>延迟的原因</h3><ol><li>备库配置比主库差</li><li>备库的压力比较大</li><li>ddl</li><li>大事务</li></ol><h3 id="主备切换的方式"><a href="#主备切换的方式" class="headerlink" title="主备切换的方式"></a>主备切换的方式</h3><ol><li>基于位点</li><li>基于gtid</li></ol><h3 id="防止过期读的方式"><a href="#防止过期读的方式" class="headerlink" title="防止过期读的方式"></a>防止过期读的方式</h3><ol><li>强制走主库</li><li>sleep方案</li><li>判读second_behind_master &#x3D;0再执行查询（show slave status）</li><li>semi-sync的方式可满足一主一从，对于都从无效</li><li>基于gtid的查询</li></ol><h2 id="判断数据库是否正常"><a href="#判断数据库是否正常" class="headerlink" title="判断数据库是否正常"></a>判断数据库是否正常</h2><ol><li>select 1 (只能判断mysql服务进程存在，如果并发查询线程数满了不能检测，最常用)</li><li>select * from mysql.heal_check （能检测出并发线程数满的情况，但是如果数据库满了不能检测）</li><li>update mysql.health_check set .. （最优）</li></ol><h2 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h2><ol><li>kill query thread_id 通常是给ctrl +c的这种方式用的api，这种会新建一个mysql链接，然后执行kill query</li><li>kill [connection] thread_id 先断开对应的mysql链接，再执行kill query的逻辑</li></ol><h2 id="buffer-pool"><a href="#buffer-pool" class="headerlink" title="buffer pool"></a>buffer pool</h2><p>使用lru的算法进行内存淘汰策略，分为young(5&#x2F;8)和old(3&#x2F;8)区，超过1s没有被访问的数据才会放倒young区，对于全表扫描（一个页的访问间隔会小于1s）的情况都只是在old区，不会有影响</p><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><blockquote><p>使用小表作为驱动表 （进行where筛选后数据量小的表）</p></blockquote><h3 id="index-nested-loop-join-NLJ"><a href="#index-nested-loop-join-NLJ" class="headerlink" title="index nested loop join(NLJ)"></a>index nested loop join(NLJ)</h3><p>被驱动表能用到索引时使用这种方案。效率高</p><h3 id="block-nested-loop-join-BNL"><a href="#block-nested-loop-join-BNL" class="headerlink" title="block nested loop join(BNL)"></a>block nested loop join(BNL)</h3><p>被驱动表不能使用索引时使用的方式，效率不高</p><ol><li>将<strong>驱动表</strong>的数据放入join buffer中，再全表扫描被驱动表的数据进行连接</li></ol><h2 id="临时表"><a href="#临时表" class="headerlink" title="临时表"></a>临时表</h2><ol><li>group by</li><li>union</li></ol><h2 id="分布式事物"><a href="#分布式事物" class="headerlink" title="分布式事物"></a>分布式事物</h2><h3 id="xa协议"><a href="#xa协议" class="headerlink" title="xa协议"></a>xa协议</h3><blockquote><p>XA协议是一个很流行的分布式事务协议，可以很好地支撑我们实现分布式事务，比如常见的2PC、3PC等</p></blockquote><p>在XA协议里有三个主要的角色：</p><ul><li><strong>应用（AP）</strong>：应用是具体的业务逻辑代码实现，业务逻辑通过请求事务协调器开启全局事务，在事务协调器注册多个子事务后，业务代码会依次给所有参与事务的子业务下发请求。待所有子业务提交成功后，业务代码根据返回情况告诉事务协调器各个子事务的执行情况，由事务协调器决策子事务是提交还是回滚（有些实现是事务协调器发请求给子服务）。</li><li><strong>事务协调器（TM）</strong>：用于创建主事务，同时协调各个子事务。事务协调器会根据各个子事务的执行情况，决策这些子事务最终是提交执行结果，还是回滚执行结果。此外，事务协调器很多时候还会自动帮我们提交事务；(通常是在业务层实现的协调)</li><li><strong>资源管理器（RM）</strong>：是一种支持事务或XA协议的数据资源，比如MySQL、Redis等。</li></ul><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><p><img src="https://i.postimg.cc/Qt3MDLHX/Pasted-image-20240205194046.png"></p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;database/sql&quot;</span></span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   _ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">   <span class="string">&quot;strconv&quot;</span></span><br><span class="line">   <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 库存的连接</span></span><br><span class="line">   stockDb, err := sql.Open(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;root:paswd@tcp(127.0.0.1:3306)/shop_product_stock&quot;</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err.Error())</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span> stockDb.Close()</span><br><span class="line">   <span class="comment">//订单的连接</span></span><br><span class="line">   orderDb, err := sql.Open(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;root:paswd@tcp(127.0.0.1:3307)/shop_order&quot;</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err.Error())</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span> orderDb.Close()</span><br><span class="line">   <span class="comment">//钱包的连接</span></span><br><span class="line">   moneyDb, err := sql.Open(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;root:paswd@tcp(127.0.0.1:3308)/user_money_bag&quot;</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err.Error())</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span> moneyDb.Close()</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 生成xid(如果在同一个数据库，子事务不能使用相同xid)</span></span><br><span class="line">   xid := strconv.FormatInt(time.Now().UnixMilli(), <span class="number">10</span>)</span><br><span class="line">   <span class="comment">//如果后续执行过程有报错，那么回滚所有子事务</span></span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         stockDb.Exec(<span class="string">&quot;XA ROLLBACK ?&quot;</span>, xid)</span><br><span class="line">         orderDb.Exec(<span class="string">&quot;XA ROLLBACK ?&quot;</span>, xid)</span><br><span class="line">         moneyDb.Exec(<span class="string">&quot;XA ROLLBACK ?&quot;</span>, xid)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 第一阶段 Prepare</span></span><br><span class="line">   <span class="comment">// 库存 子事务启动</span></span><br><span class="line">   <span class="keyword">if</span> _, err = stockDb.Exec(<span class="string">&quot;XA START ?&quot;</span>, xid); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err.Error())</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//扣除库存，这里省略了数据行锁操作</span></span><br><span class="line">   <span class="keyword">if</span> _, err = stockDb.Exec(<span class="string">&quot;update product_stock set stock=stock-1 where id =1&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err.Error())</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//事务执行结束</span></span><br><span class="line">   <span class="keyword">if</span> _, err = stockDb.Exec(<span class="string">&quot;XA END ?&quot;</span>, xid); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err.Error())</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//设置库存任务为Prepared状态</span></span><br><span class="line">   <span class="keyword">if</span> _, err = stockDb.Exec(<span class="string">&quot;XA PREPARE ?&quot;</span>, xid); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err.Error())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 订单 子事务启动</span></span><br><span class="line">   <span class="keyword">if</span> _, err = orderDb.Exec(<span class="string">&quot;XA START ?&quot;</span>, xid); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err.Error())</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//创建订单</span></span><br><span class="line">   <span class="keyword">if</span> _, err = orderDb.Exec(<span class="string">&quot;insert shop_order(id,pid,xx) value (1,2,3)&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err.Error())</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//事务执行结束</span></span><br><span class="line">   <span class="keyword">if</span> _, err = orderDb.Exec(<span class="string">&quot;XA END ?&quot;</span>, xid); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err.Error())</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//设置任务为Prepared状态</span></span><br><span class="line">   <span class="keyword">if</span> _, err = orderDb.Exec(<span class="string">&quot;XA PREPARE ?&quot;</span>, xid); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err.Error())</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 钱包 子事务启动</span></span><br><span class="line">   <span class="keyword">if</span> _, err = moneyDb.Exec(<span class="string">&quot;XA START ?&quot;</span>, xid); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err.Error())</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//扣减用户账户现金，这里省略了数据行锁操作</span></span><br><span class="line">   <span class="keyword">if</span> _, err = moneyDb.Exec(<span class="string">&quot;update user_money_bag set money=money-1 where id =9527&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err.Error())</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//事务执行结束</span></span><br><span class="line">   <span class="keyword">if</span> _, err = moneyDb.Exec(<span class="string">&quot;XA END ?&quot;</span>, xid); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err.Error())</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//设置任务为Prepared状态</span></span><br><span class="line">   <span class="keyword">if</span> _, err = moneyDb.Exec(<span class="string">&quot;XA PREPARE ?&quot;</span>, xid); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err.Error())</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 在这时，如果链接断开、Prepared状态的XA事务仍旧在MySQL存在</span></span><br><span class="line">   <span class="comment">// 任意一个链接调用XA RECOVER都能够看到这三个没有最终提交的事务</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">// --------</span></span><br><span class="line">   <span class="comment">// 第二阶段 运行到这里没有任何问题</span></span><br><span class="line">   <span class="comment">// 那么执行 commit</span></span><br><span class="line">   <span class="comment">// --------</span></span><br><span class="line">   <span class="keyword">if</span> _, err = stockDb.Exec(<span class="string">&quot;XA COMMIT ?&quot;</span>, xid); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err.Error())</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> _, err = orderDb.Exec(<span class="string">&quot;XA COMMIT ?&quot;</span>, xid); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err.Error())</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> _, err = moneyDb.Exec(<span class="string">&quot;XA COMMIT ?&quot;</span>, xid); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err.Error())</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//到这里全部流程完毕</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>资源锁时间比较长</li><li>如果一个节点参与了事务但在第二阶段无法完成提交或回滚操作，可能会导致整个系统的部分故障</li></ul><h3 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h3><blockquote><p>TCC是Try-Confirm-Cancel的缩写</p></blockquote><p>首先在 <strong>Try阶段</strong>，业务代码会预留业务所需的全部资源，比如冻结用户账户100元、提前扣除一个商品库存、提前创建一个没有开始交易的订单等，这样可以减少各个子事务锁定的数据量。业务拿到这些资源后，后续两个阶段操作就可以无锁进行了。<br>在 <strong>Confirm阶段</strong>，业务确认所需的资源都拿到后，子事务会并行执行这些业务。执行时可以不做任何锁互斥，也无需检查，直接执行Try阶段准备的所有资源就行。<br>请注意，协议要求所有操作都是幂等的，以支持失败重试，因为在一些特殊情况下，比如资源锁争抢超时、网络不稳定等，操作要尝试执行多次才会成功。<br>最后在 <strong>Cancel阶段</strong>：如果子事务在Try阶段或Confirm阶段多次执行重试后仍旧失败，TM就会执行Cancel阶段的代码，并释放Try预留的资源，同时回滚Confirm期间的内容。注意，Cancel阶段的代码也要做幂等，以支持多次执行。</p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>业务侵入性强</li><li>复杂度高</li><li>要求幂等</li></ul><h2 id="Mysql脆弱的原因"><a href="#Mysql脆弱的原因" class="headerlink" title="Mysql脆弱的原因"></a>Mysql脆弱的原因</h2><ol><li>数据存储在磁盘</li><li>通常是一主多从，写在主节点，并发能力有限</li><li>不能并发查询</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 八股 </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人性的弱点</title>
      <link href="/2023/11/25/read/%E4%BA%BA%E6%80%A7%E7%9A%84%E5%BC%B1%E7%82%B9/"/>
      <url>/2023/11/25/read/%E4%BA%BA%E6%80%A7%E7%9A%84%E5%BC%B1%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>第一篇 与人相处的基本技巧<br>1.不要批评，责怪或抱怨他人<br>2.真诚地赞赏他人<br>3.想到他人的需求，并告诉他如何实现（影响他人的唯一方式）  </p><p>第二篇 平安快乐的要诀<br>1.无须模仿他人，发现自我<br>2.保持良好的工作习惯<br>3.放松自己，消除疲劳<br>4.不要对事情感到倦怠，要使它充满乐趣<br>5.想的开心，做的开心，你就会真的觉得开心<br>6.永远不要对敌人心存报复，这样对你自己的伤害将大过对别人的<br>7.享受付出的快乐，不要期望他人感恩<br>8.对得到的帮助心存感激<br>9.命运给你酸柠檬，把它做成柠檬汁<br>10.忘却自己，对别人多感兴趣<br>11.凡事尽力，不必太在意指责<br>12.记下自己干的蠢事，自我批评  </p><p>第三篇 如何使人喜欢你<br>1.真诚地关心别人<br>2.保持微笑<br>3.记住他人的姓名，这将有助于加深对方对你的印象<br>4.做一个善于倾听的人，鼓励别人谈论自己<br>5.谈论别人感兴趣的话题<br>6.让他人感到自己重要-而且要真诚而为  </p><p>第四篇 如何赢得他人的赞同<br>1.避免与人争论<br>2.对他人的意见表示尊重，别说“你错了”<br>3.你错了，就迅速而真诚地承认<br>4.以友善的方式开始<br>5.首先让别人说“是，是的”<br>6.让对方多说话<br>7.让别人觉得那是他自己的主意<br>8.真诚地尽力从对方的角度看事情<br>9.同情对方的意念及愿望<br>10.激发他人的高尚动机<br>11.将你的意图戏剧性地表现出来<br>12.给他人提出挑战  </p><p>第五篇 如何更好地说服他人<br>1.从称赞与真诚的欣赏开始<br>2.间接地指出他人错误<br>3.指责别人前，先想想自己的错误<br>4.保全他人的面子<br>5.称赞他人的每个微小进步<br>6.给人一个美名，并使之努力保全<br>7.鼓励的办法使人改正错误<br>8.使对方乐于做你建议的事  </p><p>第六篇 幸福的家庭生活<br>1.切勿,切勿喋喋不休<br>2.不要试图改造你的配偶<br>3.不要批判你的丈夫或妻子<br>4.给与对方真诚的欣赏<br>5.对妻子或丈夫要有礼貌<br>6.学会与她相处<br>(1)感谢她，称赞她<br>(2)要慷慨，关心<br>(3)不要过于不修边幅<br>(4)了解她的工作<br>(5)做她的后盾<br>(6)分享她的嗜好<br>(7)爱你的妻子<br>7.了解一些必备的性知识  </p><p>第七篇 如何使你变得更加成熟<br>1.为自己的行为负责<br>2.不要在乎困难，或许它也是一种机遇<br>3.学会摆脱生活中的不幸<br>4.拥有自己的信仰并付诸行动<br>5.你是独一无二的<br>(1)每天抽出时间独处，以进一步认识自己<br>(2)打破习惯的束缚<br>(3)发现生活中什么东西最能让我们感到满足<br>6.了解并喜欢你自己<br>7.不要盲从因袭，听从你内心的声音<br>8.注意自己身上令人讨厌的地方<br>(1)不停谈论小孩或宠物<br>(2)谈话没有重点<br>(3)完全不理会他人的话题<br>(4)不要一直争论不休<br>(5)永远唱低调的人<br>9.要让别人喜欢你，先得使自己让人喜欢  </p><p>第八篇 走出孤独忧虑的人生<br>1.幸福不来自于他人的布施，而是你自己去赢得别人对你的需求和喜爱<br>2.消除心中的忧虑<br>3.对于忧虑的问题，考虑最坏情况，接受这种可能，冷静处理善后<br>4.问题，问题的原因，可能的几种解决方案，你的选择<br>5.让自己处于忙碌状态<br>6.活在今天<br>7.不要为小事烦心<br>8.计算事情发生的概率<br>9.接受不可避免发生的事实  </p><p>第九篇 不要为金钱和工作烦恼<br>1.慎重做出职业生涯和生活中的重大决定<br>(1)研究职业选择建议<br>(2)避免哪些原已拥挤的职业和事业<br>(3)避免哪些维生机会只有1&#x2F;10的行业<br>(4)决定投入一项职业之前，可以先花几个礼拜时间，对该项工作做个全盘认识。通过和从事该行业10年，20年，30年的人士面谈.<br> 1)如果您的生命从头开始，您是否愿意在做一名建筑（XX）师？<br> 2)您仔细打量我后，我想请问您觉得我是否具成为一名成功建筑师的要件？<br> 3)建筑师这一行业是否已经人满为患？<br> 4)如果我学习了4年建筑课程，要找工作是否困难？我应该首先接受哪一类的工作<br> 5)如果我的能力中等，在头5年中，我可以希望赚多少钱<br> 6)当一名建筑师有什么好处和坏处？<br> 7)如果我是您儿子，您建议我当一名建筑师么？<br>(5)要知道每个人都可能在多项事业上成功！<br>2.不要总是为工作和金钱发愁<br> (1)把事实记在纸上<br> (2)拟出一个合适你的预算<br> (3)学习如何聪明地花钱<br> (4)不要为你的收入增加而头痛<br> (5)如果需要借贷，选择银行贷款<br> (6)投保意外保险<br> (7)人寿保险的收益不要一次现金付给受益人<br> (8)教导子女对金钱养成负责任的态度<br> (9)不要赌博-永远不要<br> (10)如果无法改善经济状况，不妨宽恕自己<br>3.处理好夫妻间的职业冲突<br>4.合理开支，不要入不敷出  </p><p>第十篇 远离疲劳，保持活力<br>1.经常休息，在你感到倦怠之前<br>2.说出你的心事<br>3.消除烦闷心理<br>4.不再为失眠忧虑</p>]]></content>
      
      
      <categories>
          
          <category> read </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>science research writing</title>
      <link href="/2023/10/13/read/science%20research%20writing/"/>
      <url>/2023/10/13/read/science%20research%20writing/</url>
      
        <content type="html"><![CDATA[<h1 id="how-to-write-an-introduction"><a href="#how-to-write-an-introduction" class="headerlink" title="how to write an introduction"></a>how to write an introduction</h1><p><del>You may want to start your Introduction by describing the problem you are trying to solve, or the aim of your work</del> . it is not the right way</p><h2 id="grammar-and-writing-skills"><a href="#grammar-and-writing-skills" class="headerlink" title="grammar and writing skills"></a>grammar and writing skills</h2><ul><li>tense pairs 时态（一般现在时✓，现在进行时）一般现在时表肯定</li><li>signalling language <ul><li>sentence connection<ul><li>overlap </li><li>pronoun or pro-form(this method)</li><li>not finish the sentence, join it with semicolon or relative clause (which i.e)</li><li>use signalling sentence connector such as therefore or however<ul><li>cause:  as ,because, since</li><li>result:  therefor, consequently, hence, do not use so(it is informal)</li><li>contrast&#x2F;difference: however, whereas, but</li><li>unexpectedness<ul><li>although, even though, though</li><li>despite, in spite of, regardless of, notwithstanding</li><li>nevertheless, however, yet, nonetheless, even so</li></ul></li><li>addition<ul><li>in addition, moreover, furthermore, apart from that&#x2F;which</li><li>also, secondly, in the second place, what is more</li></ul></li></ul></li></ul></li></ul></li><li>passive active use 主动与被动<ul><li>where referring to we, don’t use I, or it, t is also common to use the passive instead of we, especially in the central ‘report’ section, or use dummy subject to take the place of I or we<ul><li>it is known that (passive mode)</li><li><strong>This article</strong> describes an algorithm for clustering… (omit we)</li></ul></li></ul></li><li>paragraphing 分段<blockquote><p>to find out quickly what it is about and where the various pieces of information are located</p></blockquote></li></ul><h2 id="writing-task-build-a-model"><a href="#writing-task-build-a-model" class="headerlink" title="writing task: build a model"></a>writing task: build a model</h2><p>In Sentence 1 ‘Polylactide (PLA) has received much attention in recent years due to its biodegradable properties, which offer important economic benefits.’ &#x3D;&#x3D;<strong>the writer establishes the importance of this research topic.</strong>&#x3D;&#x3D;</p><blockquote><p>use Present Perfect tense or Present Simple tense</p></blockquote><p>In Sentence 2 ‘PLA is a polymer obtained from corn and is produced by the polymerisation of lactide.’ &#x3D;&#x3D;<strong>the writer provides general background information for the reader.</strong>&#x3D;&#x3D;</p><p>In Sentence 3 ‘PLA has many possible uses in the biomedical field1 and has also been investigated as a potential engineering material 2,3’ the writer does the same as in Sentences 1 and 2, but in a more specific&#x2F;detailed way, &#x3D;&#x3D;using research references to support both the background facts and the claim for significance.&#x3D;&#x3D;</p>]]></content>
      
      
      <categories>
          
          <category> read </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2023/07/05/read/redis/"/>
      <url>/2023/07/05/read/redis/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与对象"><a href="#数据结构与对象" class="headerlink" title="数据结构与对象"></a>数据结构与对象</h1><h2 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span>    </span><br><span class="line"><span class="comment">// 记录buf数组中已使用字节的数量    </span></span><br><span class="line"><span class="comment">// 等于SDS所保存字符串的长度 ，可以O(1)获取字符串长度   </span></span><br><span class="line"><span class="type">int</span> len;    </span><br><span class="line"><span class="comment">// 记录buf数组中未使用字节的数量    </span></span><br><span class="line"><span class="type">int</span> <span class="built_in">free</span>;    </span><br><span class="line"><span class="comment">// 字节数组，用于保存字符串,遵守C语言\0结尾的惯例，因为这样可以复用C语言的字符串部分方法    </span></span><br><span class="line"><span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>len 可以O(1)获取字符串长度</li><li>避免缓冲器溢出</li><li>减少字符串修改带来的内容重新分配</li><li>空间预分配 + 惰性释放</li><li>二进制安全</li><li>兼容部分c函数</li></ul><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span>    </span><br><span class="line"><span class="comment">// 前置节点    </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> * <span class="title">prev</span>;</span>    </span><br><span class="line"><span class="comment">// 后置节点    </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> * <span class="title">next</span>;</span>   </span><br><span class="line"><span class="comment">// 节点的值    </span></span><br><span class="line"><span class="type">void</span> * value;</span><br><span class="line">&#125;listNode;</span><br><span class="line"># 双端链表</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span>    </span><br><span class="line"><span class="comment">// 表头节点    </span></span><br><span class="line">listNode * head;    </span><br><span class="line"><span class="comment">// 表尾节点    </span></span><br><span class="line">listNode * tail;    </span><br><span class="line"><span class="comment">// 链表所包含的节点数量    </span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> len;    </span><br><span class="line"><span class="comment">// 节点值复制函数    </span></span><br><span class="line"><span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);    </span><br><span class="line"><span class="comment">// 节点值释放函数    </span></span><br><span class="line"><span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *ptr);    </span><br><span class="line"><span class="comment">// 节点值对比函数    </span></span><br><span class="line"><span class="type">int</span> (*match)(<span class="type">void</span> *ptr,<span class="type">void</span> *key);</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span>    </span><br><span class="line"><span class="comment">// 哈希表数组   </span></span><br><span class="line">dictEntry **table;    </span><br><span class="line"><span class="comment">// 哈希表大小    </span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> size;    </span><br><span class="line"><span class="comment">//哈希表大小掩码，用于计算索引值    </span></span><br><span class="line"><span class="comment">//总是等于size-1    </span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> sizemask;    </span><br><span class="line"><span class="comment">// 该哈希表已有节点的数量    </span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125; dictht;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span>    </span><br><span class="line"><span class="comment">// 键    </span></span><br><span class="line"><span class="type">void</span> *key;    </span><br><span class="line"><span class="comment">// 值    </span></span><br><span class="line"><span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line"><span class="type">void</span> *val;</span><br><span class="line">uint64_tu64;</span><br><span class="line">int64_ts64;</span><br><span class="line">&#125; v;   </span><br><span class="line"><span class="comment">// 指向下个哈希表节点，形成链表 </span></span><br><span class="line"><span class="comment">//使用的是头插法   </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><h3 id="字典-1"><a href="#字典-1" class="headerlink" title="字典"></a>字典</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line"><span class="comment">// 类型特定函数</span></span><br><span class="line">dictType *type;</span><br><span class="line"><span class="comment">// 私有数据    </span></span><br><span class="line"><span class="type">void</span> *privdata;</span><br><span class="line"><span class="comment">// 哈希表    </span></span><br><span class="line">dictht ht[<span class="number">2</span>];</span><br><span class="line"><span class="comment">// rehash索引    </span></span><br><span class="line"><span class="comment">//当rehash不在进行时，值为-1    </span></span><br><span class="line"><span class="type">int</span> rehashidx;</span><br><span class="line"> <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span>    </span><br><span class="line"><span class="comment">// 计算哈希值的函数    </span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key)</span>;</span><br><span class="line"><span class="comment">// 复制键的函数</span></span><br><span class="line"><span class="type">void</span> *(*keyDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line"><span class="comment">// 复制值的函数    </span></span><br><span class="line"><span class="type">void</span> *(*valDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *obj);    </span><br><span class="line"><span class="comment">// 对比键的函数</span></span><br><span class="line"><span class="type">int</span> (*keyCompare)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key1, <span class="type">const</span> <span class="type">void</span> *key2);    </span><br><span class="line"><span class="comment">// 销毁键的函数</span></span><br><span class="line"><span class="type">void</span> (*keyDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *key);</span><br><span class="line"><span class="comment">// 销毁值的函数</span></span><br><span class="line"><span class="type">void</span> (*valDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure><p><img src="https://i.postimg.cc/Bv8FbGSH/00031.jpg"></p><h3 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h3><ol><li>为ht[1]分配ht[0].used*2的大小(收缩是ht[0].used的大小)</li><li>在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。</li><li>在rehash进行期间，每次只会迁移一小部分数据，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成之后，程序将rehashidx属性的值增一</li><li>随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash至ht[1]，这时程序将rehashidx属性的值设为-1，表示rehash操作已完成。</li></ol><h2 id="跳表skiplist"><a href="#跳表skiplist" class="headerlink" title="跳表skiplist"></a>跳表skiplist</h2><p><img src="https://i.postimg.cc/pdgFn1r7/00048.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span>    </span><br><span class="line"><span class="comment">// 层</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line"><span class="comment">// 前进指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line"><span class="comment">// 跨度</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> span;    </span><br><span class="line">&#125; level[];    </span><br><span class="line"><span class="comment">// 后退指针    </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span>    </span><br><span class="line"><span class="comment">// 分值    </span></span><br><span class="line"><span class="type">double</span> score;    </span><br><span class="line"><span class="comment">// 成员对象    </span></span><br><span class="line">robj *obj;</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//跳表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span>    </span><br><span class="line"><span class="comment">// 表头节点和表尾节点    </span></span><br><span class="line">structz skiplistNode *header, *tail;</span><br><span class="line"><span class="comment">// 表中节点的数量    </span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> length;    </span><br><span class="line"><span class="comment">// 表中层数最大的节点的层数    </span></span><br><span class="line"><span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="层高的确定逻辑"><a href="#层高的确定逻辑" class="headerlink" title="层高的确定逻辑"></a>层高的确定逻辑</h3><p>每次创建一个新跳跃表节点的时候，程序都根据幂次定律（power law，越大的数出现的概率越小）随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的“高度”。<br>具体的做法是，跳表在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于 0.25（相当于概率 25%），那么层数就增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 0.25 结束，最终确定该节点的层数。这样的做法，相当于每增加一层的概率不超过 25%，层数越高，概率越低，层高最大限制是 32（层高不同版本不一样）。</p><h3 id="排序方式"><a href="#排序方式" class="headerlink" title="排序方式"></a>排序方式</h3><p>按score由小到大排序，如果分数一样，则按成员对象在字典序的大小来判断</p><h3 id="跳表的查询过程"><a href="#跳表的查询过程" class="headerlink" title="跳表的查询过程"></a>跳表的查询过程</h3><ol><li><strong>开始节点</strong>：查询从跳表的头部节点（通常是一个特殊的头部节点，不包含实际数据）开始，这个节点有指向不同层的指针。</li><li><strong>水平遍历</strong>：从跳表的最高层开始，向右遍历节点。如果<strong>当前节点的下一个节点</strong>的值小于要查询的值，就继续向右移动。</li><li><strong>下降</strong>：如果当前节点的下一个节点的值大于要查询的值，或者当前节点是该层的最后一个节点（即没有下一个节点），则向下移动到下一层。</li><li><strong>继续搜索</strong>：在下一层，重复进行向右查找和下降的过程，直到到达最底层的链表。</li><li><strong>最底层查找</strong>：在最底层，继续向右查找，直到找到一个值等于查询值的节点，或者找到一个值大于查询值的节点，或者到达链表的末尾。</li><li><strong>返回结果</strong>：<ul><li>如果找到了一个值等于查询值的节点，查询成功，返回该节点或相应的信息。</li><li>如果没有找到，或者找到了一个值大于查询值的节点，说明要查询的值不在跳表中，返回查询失败或null。</li></ul></li></ol><h3 id="跳表的新增过程"><a href="#跳表的新增过程" class="headerlink" title="跳表的新增过程"></a>跳表的新增过程</h3><ol><li><strong>查找插入位置</strong>：首先，从跳表的头部节点开始，向右和向下查找应该插入的位置，直到到达最底层链表。在每一层，如果当前节点的下一个节点的值小于要插入的值，则继续向右移动；如果大于或等于要插入的值，则向下移动到下一层，继续查找。</li><li><strong>更新前驱节点</strong>：在查找过程中，会记录下每一层达到的最后一个节点，这些节点将成为新节点在每一层的前驱节点。</li><li><strong>随机生成层数</strong>：插入新元素时，需要随机生成一个层数，该层数决定了新节点在跳表中的高度。通常，这个过程使用“抛硬币”的方式，即每次随机决定是否增加一层，直到“抛硬币”结果为否或者达到了跳表的最大高度。</li><li><strong>创建新节点</strong>：为新元素创建一个跳表节点，该节点的层数等于随机生成的层数。</li><li><strong>链接节点</strong>：将新节点插入到跳表中，更新步骤 2 中记录的前驱节点的指针，将它们的后继指针指向新节点，同时将新节点的后继指针指向前驱节点原先的后继节点。这一步需要在新节点的所有层上执行。</li><li><strong>更新跳表属性</strong>：如果新节点的层数超过了跳表当前的最大层数，跳表的头部节点和最大层数属性将被更新。</li><li><strong>维护跳表的有序性</strong>：跳表通过以上步骤确保插入后，所有的层都保持有序（从左到右为递增顺序）。</li></ol><h3 id="为什么不实用平衡二叉树"><a href="#为什么不实用平衡二叉树" class="headerlink" title="为什么不实用平衡二叉树"></a>为什么不实用平衡二叉树</h3><p>redis的左右有回答这个问题，大致分下面三点：</p><ol><li>查找性能不比平衡二叉树低</li><li>从内存占用上来比较，跳表比平衡树更灵活一些。平衡树每个节点包含 2 个指针（分别指向左右子树），而跳表每个节点包含的指针数目平均为 1&#x2F;(1-p)，具体取决于参数 p 的大小。如果像 Redis里的实现一样，取 p&#x3D;1&#x2F;4，那么平均每个节点包含 1.33 个指针，比平衡树更有优势。</li><li>实现相对简单</li></ol><h2 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h2><p>各项数据由小到大有序排列并且不会重复<br>新添加的数据如果比之前的数据类型要长，会将encoding换成新的类型，并重新分配内存，但是不会降级</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span>    </span><br><span class="line"><span class="comment">// 编码方式   </span></span><br><span class="line"><span class="type">uint32_t</span> encoding;    </span><br><span class="line"><span class="comment">// 集合包含的元素数量    </span></span><br><span class="line"><span class="type">uint32_t</span> length;    </span><br><span class="line"><span class="comment">// 保存元素的数组    </span></span><br><span class="line"><span class="type">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><p>zlbytes | zltail | zllen | entry1 | entry2 | …. | entryN | zlend</p><ul><li>zlbytes 记录占用的总共字节数</li><li>zltail 记录尾节点距离头结点多少个字节，可以快速定位为节点</li><li>zllen 包含的节点数量，当大于65535时需啊遍历才能得到正确的值</li><li>zlend 0xFF 表结尾标记</li></ul><h3 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h3><p>存放字节数组或整数<br>previous_entry_length | encoding | content </p><ul><li>previous_entry_length前一个节点的长度，用于遍历前一个节点</li><li>encoding 记录节点保存数据的类型及长度</li><li>content 值大小有encoding决定</li></ul><h2 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h2><p>在 Redis 3.0 之前，List 对象的底层数据结构是双向链表或者压缩列表。然后在 Redis 3.2 的时候，List 对象的底层改由 quicklist 数据结构实现。<br>其实 quicklist 就是「双向链表 + 压缩列表」组合，因为一个 quicklist 就是一个链表，而链表中的每个元素又是一个压缩列表。<br>quicklist 解决办法，<strong>通过控制每个链表节点中的压缩列表的大小或者元素个数，来规避连锁更新的问题。因为压缩列表元素越少或越小，连锁更新带来的影响就越小，从而提供了更好的访问性能。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    <span class="comment">//quicklist的链表头</span></span><br><span class="line">    quicklistNode *head;      <span class="comment">//quicklist的链表头</span></span><br><span class="line">    <span class="comment">//quicklist的链表尾</span></span><br><span class="line">    quicklistNode *tail; </span><br><span class="line">    <span class="comment">//所有压缩列表中的总元素个数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> count;</span><br><span class="line">    <span class="comment">//quicklistNodes的个数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;       </span><br><span class="line">    ...</span><br><span class="line">&#125; quicklist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">//前一个quicklistNode</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span>     <span class="comment">//前一个quicklistNode</span></span><br><span class="line">    <span class="comment">//下一个quicklistNode</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span>     <span class="comment">//后一个quicklistNode</span></span><br><span class="line">    <span class="comment">//quicklistNode指向的压缩列表</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zl;              </span><br><span class="line">    <span class="comment">//压缩列表的的字节大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz;                </span><br><span class="line">    <span class="comment">//压缩列表的元素个数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count : <span class="number">16</span>;        <span class="comment">//ziplist中的元素个数 </span></span><br><span class="line">    ....</span><br><span class="line">&#125; quicklistNode;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.xiaolincoding.com//mysql/other/f46cbe347f65ded522f1cc3fd8dba549.png"></p><h2 id="listpack"><a href="#listpack" class="headerlink" title="listpack"></a>listpack</h2><p><img src="https://cdn.xiaolincoding.com//mysql/other/c5fb0a602d4caaca37ff0357f05b0abf.png"><br>可以看到，<strong>listpack 没有压缩列表中记录前一个节点长度的字段了，listpack 只记录当前节点的长度，当我们向 listpack 加入一个新元素的时候，不会影响其他节点的长度字段的变化，从而避免了压缩列表的连锁更新问题</strong>。</p><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>redis并没有直接使用数据结构，而是整合成字符串对象，列表对象，哈希对象，集合对象，有序集合对象，每个对象至少使用一个数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span>    </span><br><span class="line"><span class="comment">// 类型 </span></span><br><span class="line"><span class="comment">//REDIS_STRING, REDIS_LIST, REDIS_HASH, REDIS_SET, REDIS_ZSET   </span></span><br><span class="line"><span class="type">unsigned</span> type:<span class="number">4</span>;    </span><br><span class="line"><span class="comment">// 编码 </span></span><br><span class="line"><span class="comment">//REDIS_ENCODING_INT,</span></span><br><span class="line"><span class="comment">//REDIS_ENCODING_EMBSTR  字符串的建值放在一起 只需分配一次内存和一次回收</span></span><br><span class="line"><span class="comment">//REDIS_ENCODING_RAW 字符串的建值分开一起</span></span><br><span class="line"><span class="comment">//REDIS_ENCODING_HT</span></span><br><span class="line"><span class="comment">//REDIS_ENCODING_LINKEDLIST</span></span><br><span class="line"><span class="comment">//REDIS_ENCODING_ZIPLIST</span></span><br><span class="line"><span class="comment">//REDIS_ENCODING_INTSET</span></span><br><span class="line"><span class="comment">//REDIS_ENCODING_SKIPLIST  </span></span><br><span class="line"><span class="type">unsigned</span> encoding:<span class="number">4</span>;    </span><br><span class="line"><span class="comment">// 指向底层实现数据结构的指针    </span></span><br><span class="line"><span class="type">void</span> *ptr;</span><br><span class="line"><span class="comment">//引用计数，用于垃圾回收</span></span><br><span class="line"><span class="type">int</span> refcount;</span><br><span class="line"><span class="comment">//上次被访问的时间，用于当内存不足的回收策略为volatile-lru,allkeys-lru</span></span><br><span class="line"><span class="type">unsigned</span> lru;    </span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><h3 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h3><h3 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h3><ul><li>ziplist (所有列表保存的字符串长度小于64 || 列表数量小于512)</li><li>linkedlist</li></ul><h3 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h3><ul><li>ziplist （同上64， 512）</li><li>hashtable</li></ul><h3 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h3><ul><li>intset（都是整数，不超过512）</li><li>hashtable</li></ul><h3 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h3><ul><li>ziplist （数据按大小顺序存放） (同上64， 128)</li><li>skiplist +dict<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span>    </span><br><span class="line">zskiplist *zsl;    </span><br><span class="line">dict *dict;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure><img src="https://i.postimg.cc/NFNGR5bM/Pasted-image-20240304201050.png"></li></ul><h3 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h3><p>redis在初始化时会创建0-9999共1w个整型，用来做复用</p><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line"><span class="comment">//数据库的数量，默认16</span></span><br><span class="line"><span class="type">int</span> dbNum;</span><br><span class="line"><span class="comment">//数据库数组指针</span></span><br><span class="line">redisDb *db</span><br><span class="line"><span class="comment">//距离上一次rdb的修改数量</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dirty</span><br><span class="line"><span class="comment">//上一次rdb的时间</span></span><br><span class="line"><span class="type">time_t</span> last_save</span><br><span class="line"><span class="comment">//链表，保存所有客户端状态</span></span><br><span class="line">lists *clients</span><br><span class="line">redisClien *lua_client</span><br><span class="line"><span class="comment">//从服务器对应的主服务器配置</span></span><br><span class="line"><span class="type">char</span> *masterhost;</span><br><span class="line"><span class="type">int</span> masterport</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端数据库</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span>&#123;</span></span><br><span class="line"><span class="comment">//记录当前客户端使用的数据库</span></span><br><span class="line">redisDb *db</span><br><span class="line"><span class="comment">//-1或者大于-1的整数，aof使用的伪客户端为-1</span></span><br><span class="line"><span class="type">int</span> fd</span><br><span class="line"><span class="comment">//客户端所处的状态 REDIS_MASTER REDIS_SLAVE REDIS_PRE_PSYCN PSYNC REDIS_LUA_CLIENT </span></span><br><span class="line"><span class="comment">//REDIS_MONITOR REDIS_MONITOR_SOCK REDIS_BLOCKED REDIS_UNBLOCKED</span></span><br><span class="line"><span class="comment">//REDIS_MULTI...</span></span><br><span class="line"><span class="type">int</span> flags</span><br><span class="line"><span class="comment">//输入缓冲区，保存客户端发送的命令</span></span><br><span class="line"><span class="comment">//输入参数</span></span><br><span class="line">robj *argsv</span><br><span class="line"><span class="type">int</span> argc</span><br><span class="line">sds querybuf</span><br><span class="line"><span class="comment">//当前执行的命令指向</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span></span></span><br><span class="line"><span class="class">//固定大小的输出的缓冲区，存放输出量较小的内容，当<span class="title">buf</span>放不下时，放出可变大小缓冲区</span></span><br><span class="line"><span class="class">//固定大小的输出缓冲区</span></span><br><span class="line"><span class="class"><span class="title">char</span> <span class="title">buf</span>[<span class="title">REIDS_REPLY_CHUNK_BYTES</span>]</span></span><br><span class="line"><span class="class">//<span class="title">buf</span>已使用的字节数量</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">bufpos</span></span></span><br><span class="line"><span class="class">//可变大小的输出缓冲区,由一个或多个字符串对象组成</span></span><br><span class="line"><span class="class"><span class="title">list</span> *<span class="title">reply</span></span></span><br><span class="line"><span class="class">//身份验证 0未通过 1已通过</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">authenticated</span></span></span><br><span class="line"><span class="class"><span class="title">time_</span> <span class="title">ctime</span></span></span><br><span class="line"><span class="class"><span class="title">time_t</span> <span class="title">lastinteraction</span></span></span><br><span class="line"><span class="class">//输出缓冲区第一次打到软性限制的时间</span></span><br><span class="line"><span class="class"><span class="title">time_t</span> <span class="title">obuf_soft_limit_reached_time</span></span></span><br><span class="line"><span class="class">//从服务器监听的端口号</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">slave_listening_port</span></span></span><br><span class="line"><span class="class">&#125;<span class="title">redisClient</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span>&#123;</span></span><br><span class="line"><span class="comment">//数据库键空间，保存所有的键值对</span></span><br><span class="line">dict *dict</span><br><span class="line"><span class="comment">//存放带有过期时间的键与过期时间</span></span><br><span class="line">dict *expires</span><br><span class="line">&#125; redisDb</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h3><ul><li><del>定时删除</del>  （创建Timer代价高，未被使用）</li><li>定期删除 （定期从expires的数据库中随机选出一批检查）</li><li>惰性删除 （读写前检查）</li></ul><h3 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h3><ol><li><strong>noeviction</strong>: 不进行数据淘汰。一旦达到内存限制，Redis会返回错误给写命令。适用于内存不做限制的情况，或者数据量不会超出内存限制。</li><li><strong>allkeys-lru</strong>: 当内存不足以容纳新写入数据时，在键空间中，使用最近最少使用（LRU）算法移除最少使用的键。这是默认策略，适用于大多数场景。</li><li><strong>volatile-lru</strong>: 从已设置过期时间的键集合中，使用LRU算法淘汰最少使用的键。如果没有可淘汰的键，会返回错误。</li><li><strong>allkeys-random</strong>: 当内存不足时，随机淘汰键，不管其使用频率如何。</li><li><strong>volatile-random</strong>: 从所有设置了过期时间的键中随机选择键进行淘汰。</li><li><strong>volatile-ttl</strong>: 从设置了过期时间的键中选择存活时间（TTL）最短的键进行淘汰。</li><li><strong>volatile-lfu</strong>: 从设置了过期时间的键中，使用最不经常使用（LFU）算法淘汰数据。（redis 4.0后加）</li><li><strong>allkeys-lfu</strong>: 从所有键中，使用LFU算法淘汰最不经常使用的键。（redis 4.0后加）</li></ol><h4 id="过期建的rdb-与aof"><a href="#过期建的rdb-与aof" class="headerlink" title="过期建的rdb 与aof"></a>过期建的rdb 与aof</h4><ul><li>rdb在dump的时候会过滤过期的建，在导入的时候如果以主服务器运行会忽略过期的键，以从服务器过期的也会导入</li><li>在键因过期被删除时，会写aof，aof重写时会忽略过期的键</li><li>主服务器的建过期时，会向从服务器发del，从服务器当有读写命令时，如果该键已经失效了也不会操作删除，而是等到主服务器的del命令， 这样保证了主从的一致性</li></ul><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><h4 id="rdb"><a href="#rdb" class="headerlink" title="rdb"></a>rdb</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 900s内有1次改动</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><p>save，bgsave生成二进制文件</p><h5 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h5><p>REDIS|db_version|databases|EOF|check_sum<br>databases部分<br>REDIS|db_version|database 0|database 3|EOF|check_sum<br>SELECTDB|db_number|key_values_pars</p><h4 id="aof"><a href="#aof" class="headerlink" title="aof"></a>aof</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 是否开启</span><br><span class="line">appendonly yes</span><br><span class="line"># 刷盘时机 always, everysec (default), no</span><br><span class="line">appendfsync always</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>aof重写：防止aof过大<br>aof重写缓冲区保证数据一致</p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><h4 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h4><p>基于reactor模式的网络事件处理器（file event handler）</p><h4 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h4><ul><li>定时事件</li><li>周期性事件</li></ul><h1 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h1><h2 id="serverCron函数"><a href="#serverCron函数" class="headerlink" title="serverCron函数"></a>serverCron函数</h2><p>每100ms执行的定时任务，用于维护server的各种数据</p><h1 id="多机数据库实现"><a href="#多机数据库实现" class="headerlink" title="多机数据库实现"></a>多机数据库实现</h1><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><blockquote><p>主从复制 slaveof ip port<br>复制过程分为 同步 + 命令传播两个过程</p></blockquote><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>当执行slaveof命令，要求从服务器复制主服务器，从服务器需要执行同步操作，即sync命令，新版2.8及以后使用的是PSYNC，执行步骤是</p><ol><li>从服务器向主服务器发送sync命令</li><li>主服务器收到sync命令后执行bgsave，生成rdb文件，并使用一个缓冲区记录从当前开始所以的写命令</li><li>主服务器将rdb文件发送给从服务器，从服务器载入数据</li><li>主服务器将缓冲区数据发送给从服务器，从服务器更新导最新状态<br>后续的写操作通过命令传播给从服务器</li></ol><h3 id="PSYNC"><a href="#PSYNC" class="headerlink" title="PSYNC"></a>PSYNC</h3><blockquote><p>PSYNC解决了从服务器断开链接后，再次与主服务器链接需要dump rdb造成的资源浪费</p></blockquote><p>主要由三个部分构成</p><ol><li>主服务器的复制偏离量和从服务器的复制偏移量</li><li>主服务器的复制积压缓冲区（默认为1M，如果从服务器的偏移量已经不再缓冲区中，则需要执行rdb的dump操作）</li><li>服务器的运行Id（run ID）<br>使用到的命令<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//首次复制</span><br><span class="line">PSYNC ? -1</span><br><span class="line">//首次响应</span><br><span class="line">+FULLRESYNC RUNID OFFSET</span><br><span class="line">//非首次</span><br><span class="line">PAYNC RUNID OFFSET</span><br><span class="line">//非首次响应</span><br><span class="line">+CONTINUE ?</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h2 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h2><h2 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h2><h3 id="心跳检测（2-8版本后新增）"><a href="#心跳检测（2-8版本后新增）" class="headerlink" title="心跳检测（2.8版本后新增）"></a>心跳检测（2.8版本后新增）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPLCONF ACK &lt;replication_offset&gt;</span><br></pre></td></tr></table></figure><ul><li>检测服务器的网络连接状态（从服务器每秒向主服务器发送）</li><li>辅助实现min-slaves</li><li>检测命令丢失</li></ul><h2 id="sentinel"><a href="#sentinel" class="headerlink" title="sentinel"></a>sentinel</h2><blockquote><p>由一个或多个Sentinel实例（instance）组成的Sentinel系统（system）可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。</p></blockquote><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel /path/to/sentinel.conf</span><br><span class="line">//or</span><br><span class="line"></span><br><span class="line">redis-server /path/to/sentinal.conf --sentinel</span><br></pre></td></tr></table></figure><h3 id="重新选主流程"><a href="#重新选主流程" class="headerlink" title="重新选主流程"></a>重新选主流程</h3><p>当Redis Sentinel集群中的主服务器发生故障或不可用时，Sentinel会自动进行重新选举，并将一个从服务器提升为新的主服务器。以下是Redis Sentinel重新选主的流程：</p><ol><li>Sentinel检测到主服务器不可用：每个Sentinel节点都会定期对主服务器进行健康检查（PING）。如果某个Sentinel节点检测到主服务器不可用，它会将这个信息广播给其他Sentinel节点。</li><li>Sentinel节点达成共识：当多个Sentinel节点检测到主服务器不可用时，它们会通过共识算法达成一致，确定主服务器已下线。</li><li>选择新的主服务器：一旦达成共识，Sentinel节点会从当前可用的从服务器中选择一个来提升为新的主服务器。选择的依据通常是当前从服务器的复制偏移量（replication offset）最大的那个。</li><li>进行故障转移：被选中的从服务器会被设置为新的主服务器，并重新配置其他从服务器以复制新的主服务器。同时，Sentinel节点会更新哨兵集群的配置，将新的主服务器信息广播给其他Sentinel节点和客户端。</li><li>客户端重新连接：一旦故障转移完成，客户端需要重新连接到新的主服务器，并且进行相应的配置更新。</li></ol><p>需要注意的是，Redis Sentinel重新选主的过程是自动进行的，无需手动干预。同时，Redis Sentinel集群的配置项也会影响重新选主的过程，例如<code>sentinel down-after-milliseconds</code>和<code>sentinel failover-timeout</code>等参数会影响Sentinel节点判断主服务器是否下线以及进行故障转移的时间。因此，在配置Sentinel集群时，需要根据实际需求进行适当的参数配置。</p><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><blockquote><p>分布式数据库方案，集群通过分片（sharding）来进行数据共享，并提供复制和故障转移功能</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#conf</span></span><br><span class="line">cluster-enabled yes <span class="comment">//将该节点设为集群节点</span></span><br><span class="line"># 命令</span><br><span class="line"># 节点间相互链接</span><br><span class="line">CLUSTER MEET &lt;IP&gt; &lt;PORT&gt;</span><br><span class="line"></span><br><span class="line"># 每个节点使用clusterNode结构来记录自己的状态</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span>  </span><br><span class="line"><span class="comment">// 创建节点的时间  </span></span><br><span class="line"><span class="type">mstime_t</span> ctime;  </span><br><span class="line"><span class="comment">// 节点的名字，由40个十六进制字符组成  </span></span><br><span class="line"><span class="comment">// 例如68eef66df23420a5862208ef5b1a7005b806f2ff  </span></span><br><span class="line"><span class="type">char</span> name[REDIS_CLUSTER_NAMELEN];  </span><br><span class="line"><span class="comment">// 节点标识  </span></span><br><span class="line"><span class="comment">// 使用各种不同的标识值记录节点的角色（比如主节点或者从节点），  </span></span><br><span class="line"><span class="comment">// 以及节点目前所处的状态（比如在线或者下线）。  </span></span><br><span class="line"><span class="type">int</span> flags; </span><br><span class="line"><span class="comment">// 节点当前的配置纪元，用于实现故障转移  </span></span><br><span class="line"><span class="type">uint64_t</span> configEpoch;  </span><br><span class="line"><span class="comment">// 节点的IP地址  </span></span><br><span class="line"><span class="type">char</span> ip[REDIS_IP_STR_LEN];  </span><br><span class="line"><span class="comment">// 节点的端口号  </span></span><br><span class="line"><span class="type">int</span> port;  </span><br><span class="line"><span class="comment">// 保存连接节点所需的有关信息  </span></span><br><span class="line"><span class="comment">//该结构保存了连接节点所需的有关信息，比如套接字描述符，输入缓冲区和输出缓冲区</span></span><br><span class="line">clusterLink *link;  </span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span>  </span><br><span class="line"><span class="comment">// 指向当前节点的指针  </span></span><br><span class="line">clusterNode *myself;  </span><br><span class="line"><span class="comment">// 集群当前的配置纪元，用于实现故障转移 </span></span><br><span class="line"><span class="type">uint64_t</span> currentEpoch;  </span><br><span class="line"><span class="comment">// 集群当前的状态：是在线还是下线  </span></span><br><span class="line"><span class="type">int</span> state;  </span><br><span class="line"><span class="comment">// 集群中至少处理着一个槽的节点的数量  </span></span><br><span class="line"><span class="type">int</span> size;  </span><br><span class="line"><span class="comment">// 集群节点名单（包括myself节点）与其他节点信息 </span></span><br><span class="line"><span class="comment">// 字典的键为节点的名字，字典的值为节点对应的clusterNode结构  </span></span><br><span class="line">dict *nodes;  </span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125; clusterState;</span><br></pre></td></tr></table></figure><h3 id="cluster-meet命令实现"><a href="#cluster-meet命令实现" class="headerlink" title="cluster meet命令实现"></a>cluster meet命令实现</h3><p>以A将B加入为例</p><ol><li>节点A会为节点B创建一个clusterNode结构，并将该结构添加到自己的clusterState.nodes字典里面。</li><li>之后，节点A将根据CLUSTER MEET命令给定的IP地址和端口号，向节点B发送一条MEET消息（message）。</li><li>如果一切顺利，节点B将接收到节点A发送的MEET消息，节点B会为节点A创建一个clusterNode结构，并将该结构添加到自己的clusterState.nodes字典里面。</li><li>之后，节点B将向节点A返回一条PONG消息。</li><li>如果一切顺利，节点A将接收到节点B返回的PONG消息，通过这条PONG消息节点A可以知道节点B已经成功地接收到了自己发送的MEET消息。</li><li>之后，节点A将向节点B返回一条PING消息。</li><li>如果一切顺利，节点B将接收到节点A返回的PING消息，通过这条PING消息节点B可以知道节点A已经成功地接收到了自己返回的PONG消息，握手完成。</li></ol><h3 id="槽指派"><a href="#槽指派" class="headerlink" title="槽指派"></a>槽指派</h3><blockquote><p>集群的整个数据库分为16384个槽</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">cluster addslots &lt;slot&gt; [slot ...]</span><br><span class="line"><span class="comment">//将0到5000分给7000节点负责</span></span><br><span class="line"><span class="comment">//登录到7000节点</span></span><br><span class="line">cluster addslots <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> ... <span class="number">5000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//记录槽指派的信息，在clusterNode结构的slots属性和numslot熟悉记录节点负责处理哪些槽</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line"><span class="comment">//二进制数组，如果对应的1就表示在该节点</span></span><br><span class="line"><span class="comment">//即使有clusterState.clusterNode，slots熟悉仍有必要，因为</span></span><br><span class="line"><span class="comment">//1.直接将该数组发送出去就可以告诉别人当前节点的槽信息</span></span><br><span class="line"><span class="comment">//2. 且不需要先遍历一遍clusterState.clusterNode</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> slots[<span class="number">16384</span>/<span class="number">8</span>]</span><br><span class="line"><span class="comment">//处理的槽的数量</span></span><br><span class="line"><span class="type">int</span> numslots</span><br><span class="line"><span class="comment">//如果是从节点，指向主节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> *<span class="title">slaveof</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class">//记录槽指向的集群节点</span></span><br><span class="line"><span class="class"><span class="title">typedef</span> <span class="keyword">struct</span> <span class="title">clusterState</span>&#123;</span></span><br><span class="line">clusterNode *slots[<span class="number">16384</span>];</span><br><span class="line"><span class="comment">//跳表里记录的是key和slot的对应关系，这样可以根据槽号获取对应的建</span></span><br><span class="line"> zskiplist *slots_to_keys;</span><br><span class="line"> <span class="comment">//正准备迁移至</span></span><br><span class="line"> clusterNode *migrating_slots_to[<span class="number">16384</span>]</span><br><span class="line"> <span class="comment">//准备从哪个节点导入</span></span><br><span class="line"> clusterNode *importing_slots_from[<span class="number">16384</span>]</span><br><span class="line">&#125; clusterState</span><br></pre></td></tr></table></figure><p>如果请求的key不在当前节点，则返回moved错误给客户端</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算属于哪个槽</span></span><br><span class="line">def <span class="title function_">slot_number</span><span class="params">(key)</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">crc</span><span class="params">(key)</span> &amp; 16383</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以使用下面命令查看在那个槽</span></span><br><span class="line">cluster keyslot &quot;data&quot;</span><br></pre></td></tr></table></figure><h3 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.redis-trib对目标节点发送CLUSTER SETSLOT &lt;slot&gt; IMPORTING&lt;source_id&gt;命令，让目标节点准备好从源节点导入（import）属于槽slot的键值对。</span><br><span class="line">2. redis-trib对源节点发送CLUSTER SETSLOT&lt;slot&gt;MIGRATING&lt;target_id&gt;命令，让源节点准备好将属于槽slot的键值对迁移（migrate）至目标节点。</span><br><span class="line">3. redis-trib向源节点发送CLUSTER GETKEYSINSLOT&lt;slot&gt;&lt;count&gt;命令，获得最多count个属于槽slot的键值对的键名（key name）。</span><br><span class="line">4. 对于步骤3获得的每个键名，redis-trib都向源节点发送一个MIGRATE&lt;target_ip&gt;&lt;target_port&gt;&lt;key_name&gt;0&lt;timeout&gt;命令，将被选中的键原子地从源节点迁移至目标节点。</span><br><span class="line">5. 重复执行步骤3和步骤4，直到源节点保存的所有属于槽slot的键值对都被迁移至目标节点为止。每次迁移键的过程如图17-24所示。</span><br><span class="line">6. redis-trib向集群中的任意一个节点发送CLUSTER SETSLOT&lt;slot&gt;NODE&lt;target_id&gt;命令，将槽slot指派给目标节点，这一指派信息会通过消息发送至整个集群，最终集群中的所有节点都会知道槽slot已经指派给了目标节点。</span><br></pre></td></tr></table></figure><h3 id="ASK错误"><a href="#ASK错误" class="headerlink" title="ASK错误"></a>ASK错误</h3><p>在迁移的过程中，如果节点在当前节点则直接返回，如果已迁移至新节点，则返回ASK错误，导向目标节点</p><h2 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h2><blockquote><p>MULTI,EXEC,WATCH</p></blockquote><ul><li>发送multi后的语句并不会立即执行，命令会放入到队列中，当遇到EXEC,DISCARD,WATCH,MULTI时才会执行</li><li>如果是命令格式的错误，事务类的语句都不会执行，如果是操作过程才能发现的错误，redis会执行，且不会回滚</li></ul><h2 id="lua脚本"><a href="#lua脚本" class="headerlink" title="lua脚本"></a>lua脚本</h2><blockquote><p>Redis从2.6版本开始引入对Lua脚本的支持，通过在服务器中嵌入Lua环境，Redis客户端可以使用Lua脚本，直接在服务器端原子地执行多个Redis命令</p></blockquote><h3 id="通过伪客户端执行"><a href="#通过伪客户端执行" class="headerlink" title="通过伪客户端执行"></a>通过伪客户端执行</h3><p>注意在集群中多个key可能分布在不同的节点，即原子性不能保证</p><h1 id="缓存相关"><a href="#缓存相关" class="headerlink" title="缓存相关"></a>缓存相关</h1><p>[[缓存]]</p><h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%9845%E8%AE%B2-%E5%AE%8C/11%20%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E5%AE%9E%E7%8E%B0%EF%BC%9F.md">参考链接</a></p><h2 id="常见的解决方案"><a href="#常见的解决方案" class="headerlink" title="常见的解决方案"></a>常见的解决方案</h2><h3 id="数据库-1"><a href="#数据库-1" class="headerlink" title="数据库"></a>数据库</h3><blockquote><p>基于数据库的主键不能重复，往数据库中插入数据，如果插入成功则抢到了锁</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `methodLock` ( </span><br><span class="line">`id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">`method_name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;锁定的方法或者资源&#x27;</span>, </span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`), </span><br><span class="line"><span class="keyword">UNIQUE</span> KEY `uidx_method_name` (`method_name `) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;对方法加锁&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> methodLock(method_name) <span class="keyword">values</span> (<span class="string">&#x27;method_name&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h4><ul><li>单点故障</li><li>超时无法失效</li><li>不可重入</li><li>无法实现阻塞</li></ul><h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><p><code>SET key value expireTime nx</code></p><h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><ol><li>锁超时被其他进程释放：通过lua脚本进行值对比释放</li><li>集群下可能出现多进程都获得锁（发生了故障转移）：Redlock</li></ol><h4 id="RedLock算法流程"><a href="#RedLock算法流程" class="headerlink" title="RedLock算法流程"></a>RedLock算法流程</h4><blockquote><p><strong>Redlock 算法</strong>是在单 Redis 节点基础上引入的<strong>高可用模式</strong>，Redlock 基于 N 个完全独立的 Redis 节点，一般是<strong>大于 3 的奇数个</strong>（通常情况下 N 可以设置为 5），可以基本保证集群内各个节点不会同时宕机。</p></blockquote><h5 id="加锁过程"><a href="#加锁过程" class="headerlink" title="加锁过程"></a>加锁过程</h5><ul><li>1、客户端获取当前时间，以毫秒为单位。</li><li>2、客户端尝试获取 N 个节点的锁，（每个节点获取锁的方式和前面说的缓存锁一样），N 个节点以相同的 key 和 value 获取锁。客户端需要设置接口访问超时，接口超时时间需要远远小于锁超时时间，比如锁自动释放的时间是 10s，那么接口超时大概设置 5-50ms。这样可以在有 redis 节点宕机后，访问该节点时能尽快超时，而减小锁的正常使用。</li><li>3、客户端计算在获得锁的时候花费了多少时间，方法是用当前时间减去在步骤一获取的时间，只有客户端获得了超过 N&#x2F;2 +1 个节点的锁，而且获取锁的时间小于锁的超时时间，客户端才获得了分布式锁。</li><li>4、客户端获取的锁的时间为设置的锁超时时间减去步骤三计算出的获取锁花费时间。</li><li>5、如果客户端获取锁失败了，客户端会依次删除所有的锁。 使用 Redlock 算法，可以保证在挂掉最多 2 个节点的时候，分布式锁服务仍然能工作，这相比之前的数据库锁和缓存锁大大提高了可用性，由于 redis 的高效性能，分布式缓存锁性能并不比数据库锁差。</li></ul><h3 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h3><p>ZooKeeper 有四种节点类型，包括持久节点、持久顺序节点、临时节点和<code>临时顺序节点</code>，利用 ZooKeeper 支持临时顺序节点的特性，可以实现分布式锁<br>当客户端对某个方法加锁时，在 ZooKeeper 中该方法对应的指定节点目录下，生成一个唯一的临时有序节点；<br>判断是否获取锁，只需要判断持有的节点是否是有序节点中序号最小的一个，是则加锁成功，否则watch 序号比本身小的前一个节点 (公平锁)；当释放锁的时候，将这个临时节点删除即可，这种方式可以避免服务宕机导致的锁无法释放而产生的死锁问题。<br><img src="https://i.postimg.cc/xdHdBjjx/Pasted-image-20240201110044.png"></p><h4 id="加锁过程-1"><a href="#加锁过程-1" class="headerlink" title="加锁过程"></a>加锁过程</h4><ol><li>连接zookeeper，创建顺序临时节点</li><li>判断当前节点的值是否是该节点下的最小值，如果是则说明拿到了锁，否则通过watch事件监听节点的变更信息，重复判断过程直到获取到锁</li><li>执行完后，删除对应的子节点，释放分布式锁</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>性能没有缓存服务器好</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 八股 </tag>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
