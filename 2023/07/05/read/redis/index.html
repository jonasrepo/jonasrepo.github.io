<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="数据结构与对象SDS123456789struct sdshdr &#123;    	&#x2F;&#x2F; 记录buf数组中已使用字节的数量    	&#x2F;&#x2F; 等于SDS所保存字符串的长度 ，可以O(1)获取字符串长度   	int len;    	&#x2F;&#x2F; 记录buf数组中未使用字节的数量    	int free;    	&#x2F;&#x2F; 字节数组，用于保存字符串,遵守C语言\0结尾的惯例，因为这样可以复用C语言的字符串部">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis">
<meta property="og:url" content="http://localhost:4000/2023/07/05/read/redis/index.html">
<meta property="og:site_name" content="Jonas">
<meta property="og:description" content="数据结构与对象SDS123456789struct sdshdr &#123;    	&#x2F;&#x2F; 记录buf数组中已使用字节的数量    	&#x2F;&#x2F; 等于SDS所保存字符串的长度 ，可以O(1)获取字符串长度   	int len;    	&#x2F;&#x2F; 记录buf数组中未使用字节的数量    	int free;    	&#x2F;&#x2F; 字节数组，用于保存字符串,遵守C语言\0结尾的惯例，因为这样可以复用C语言的字符串部">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.postimg.cc/Bv8FbGSH/00031.jpg">
<meta property="og:image" content="https://i.postimg.cc/pdgFn1r7/00048.jpg">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/f46cbe347f65ded522f1cc3fd8dba549.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/c5fb0a602d4caaca37ff0357f05b0abf.png">
<meta property="og:image" content="https://i.postimg.cc/NFNGR5bM/Pasted-image-20240304201050.png">
<meta property="og:image" content="https://i.postimg.cc/xdHdBjjx/Pasted-image-20240201110044.png">
<meta property="article:published_time" content="2023-07-05T07:07:16.756Z">
<meta property="article:modified_time" content="2024-05-21T07:13:43.207Z">
<meta property="article:author" content="jonas">
<meta property="article:tag" content="八股">
<meta property="article:tag" content="Redis">
<meta property="article:tag" content="缓存">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.postimg.cc/Bv8FbGSH/00031.jpg">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>Redis</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<meta name="generator" content="Hexo 7.1.1"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/categories/">Category</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a href="/search">Search</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/jonasrepo.github.io">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2023/10/13/read/science%20research%20writing/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://localhost:4000/2023/07/05/read/redis/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://localhost:4000/2023/07/05/read/redis/&text=Redis"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://localhost:4000/2023/07/05/read/redis/&title=Redis"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://localhost:4000/2023/07/05/read/redis/&is_video=false&description=Redis"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Redis&body=Check out this article: http://localhost:4000/2023/07/05/read/redis/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://localhost:4000/2023/07/05/read/redis/&title=Redis"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://localhost:4000/2023/07/05/read/redis/&title=Redis"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://localhost:4000/2023/07/05/read/redis/&title=Redis"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://localhost:4000/2023/07/05/read/redis/&title=Redis"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://localhost:4000/2023/07/05/read/redis/&name=Redis&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://localhost:4000/2023/07/05/read/redis/&t=Redis"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.</span> <span class="toc-text">数据结构与对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SDS"><span class="toc-number">1.1.</span> <span class="toc-text">SDS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">1.1.1.</span> <span class="toc-text">优点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.</span> <span class="toc-text">链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E5%85%B8"><span class="toc-number">1.3.</span> <span class="toc-text">字典</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">哈希表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E5%85%B8-1"><span class="toc-number">1.3.2.</span> <span class="toc-text">字典</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%90%E8%BF%9B%E5%BC%8Frehash"><span class="toc-number">1.3.3.</span> <span class="toc-text">渐进式rehash</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%B3%E8%A1%A8skiplist"><span class="toc-number">1.4.</span> <span class="toc-text">跳表skiplist</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E9%AB%98%E7%9A%84%E7%A1%AE%E5%AE%9A%E9%80%BB%E8%BE%91"><span class="toc-number">1.4.1.</span> <span class="toc-text">层高的确定逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.2.</span> <span class="toc-text">排序方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%A1%A8%E7%9A%84%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">1.4.3.</span> <span class="toc-text">跳表的查询过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%A1%A8%E7%9A%84%E6%96%B0%E5%A2%9E%E8%BF%87%E7%A8%8B"><span class="toc-number">1.4.4.</span> <span class="toc-text">跳表的新增过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%AE%9E%E7%94%A8%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.4.5.</span> <span class="toc-text">为什么不实用平衡二叉树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88"><span class="toc-number">1.5.</span> <span class="toc-text">整数集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8"><span class="toc-number">1.6.</span> <span class="toc-text">压缩列表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#entry"><span class="toc-number">1.6.1.</span> <span class="toc-text">entry</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#quicklist"><span class="toc-number">1.7.</span> <span class="toc-text">quicklist</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#listpack"><span class="toc-number">1.8.</span> <span class="toc-text">listpack</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.</span> <span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.0.1.</span> <span class="toc-text">字符串对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.0.2.</span> <span class="toc-text">列表对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.0.3.</span> <span class="toc-text">哈希对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.0.4.</span> <span class="toc-text">集合对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.0.5.</span> <span class="toc-text">有序集合对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%85%B1%E4%BA%AB"><span class="toc-number">2.0.6.</span> <span class="toc-text">对象共享</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">3.</span> <span class="toc-text">数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="toc-number">3.0.1.</span> <span class="toc-text">过期删除策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">3.0.2.</span> <span class="toc-text">内存淘汰策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E5%BB%BA%E7%9A%84rdb-%E4%B8%8Eaof"><span class="toc-number">3.0.2.1.</span> <span class="toc-text">过期建的rdb 与aof</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">3.0.3.</span> <span class="toc-text">持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rdb"><span class="toc-number">3.0.3.1.</span> <span class="toc-text">rdb</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.0.3.1.1.</span> <span class="toc-text">文件格式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#aof"><span class="toc-number">3.0.3.2.</span> <span class="toc-text">aof</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6"><span class="toc-number">3.0.4.</span> <span class="toc-text">事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%BA%8B%E4%BB%B6"><span class="toc-number">3.0.4.1.</span> <span class="toc-text">文件事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E4%BA%8B%E4%BB%B6"><span class="toc-number">3.0.4.2.</span> <span class="toc-text">时间事件</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">4.</span> <span class="toc-text">服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#serverCron%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.</span> <span class="toc-text">serverCron函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.</span> <span class="toc-text">多机数据库实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6"><span class="toc-number">5.1.</span> <span class="toc-text">复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5"><span class="toc-number">5.2.</span> <span class="toc-text">同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PSYNC"><span class="toc-number">5.2.1.</span> <span class="toc-text">PSYNC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E4%BC%A0%E6%92%AD"><span class="toc-number">5.3.</span> <span class="toc-text">命令传播</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E"><span class="toc-number">5.4.</span> <span class="toc-text">主从</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B%EF%BC%882-8%E7%89%88%E6%9C%AC%E5%90%8E%E6%96%B0%E5%A2%9E%EF%BC%89"><span class="toc-number">5.4.1.</span> <span class="toc-text">心跳检测（2.8版本后新增）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sentinel"><span class="toc-number">5.5.</span> <span class="toc-text">sentinel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8"><span class="toc-number">5.5.1.</span> <span class="toc-text">启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E9%80%89%E4%B8%BB%E6%B5%81%E7%A8%8B"><span class="toc-number">5.5.2.</span> <span class="toc-text">重新选主流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4"><span class="toc-number">5.6.</span> <span class="toc-text">集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cluster-meet%E5%91%BD%E4%BB%A4%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.6.1.</span> <span class="toc-text">cluster meet命令实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A7%BD%E6%8C%87%E6%B4%BE"><span class="toc-number">5.6.2.</span> <span class="toc-text">槽指派</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E5%88%86%E7%89%87"><span class="toc-number">5.6.3.</span> <span class="toc-text">重新分片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ASK%E9%94%99%E8%AF%AF"><span class="toc-number">5.6.4.</span> <span class="toc-text">ASK错误</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E7%89%A9"><span class="toc-number">5.7.</span> <span class="toc-text">事物</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lua%E8%84%9A%E6%9C%AC"><span class="toc-number">5.8.</span> <span class="toc-text">lua脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E4%BC%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%89%A7%E8%A1%8C"><span class="toc-number">5.8.1.</span> <span class="toc-text">通过伪客户端执行</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3"><span class="toc-number">6.</span> <span class="toc-text">缓存相关</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">7.</span> <span class="toc-text">分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">7.1.</span> <span class="toc-text">常见的解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93-1"><span class="toc-number">7.1.1.</span> <span class="toc-text">数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98"><span class="toc-number">7.1.1.1.</span> <span class="toc-text">存在问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis"><span class="toc-number">7.1.2.</span> <span class="toc-text">redis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">7.1.2.1.</span> <span class="toc-text">存在的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RedLock%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B"><span class="toc-number">7.1.2.2.</span> <span class="toc-text">RedLock算法流程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B"><span class="toc-number">7.1.2.2.1.</span> <span class="toc-text">加锁过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zookeeper"><span class="toc-number">7.1.3.</span> <span class="toc-text">zookeeper</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B-1"><span class="toc-number">7.1.3.1.</span> <span class="toc-text">加锁过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">7.1.3.2.</span> <span class="toc-text">缺点</span></a></li></ol></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        Redis
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">jonas</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-07-05T07:07:16.756Z" class="dt-published" itemprop="datePublished">2023-07-05</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
    </div>


      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/Redis/" rel="tag">Redis</a>, <a class="p-category" href="/tags/%E5%85%AB%E8%82%A1/" rel="tag">八股</a>, <a class="p-category" href="/tags/%E7%BC%93%E5%AD%98/" rel="tag">缓存</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1 id="数据结构与对象"><a href="#数据结构与对象" class="headerlink" title="数据结构与对象"></a>数据结构与对象</h1><h2 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span>    </span><br><span class="line">	<span class="comment">// 记录buf数组中已使用字节的数量    </span></span><br><span class="line">	<span class="comment">// 等于SDS所保存字符串的长度 ，可以O(1)获取字符串长度   </span></span><br><span class="line">	<span class="type">int</span> len;    </span><br><span class="line">	<span class="comment">// 记录buf数组中未使用字节的数量    </span></span><br><span class="line">	<span class="type">int</span> <span class="built_in">free</span>;    </span><br><span class="line">	<span class="comment">// 字节数组，用于保存字符串,遵守C语言\0结尾的惯例，因为这样可以复用C语言的字符串部分方法    </span></span><br><span class="line">	<span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>len 可以O(1)获取字符串长度</li>
<li>避免缓冲器溢出</li>
<li>减少字符串修改带来的内容重新分配</li>
<li>空间预分配 + 惰性释放</li>
<li>二进制安全</li>
<li>兼容部分c函数</li>
</ul>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span>    </span><br><span class="line">	<span class="comment">// 前置节点    </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> * <span class="title">prev</span>;</span>    </span><br><span class="line">	<span class="comment">// 后置节点    </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> * <span class="title">next</span>;</span>   </span><br><span class="line">	<span class="comment">// 节点的值    </span></span><br><span class="line">	<span class="type">void</span> * value;</span><br><span class="line">&#125;listNode;</span><br><span class="line"># 双端链表</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span>    </span><br><span class="line">	<span class="comment">// 表头节点    </span></span><br><span class="line">	listNode * head;    </span><br><span class="line">	<span class="comment">// 表尾节点    </span></span><br><span class="line">	listNode * tail;    </span><br><span class="line">	<span class="comment">// 链表所包含的节点数量    </span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> len;    </span><br><span class="line">	<span class="comment">// 节点值复制函数    </span></span><br><span class="line">	<span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);    </span><br><span class="line">	<span class="comment">// 节点值释放函数    </span></span><br><span class="line">	<span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *ptr);    </span><br><span class="line">	<span class="comment">// 节点值对比函数    </span></span><br><span class="line">	<span class="type">int</span> (*match)(<span class="type">void</span> *ptr,<span class="type">void</span> *key);</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span>    </span><br><span class="line">	<span class="comment">// 哈希表数组   </span></span><br><span class="line">	dictEntry **table;    </span><br><span class="line">	<span class="comment">// 哈希表大小    </span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> size;    </span><br><span class="line">	<span class="comment">//哈希表大小掩码，用于计算索引值    </span></span><br><span class="line">	<span class="comment">//总是等于size-1    </span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> sizemask;    </span><br><span class="line">	<span class="comment">// 该哈希表已有节点的数量    </span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125; dictht;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span>    </span><br><span class="line">	<span class="comment">// 键    </span></span><br><span class="line">	<span class="type">void</span> *key;    </span><br><span class="line">	<span class="comment">// 值    </span></span><br><span class="line">	<span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">		<span class="type">void</span> *val;</span><br><span class="line">		uint64_tu64;</span><br><span class="line">		int64_ts64;</span><br><span class="line">	&#125; v;   </span><br><span class="line">	<span class="comment">// 指向下个哈希表节点，形成链表 </span></span><br><span class="line">	<span class="comment">//使用的是头插法   </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>
<h3 id="字典-1"><a href="#字典-1" class="headerlink" title="字典"></a>字典</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">	<span class="comment">// 类型特定函数</span></span><br><span class="line">	dictType *type;</span><br><span class="line">	<span class="comment">// 私有数据    </span></span><br><span class="line">	<span class="type">void</span> *privdata;</span><br><span class="line">	<span class="comment">// 哈希表    </span></span><br><span class="line">	dictht ht[<span class="number">2</span>];</span><br><span class="line">	<span class="comment">// rehash索引    </span></span><br><span class="line">	<span class="comment">//当rehash不在进行时，值为-1    </span></span><br><span class="line">	<span class="type">int</span> rehashidx;</span><br><span class="line">	 <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span>    </span><br><span class="line">	<span class="comment">// 计算哈希值的函数    </span></span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key)</span>;</span><br><span class="line">	<span class="comment">// 复制键的函数</span></span><br><span class="line">	<span class="type">void</span> *(*keyDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line">	<span class="comment">// 复制值的函数    </span></span><br><span class="line">	<span class="type">void</span> *(*valDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *obj);    </span><br><span class="line">	<span class="comment">// 对比键的函数</span></span><br><span class="line">	<span class="type">int</span> (*keyCompare)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key1, <span class="type">const</span> <span class="type">void</span> *key2);    </span><br><span class="line">	<span class="comment">// 销毁键的函数</span></span><br><span class="line">	<span class="type">void</span> (*keyDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *key);</span><br><span class="line">	<span class="comment">// 销毁值的函数</span></span><br><span class="line">	<span class="type">void</span> (*valDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.postimg.cc/Bv8FbGSH/00031.jpg"></p>
<h3 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h3><ol>
<li>为ht[1]分配ht[0].used*2的大小(收缩是ht[0].used的大小)</li>
<li>在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。</li>
<li>在rehash进行期间，每次只会迁移一小部分数据，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成之后，程序将rehashidx属性的值增一</li>
<li>随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash至ht[1]，这时程序将rehashidx属性的值设为-1，表示rehash操作已完成。</li>
</ol>
<h2 id="跳表skiplist"><a href="#跳表skiplist" class="headerlink" title="跳表skiplist"></a>跳表skiplist</h2><p><img src="https://i.postimg.cc/pdgFn1r7/00048.jpg"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span>    </span><br><span class="line">	<span class="comment">// 层</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">		<span class="comment">// 前进指针</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">		<span class="comment">// 跨度</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> span;    </span><br><span class="line">	&#125; level[];    </span><br><span class="line">	<span class="comment">// 后退指针    </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span>    </span><br><span class="line">	<span class="comment">// 分值    </span></span><br><span class="line">	<span class="type">double</span> score;    </span><br><span class="line">	<span class="comment">// 成员对象    </span></span><br><span class="line">	robj *obj;</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//跳表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span>    </span><br><span class="line">	<span class="comment">// 表头节点和表尾节点    </span></span><br><span class="line">	structz skiplistNode *header, *tail;</span><br><span class="line">	<span class="comment">// 表中节点的数量    </span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> length;    </span><br><span class="line">	<span class="comment">// 表中层数最大的节点的层数    </span></span><br><span class="line">	<span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="层高的确定逻辑"><a href="#层高的确定逻辑" class="headerlink" title="层高的确定逻辑"></a>层高的确定逻辑</h3><p>每次创建一个新跳跃表节点的时候，程序都根据幂次定律（power law，越大的数出现的概率越小）随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的“高度”。<br>具体的做法是，跳表在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于 0.25（相当于概率 25%），那么层数就增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 0.25 结束，最终确定该节点的层数。这样的做法，相当于每增加一层的概率不超过 25%，层数越高，概率越低，层高最大限制是 32（层高不同版本不一样）。</p>
<h3 id="排序方式"><a href="#排序方式" class="headerlink" title="排序方式"></a>排序方式</h3><p>按score由小到大排序，如果分数一样，则按成员对象在字典序的大小来判断</p>
<h3 id="跳表的查询过程"><a href="#跳表的查询过程" class="headerlink" title="跳表的查询过程"></a>跳表的查询过程</h3><ol>
<li><strong>开始节点</strong>：查询从跳表的头部节点（通常是一个特殊的头部节点，不包含实际数据）开始，这个节点有指向不同层的指针。</li>
<li><strong>水平遍历</strong>：从跳表的最高层开始，向右遍历节点。如果<strong>当前节点的下一个节点</strong>的值小于要查询的值，就继续向右移动。</li>
<li><strong>下降</strong>：如果当前节点的下一个节点的值大于要查询的值，或者当前节点是该层的最后一个节点（即没有下一个节点），则向下移动到下一层。</li>
<li><strong>继续搜索</strong>：在下一层，重复进行向右查找和下降的过程，直到到达最底层的链表。</li>
<li><strong>最底层查找</strong>：在最底层，继续向右查找，直到找到一个值等于查询值的节点，或者找到一个值大于查询值的节点，或者到达链表的末尾。</li>
<li><strong>返回结果</strong>：<ul>
<li>如果找到了一个值等于查询值的节点，查询成功，返回该节点或相应的信息。</li>
<li>如果没有找到，或者找到了一个值大于查询值的节点，说明要查询的值不在跳表中，返回查询失败或null。</li>
</ul>
</li>
</ol>
<h3 id="跳表的新增过程"><a href="#跳表的新增过程" class="headerlink" title="跳表的新增过程"></a>跳表的新增过程</h3><ol>
<li><strong>查找插入位置</strong>：首先，从跳表的头部节点开始，向右和向下查找应该插入的位置，直到到达最底层链表。在每一层，如果当前节点的下一个节点的值小于要插入的值，则继续向右移动；如果大于或等于要插入的值，则向下移动到下一层，继续查找。</li>
<li><strong>更新前驱节点</strong>：在查找过程中，会记录下每一层达到的最后一个节点，这些节点将成为新节点在每一层的前驱节点。</li>
<li><strong>随机生成层数</strong>：插入新元素时，需要随机生成一个层数，该层数决定了新节点在跳表中的高度。通常，这个过程使用“抛硬币”的方式，即每次随机决定是否增加一层，直到“抛硬币”结果为否或者达到了跳表的最大高度。</li>
<li><strong>创建新节点</strong>：为新元素创建一个跳表节点，该节点的层数等于随机生成的层数。</li>
<li><strong>链接节点</strong>：将新节点插入到跳表中，更新步骤 2 中记录的前驱节点的指针，将它们的后继指针指向新节点，同时将新节点的后继指针指向前驱节点原先的后继节点。这一步需要在新节点的所有层上执行。</li>
<li><strong>更新跳表属性</strong>：如果新节点的层数超过了跳表当前的最大层数，跳表的头部节点和最大层数属性将被更新。</li>
<li><strong>维护跳表的有序性</strong>：跳表通过以上步骤确保插入后，所有的层都保持有序（从左到右为递增顺序）。</li>
</ol>
<h3 id="为什么不实用平衡二叉树"><a href="#为什么不实用平衡二叉树" class="headerlink" title="为什么不实用平衡二叉树"></a>为什么不实用平衡二叉树</h3><p>redis的左右有回答这个问题，大致分下面三点：</p>
<ol>
<li>查找性能不比平衡二叉树低</li>
<li>从内存占用上来比较，跳表比平衡树更灵活一些。平衡树每个节点包含 2 个指针（分别指向左右子树），而跳表每个节点包含的指针数目平均为 1&#x2F;(1-p)，具体取决于参数 p 的大小。如果像 Redis里的实现一样，取 p&#x3D;1&#x2F;4，那么平均每个节点包含 1.33 个指针，比平衡树更有优势。</li>
<li>实现相对简单</li>
</ol>
<h2 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h2><p>各项数据由小到大有序排列并且不会重复<br>新添加的数据如果比之前的数据类型要长，会将encoding换成新的类型，并重新分配内存，但是不会降级</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span>    </span><br><span class="line">	<span class="comment">// 编码方式   </span></span><br><span class="line">	<span class="type">uint32_t</span> encoding;    </span><br><span class="line">	<span class="comment">// 集合包含的元素数量    </span></span><br><span class="line">	<span class="type">uint32_t</span> length;    </span><br><span class="line">	<span class="comment">// 保存元素的数组    </span></span><br><span class="line">	<span class="type">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>
<h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><p>zlbytes | zltail | zllen | entry1 | entry2 | …. | entryN | zlend</p>
<ul>
<li>zlbytes 记录占用的总共字节数</li>
<li>zltail 记录尾节点距离头结点多少个字节，可以快速定位为节点</li>
<li>zllen 包含的节点数量，当大于65535时需啊遍历才能得到正确的值</li>
<li>zlend 0xFF 表结尾标记</li>
</ul>
<h3 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h3><p>存放字节数组或整数<br>previous_entry_length | encoding | content </p>
<ul>
<li>previous_entry_length前一个节点的长度，用于遍历前一个节点</li>
<li>encoding 记录节点保存数据的类型及长度</li>
<li>content 值大小有encoding决定</li>
</ul>
<h2 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h2><p>在 Redis 3.0 之前，List 对象的底层数据结构是双向链表或者压缩列表。然后在 Redis 3.2 的时候，List 对象的底层改由 quicklist 数据结构实现。<br>其实 quicklist 就是「双向链表 + 压缩列表」组合，因为一个 quicklist 就是一个链表，而链表中的每个元素又是一个压缩列表。<br>quicklist 解决办法，<strong>通过控制每个链表节点中的压缩列表的大小或者元素个数，来规避连锁更新的问题。因为压缩列表元素越少或越小，连锁更新带来的影响就越小，从而提供了更好的访问性能。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    <span class="comment">//quicklist的链表头</span></span><br><span class="line">    quicklistNode *head;      <span class="comment">//quicklist的链表头</span></span><br><span class="line">    <span class="comment">//quicklist的链表尾</span></span><br><span class="line">    quicklistNode *tail; </span><br><span class="line">    <span class="comment">//所有压缩列表中的总元素个数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> count;</span><br><span class="line">    <span class="comment">//quicklistNodes的个数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;       </span><br><span class="line">    ...</span><br><span class="line">&#125; quicklist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">//前一个quicklistNode</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span>     <span class="comment">//前一个quicklistNode</span></span><br><span class="line">    <span class="comment">//下一个quicklistNode</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span>     <span class="comment">//后一个quicklistNode</span></span><br><span class="line">    <span class="comment">//quicklistNode指向的压缩列表</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zl;              </span><br><span class="line">    <span class="comment">//压缩列表的的字节大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz;                </span><br><span class="line">    <span class="comment">//压缩列表的元素个数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count : <span class="number">16</span>;        <span class="comment">//ziplist中的元素个数 </span></span><br><span class="line">    ....</span><br><span class="line">&#125; quicklistNode;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/f46cbe347f65ded522f1cc3fd8dba549.png"></p>
<h2 id="listpack"><a href="#listpack" class="headerlink" title="listpack"></a>listpack</h2><p><img src="https://cdn.xiaolincoding.com//mysql/other/c5fb0a602d4caaca37ff0357f05b0abf.png"><br>可以看到，<strong>listpack 没有压缩列表中记录前一个节点长度的字段了，listpack 只记录当前节点的长度，当我们向 listpack 加入一个新元素的时候，不会影响其他节点的长度字段的变化，从而避免了压缩列表的连锁更新问题</strong>。</p>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>redis并没有直接使用数据结构，而是整合成字符串对象，列表对象，哈希对象，集合对象，有序集合对象，每个对象至少使用一个数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span>    </span><br><span class="line">	<span class="comment">// 类型 </span></span><br><span class="line">	<span class="comment">//REDIS_STRING, REDIS_LIST, REDIS_HASH, REDIS_SET, REDIS_ZSET   </span></span><br><span class="line">	<span class="type">unsigned</span> type:<span class="number">4</span>;    </span><br><span class="line">	<span class="comment">// 编码 </span></span><br><span class="line">	<span class="comment">//REDIS_ENCODING_INT,</span></span><br><span class="line">	<span class="comment">//REDIS_ENCODING_EMBSTR  字符串的建值放在一起 只需分配一次内存和一次回收</span></span><br><span class="line">	<span class="comment">//REDIS_ENCODING_RAW 字符串的建值分开一起</span></span><br><span class="line">	<span class="comment">//REDIS_ENCODING_HT</span></span><br><span class="line">	<span class="comment">//REDIS_ENCODING_LINKEDLIST</span></span><br><span class="line">	<span class="comment">//REDIS_ENCODING_ZIPLIST</span></span><br><span class="line">	<span class="comment">//REDIS_ENCODING_INTSET</span></span><br><span class="line">	<span class="comment">//REDIS_ENCODING_SKIPLIST  </span></span><br><span class="line">	<span class="type">unsigned</span> encoding:<span class="number">4</span>;    </span><br><span class="line">	<span class="comment">// 指向底层实现数据结构的指针    </span></span><br><span class="line">	<span class="type">void</span> *ptr;</span><br><span class="line">	<span class="comment">//引用计数，用于垃圾回收</span></span><br><span class="line">	<span class="type">int</span> refcount;</span><br><span class="line">	<span class="comment">//上次被访问的时间，用于当内存不足的回收策略为volatile-lru,allkeys-lru</span></span><br><span class="line">	<span class="type">unsigned</span> lru;    </span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>
<h3 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h3><h3 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h3><ul>
<li>ziplist (所有列表保存的字符串长度小于64 || 列表数量小于512)</li>
<li>linkedlist</li>
</ul>
<h3 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h3><ul>
<li>ziplist （同上64， 512）</li>
<li>hashtable</li>
</ul>
<h3 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h3><ul>
<li>intset（都是整数，不超过512）</li>
<li>hashtable</li>
</ul>
<h3 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h3><ul>
<li>ziplist （数据按大小顺序存放） (同上64， 128)</li>
<li>skiplist +dict<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span>    </span><br><span class="line">	zskiplist *zsl;    </span><br><span class="line">	dict *dict;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>
<img src="https://i.postimg.cc/NFNGR5bM/Pasted-image-20240304201050.png"></li>
</ul>
<h3 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h3><p>redis在初始化时会创建0-9999共1w个整型，用来做复用</p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">	<span class="comment">//数据库的数量，默认16</span></span><br><span class="line">	<span class="type">int</span> dbNum;</span><br><span class="line">	<span class="comment">//数据库数组指针</span></span><br><span class="line">	redisDb *db</span><br><span class="line">	<span class="comment">//距离上一次rdb的修改数量</span></span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> dirty</span><br><span class="line">	<span class="comment">//上一次rdb的时间</span></span><br><span class="line">	<span class="type">time_t</span> last_save</span><br><span class="line">	<span class="comment">//链表，保存所有客户端状态</span></span><br><span class="line">	lists *clients</span><br><span class="line">	redisClien *lua_client</span><br><span class="line">	<span class="comment">//从服务器对应的主服务器配置</span></span><br><span class="line">	<span class="type">char</span> *masterhost;</span><br><span class="line">	<span class="type">int</span> masterport</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端数据库</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span>&#123;</span></span><br><span class="line">	<span class="comment">//记录当前客户端使用的数据库</span></span><br><span class="line">	redisDb *db</span><br><span class="line">	<span class="comment">//-1或者大于-1的整数，aof使用的伪客户端为-1</span></span><br><span class="line">	<span class="type">int</span> fd</span><br><span class="line">	<span class="comment">//客户端所处的状态 REDIS_MASTER REDIS_SLAVE REDIS_PRE_PSYCN PSYNC REDIS_LUA_CLIENT </span></span><br><span class="line">	<span class="comment">//REDIS_MONITOR REDIS_MONITOR_SOCK REDIS_BLOCKED REDIS_UNBLOCKED</span></span><br><span class="line">	<span class="comment">//REDIS_MULTI...</span></span><br><span class="line">	<span class="type">int</span> flags</span><br><span class="line">	<span class="comment">//输入缓冲区，保存客户端发送的命令</span></span><br><span class="line">	<span class="comment">//输入参数</span></span><br><span class="line">	robj *argsv</span><br><span class="line">	<span class="type">int</span> argc</span><br><span class="line">	sds querybuf</span><br><span class="line">	<span class="comment">//当前执行的命令指向</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span></span></span><br><span class="line"><span class="class">	//固定大小的输出的缓冲区，存放输出量较小的内容，当<span class="title">buf</span>放不下时，放出可变大小缓冲区</span></span><br><span class="line"><span class="class">	//固定大小的输出缓冲区</span></span><br><span class="line"><span class="class">	<span class="title">char</span> <span class="title">buf</span>[<span class="title">REIDS_REPLY_CHUNK_BYTES</span>]</span></span><br><span class="line"><span class="class">	//<span class="title">buf</span>已使用的字节数量</span></span><br><span class="line"><span class="class">	<span class="title">int</span> <span class="title">bufpos</span></span></span><br><span class="line"><span class="class">	//可变大小的输出缓冲区,由一个或多个字符串对象组成</span></span><br><span class="line"><span class="class">	<span class="title">list</span> *<span class="title">reply</span></span></span><br><span class="line"><span class="class">	//身份验证 0未通过 1已通过</span></span><br><span class="line"><span class="class">	<span class="title">int</span> <span class="title">authenticated</span></span></span><br><span class="line"><span class="class">	<span class="title">time_</span> <span class="title">ctime</span></span></span><br><span class="line"><span class="class">	<span class="title">time_t</span> <span class="title">lastinteraction</span></span></span><br><span class="line"><span class="class">	//输出缓冲区第一次打到软性限制的时间</span></span><br><span class="line"><span class="class">	<span class="title">time_t</span> <span class="title">obuf_soft_limit_reached_time</span></span></span><br><span class="line"><span class="class">	//从服务器监听的端口号</span></span><br><span class="line"><span class="class">	<span class="title">int</span> <span class="title">slave_listening_port</span></span></span><br><span class="line"><span class="class">&#125;<span class="title">redisClient</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span>&#123;</span></span><br><span class="line">	<span class="comment">//数据库键空间，保存所有的键值对</span></span><br><span class="line">	dict *dict</span><br><span class="line">	<span class="comment">//存放带有过期时间的键与过期时间</span></span><br><span class="line">	dict *expires</span><br><span class="line">&#125; redisDb</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h3><ul>
<li><del>定时删除</del>  （创建Timer代价高，未被使用）</li>
<li>定期删除 （定期从expires的数据库中随机选出一批检查）</li>
<li>惰性删除 （读写前检查）</li>
</ul>
<h3 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h3><ol>
<li><strong>noeviction</strong>: 不进行数据淘汰。一旦达到内存限制，Redis会返回错误给写命令。适用于内存不做限制的情况，或者数据量不会超出内存限制。</li>
<li><strong>allkeys-lru</strong>: 当内存不足以容纳新写入数据时，在键空间中，使用最近最少使用（LRU）算法移除最少使用的键。这是默认策略，适用于大多数场景。</li>
<li><strong>volatile-lru</strong>: 从已设置过期时间的键集合中，使用LRU算法淘汰最少使用的键。如果没有可淘汰的键，会返回错误。</li>
<li><strong>allkeys-random</strong>: 当内存不足时，随机淘汰键，不管其使用频率如何。</li>
<li><strong>volatile-random</strong>: 从所有设置了过期时间的键中随机选择键进行淘汰。</li>
<li><strong>volatile-ttl</strong>: 从设置了过期时间的键中选择存活时间（TTL）最短的键进行淘汰。</li>
<li><strong>volatile-lfu</strong>: 从设置了过期时间的键中，使用最不经常使用（LFU）算法淘汰数据。（redis 4.0后加）</li>
<li><strong>allkeys-lfu</strong>: 从所有键中，使用LFU算法淘汰最不经常使用的键。（redis 4.0后加）</li>
</ol>
<h4 id="过期建的rdb-与aof"><a href="#过期建的rdb-与aof" class="headerlink" title="过期建的rdb 与aof"></a>过期建的rdb 与aof</h4><ul>
<li>rdb在dump的时候会过滤过期的建，在导入的时候如果以主服务器运行会忽略过期的键，以从服务器过期的也会导入</li>
<li>在键因过期被删除时，会写aof，aof重写时会忽略过期的键</li>
<li>主服务器的建过期时，会向从服务器发del，从服务器当有读写命令时，如果该键已经失效了也不会操作删除，而是等到主服务器的del命令， 这样保证了主从的一致性</li>
</ul>
<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><h4 id="rdb"><a href="#rdb" class="headerlink" title="rdb"></a>rdb</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 900s内有1次改动</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>
<p>save，bgsave生成二进制文件</p>
<h5 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h5><p>REDIS|db_version|databases|EOF|check_sum<br>databases部分<br>REDIS|db_version|database 0|database 3|EOF|check_sum<br>SELECTDB|db_number|key_values_pars</p>
<h4 id="aof"><a href="#aof" class="headerlink" title="aof"></a>aof</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 是否开启</span><br><span class="line">appendonly yes</span><br><span class="line"># 刷盘时机 always, everysec (default), no</span><br><span class="line">appendfsync always</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>aof重写：防止aof过大<br>aof重写缓冲区保证数据一致</p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><h4 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h4><p>基于reactor模式的网络事件处理器（file event handler）</p>
<h4 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h4><ul>
<li>定时事件</li>
<li>周期性事件</li>
</ul>
<h1 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h1><h2 id="serverCron函数"><a href="#serverCron函数" class="headerlink" title="serverCron函数"></a>serverCron函数</h2><p>每100ms执行的定时任务，用于维护server的各种数据</p>
<h1 id="多机数据库实现"><a href="#多机数据库实现" class="headerlink" title="多机数据库实现"></a>多机数据库实现</h1><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><blockquote>
<p>主从复制 slaveof ip port<br>复制过程分为 同步 + 命令传播两个过程</p>
</blockquote>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>当执行slaveof命令，要求从服务器复制主服务器，从服务器需要执行同步操作，即sync命令，新版2.8及以后使用的是PSYNC，执行步骤是</p>
<ol>
<li>从服务器向主服务器发送sync命令</li>
<li>主服务器收到sync命令后执行bgsave，生成rdb文件，并使用一个缓冲区记录从当前开始所以的写命令</li>
<li>主服务器将rdb文件发送给从服务器，从服务器载入数据</li>
<li>主服务器将缓冲区数据发送给从服务器，从服务器更新导最新状态<br>后续的写操作通过命令传播给从服务器</li>
</ol>
<h3 id="PSYNC"><a href="#PSYNC" class="headerlink" title="PSYNC"></a>PSYNC</h3><blockquote>
<p>PSYNC解决了从服务器断开链接后，再次与主服务器链接需要dump rdb造成的资源浪费</p>
</blockquote>
<p>主要由三个部分构成</p>
<ol>
<li>主服务器的复制偏离量和从服务器的复制偏移量</li>
<li>主服务器的复制积压缓冲区（默认为1M，如果从服务器的偏移量已经不再缓冲区中，则需要执行rdb的dump操作）</li>
<li>服务器的运行Id（run ID）<br>使用到的命令<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//首次复制</span><br><span class="line">PSYNC ? -1</span><br><span class="line">//首次响应</span><br><span class="line">+FULLRESYNC RUNID OFFSET</span><br><span class="line">//非首次</span><br><span class="line">PAYNC RUNID OFFSET</span><br><span class="line">//非首次响应</span><br><span class="line">+CONTINUE ?</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h2><h2 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h2><h3 id="心跳检测（2-8版本后新增）"><a href="#心跳检测（2-8版本后新增）" class="headerlink" title="心跳检测（2.8版本后新增）"></a>心跳检测（2.8版本后新增）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPLCONF ACK &lt;replication_offset&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>检测服务器的网络连接状态（从服务器每秒向主服务器发送）</li>
<li>辅助实现min-slaves</li>
<li>检测命令丢失</li>
</ul>
<h2 id="sentinel"><a href="#sentinel" class="headerlink" title="sentinel"></a>sentinel</h2><blockquote>
<p>由一个或多个Sentinel实例（instance）组成的Sentinel系统（system）可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。</p>
</blockquote>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel /path/to/sentinel.conf</span><br><span class="line">//or</span><br><span class="line"></span><br><span class="line">redis-server /path/to/sentinal.conf --sentinel</span><br></pre></td></tr></table></figure>
<h3 id="重新选主流程"><a href="#重新选主流程" class="headerlink" title="重新选主流程"></a>重新选主流程</h3><p>当Redis Sentinel集群中的主服务器发生故障或不可用时，Sentinel会自动进行重新选举，并将一个从服务器提升为新的主服务器。以下是Redis Sentinel重新选主的流程：</p>
<ol>
<li>Sentinel检测到主服务器不可用：每个Sentinel节点都会定期对主服务器进行健康检查（PING）。如果某个Sentinel节点检测到主服务器不可用，它会将这个信息广播给其他Sentinel节点。</li>
<li>Sentinel节点达成共识：当多个Sentinel节点检测到主服务器不可用时，它们会通过共识算法达成一致，确定主服务器已下线。</li>
<li>选择新的主服务器：一旦达成共识，Sentinel节点会从当前可用的从服务器中选择一个来提升为新的主服务器。选择的依据通常是当前从服务器的复制偏移量（replication offset）最大的那个。</li>
<li>进行故障转移：被选中的从服务器会被设置为新的主服务器，并重新配置其他从服务器以复制新的主服务器。同时，Sentinel节点会更新哨兵集群的配置，将新的主服务器信息广播给其他Sentinel节点和客户端。</li>
<li>客户端重新连接：一旦故障转移完成，客户端需要重新连接到新的主服务器，并且进行相应的配置更新。</li>
</ol>
<p>需要注意的是，Redis Sentinel重新选主的过程是自动进行的，无需手动干预。同时，Redis Sentinel集群的配置项也会影响重新选主的过程，例如<code>sentinel down-after-milliseconds</code>和<code>sentinel failover-timeout</code>等参数会影响Sentinel节点判断主服务器是否下线以及进行故障转移的时间。因此，在配置Sentinel集群时，需要根据实际需求进行适当的参数配置。</p>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><blockquote>
<p>分布式数据库方案，集群通过分片（sharding）来进行数据共享，并提供复制和故障转移功能</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#conf</span></span><br><span class="line">cluster-enabled yes <span class="comment">//将该节点设为集群节点</span></span><br><span class="line"># 命令</span><br><span class="line"># 节点间相互链接</span><br><span class="line">CLUSTER MEET &lt;IP&gt; &lt;PORT&gt;</span><br><span class="line"></span><br><span class="line"># 每个节点使用clusterNode结构来记录自己的状态</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span>  </span><br><span class="line">	<span class="comment">// 创建节点的时间  </span></span><br><span class="line">	<span class="type">mstime_t</span> ctime;  </span><br><span class="line">	<span class="comment">// 节点的名字，由40个十六进制字符组成  </span></span><br><span class="line">	<span class="comment">// 例如68eef66df23420a5862208ef5b1a7005b806f2ff  </span></span><br><span class="line">	<span class="type">char</span> name[REDIS_CLUSTER_NAMELEN];  </span><br><span class="line">	<span class="comment">// 节点标识  </span></span><br><span class="line">	<span class="comment">// 使用各种不同的标识值记录节点的角色（比如主节点或者从节点），  </span></span><br><span class="line">	<span class="comment">// 以及节点目前所处的状态（比如在线或者下线）。  </span></span><br><span class="line">	<span class="type">int</span> flags; </span><br><span class="line">	<span class="comment">// 节点当前的配置纪元，用于实现故障转移  </span></span><br><span class="line">	<span class="type">uint64_t</span> configEpoch;  </span><br><span class="line">	<span class="comment">// 节点的IP地址  </span></span><br><span class="line">	<span class="type">char</span> ip[REDIS_IP_STR_LEN];  </span><br><span class="line">	<span class="comment">// 节点的端口号  </span></span><br><span class="line">	<span class="type">int</span> port;  </span><br><span class="line">	<span class="comment">// 保存连接节点所需的有关信息  </span></span><br><span class="line">	<span class="comment">//该结构保存了连接节点所需的有关信息，比如套接字描述符，输入缓冲区和输出缓冲区</span></span><br><span class="line">	clusterLink *link;  </span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span>  </span><br><span class="line">	<span class="comment">// 指向当前节点的指针  </span></span><br><span class="line">	clusterNode *myself;  </span><br><span class="line">	<span class="comment">// 集群当前的配置纪元，用于实现故障转移 </span></span><br><span class="line">	<span class="type">uint64_t</span> currentEpoch;  </span><br><span class="line">	<span class="comment">// 集群当前的状态：是在线还是下线  </span></span><br><span class="line">	<span class="type">int</span> state;  </span><br><span class="line">	<span class="comment">// 集群中至少处理着一个槽的节点的数量  </span></span><br><span class="line">	<span class="type">int</span> size;  </span><br><span class="line">	<span class="comment">// 集群节点名单（包括myself节点）与其他节点信息 </span></span><br><span class="line">	<span class="comment">// 字典的键为节点的名字，字典的值为节点对应的clusterNode结构  </span></span><br><span class="line">	dict *nodes;  </span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125; clusterState;</span><br></pre></td></tr></table></figure>
<h3 id="cluster-meet命令实现"><a href="#cluster-meet命令实现" class="headerlink" title="cluster meet命令实现"></a>cluster meet命令实现</h3><p>以A将B加入为例</p>
<ol>
<li>节点A会为节点B创建一个clusterNode结构，并将该结构添加到自己的clusterState.nodes字典里面。</li>
<li>之后，节点A将根据CLUSTER MEET命令给定的IP地址和端口号，向节点B发送一条MEET消息（message）。</li>
<li>如果一切顺利，节点B将接收到节点A发送的MEET消息，节点B会为节点A创建一个clusterNode结构，并将该结构添加到自己的clusterState.nodes字典里面。</li>
<li>之后，节点B将向节点A返回一条PONG消息。</li>
<li>如果一切顺利，节点A将接收到节点B返回的PONG消息，通过这条PONG消息节点A可以知道节点B已经成功地接收到了自己发送的MEET消息。</li>
<li>之后，节点A将向节点B返回一条PING消息。</li>
<li>如果一切顺利，节点B将接收到节点A返回的PING消息，通过这条PING消息节点B可以知道节点A已经成功地接收到了自己返回的PONG消息，握手完成。</li>
</ol>
<h3 id="槽指派"><a href="#槽指派" class="headerlink" title="槽指派"></a>槽指派</h3><blockquote>
<p>集群的整个数据库分为16384个槽</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">cluster addslots &lt;slot&gt; [slot ...]</span><br><span class="line"><span class="comment">//将0到5000分给7000节点负责</span></span><br><span class="line"><span class="comment">//登录到7000节点</span></span><br><span class="line">cluster addslots <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> ... <span class="number">5000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//记录槽指派的信息，在clusterNode结构的slots属性和numslot熟悉记录节点负责处理哪些槽</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line">	<span class="comment">//二进制数组，如果对应的1就表示在该节点</span></span><br><span class="line">	<span class="comment">//即使有clusterState.clusterNode，slots熟悉仍有必要，因为</span></span><br><span class="line">	<span class="comment">//1.直接将该数组发送出去就可以告诉别人当前节点的槽信息</span></span><br><span class="line">	<span class="comment">//2. 且不需要先遍历一遍clusterState.clusterNode</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> slots[<span class="number">16384</span>/<span class="number">8</span>]</span><br><span class="line">	<span class="comment">//处理的槽的数量</span></span><br><span class="line">	<span class="type">int</span> numslots</span><br><span class="line">	<span class="comment">//如果是从节点，指向主节点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> *<span class="title">slaveof</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class">//记录槽指向的集群节点</span></span><br><span class="line"><span class="class"><span class="title">typedef</span> <span class="keyword">struct</span> <span class="title">clusterState</span>&#123;</span></span><br><span class="line">	clusterNode *slots[<span class="number">16384</span>];</span><br><span class="line">	<span class="comment">//跳表里记录的是key和slot的对应关系，这样可以根据槽号获取对应的建</span></span><br><span class="line">	 zskiplist *slots_to_keys;</span><br><span class="line">	 <span class="comment">//正准备迁移至</span></span><br><span class="line">	 clusterNode *migrating_slots_to[<span class="number">16384</span>]</span><br><span class="line">	 <span class="comment">//准备从哪个节点导入</span></span><br><span class="line">	 clusterNode *importing_slots_from[<span class="number">16384</span>]</span><br><span class="line">&#125; clusterState</span><br></pre></td></tr></table></figure>

<p>如果请求的key不在当前节点，则返回moved错误给客户端</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算属于哪个槽</span></span><br><span class="line">def <span class="title function_">slot_number</span><span class="params">(key)</span>:</span><br><span class="line">	<span class="keyword">return</span> <span class="title function_">crc</span><span class="params">(key)</span> &amp; 16383</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以使用下面命令查看在那个槽</span></span><br><span class="line">cluster keyslot &quot;data&quot;</span><br></pre></td></tr></table></figure>
<h3 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.redis-trib对目标节点发送CLUSTER SETSLOT &lt;slot&gt; IMPORTING&lt;source_id&gt;命令，让目标节点准备好从源节点导入（import）属于槽slot的键值对。</span><br><span class="line">2. redis-trib对源节点发送CLUSTER SETSLOT&lt;slot&gt;MIGRATING&lt;target_id&gt;命令，让源节点准备好将属于槽slot的键值对迁移（migrate）至目标节点。</span><br><span class="line">3. redis-trib向源节点发送CLUSTER GETKEYSINSLOT&lt;slot&gt;&lt;count&gt;命令，获得最多count个属于槽slot的键值对的键名（key name）。</span><br><span class="line">4. 对于步骤3获得的每个键名，redis-trib都向源节点发送一个MIGRATE&lt;target_ip&gt;&lt;target_port&gt;&lt;key_name&gt;0&lt;timeout&gt;命令，将被选中的键原子地从源节点迁移至目标节点。</span><br><span class="line">5. 重复执行步骤3和步骤4，直到源节点保存的所有属于槽slot的键值对都被迁移至目标节点为止。每次迁移键的过程如图17-24所示。</span><br><span class="line">6. redis-trib向集群中的任意一个节点发送CLUSTER SETSLOT&lt;slot&gt;NODE&lt;target_id&gt;命令，将槽slot指派给目标节点，这一指派信息会通过消息发送至整个集群，最终集群中的所有节点都会知道槽slot已经指派给了目标节点。</span><br></pre></td></tr></table></figure>

<h3 id="ASK错误"><a href="#ASK错误" class="headerlink" title="ASK错误"></a>ASK错误</h3><p>在迁移的过程中，如果节点在当前节点则直接返回，如果已迁移至新节点，则返回ASK错误，导向目标节点</p>
<h2 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h2><blockquote>
<p>MULTI,EXEC,WATCH</p>
</blockquote>
<ul>
<li>发送multi后的语句并不会立即执行，命令会放入到队列中，当遇到EXEC,DISCARD,WATCH,MULTI时才会执行</li>
<li>如果是命令格式的错误，事务类的语句都不会执行，如果是操作过程才能发现的错误，redis会执行，且不会回滚</li>
</ul>
<h2 id="lua脚本"><a href="#lua脚本" class="headerlink" title="lua脚本"></a>lua脚本</h2><blockquote>
<p>Redis从2.6版本开始引入对Lua脚本的支持，通过在服务器中嵌入Lua环境，Redis客户端可以使用Lua脚本，直接在服务器端原子地执行多个Redis命令</p>
</blockquote>
<h3 id="通过伪客户端执行"><a href="#通过伪客户端执行" class="headerlink" title="通过伪客户端执行"></a>通过伪客户端执行</h3><p>注意在集群中多个key可能分布在不同的节点，即原子性不能保证</p>
<h1 id="缓存相关"><a href="#缓存相关" class="headerlink" title="缓存相关"></a>缓存相关</h1><p>[[缓存]]</p>
<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p><a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%9845%E8%AE%B2-%E5%AE%8C/11%20%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E5%AE%9E%E7%8E%B0%EF%BC%9F.md">参考链接</a></p>
<h2 id="常见的解决方案"><a href="#常见的解决方案" class="headerlink" title="常见的解决方案"></a>常见的解决方案</h2><h3 id="数据库-1"><a href="#数据库-1" class="headerlink" title="数据库"></a>数据库</h3><blockquote>
<p>基于数据库的主键不能重复，往数据库中插入数据，如果插入成功则抢到了锁</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `methodLock` ( </span><br><span class="line">`id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">`method_name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;锁定的方法或者资源&#x27;</span>, </span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`), </span><br><span class="line"><span class="keyword">UNIQUE</span> KEY `uidx_method_name` (`method_name `) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;对方法加锁&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> methodLock(method_name) <span class="keyword">values</span> (<span class="string">&#x27;method_name&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h4><ul>
<li>单点故障</li>
<li>超时无法失效</li>
<li>不可重入</li>
<li>无法实现阻塞</li>
</ul>
<h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><p><code>SET key value expireTime nx</code></p>
<h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><ol>
<li>锁超时被其他进程释放：通过lua脚本进行值对比释放</li>
<li>集群下可能出现多进程都获得锁（发生了故障转移）：Redlock</li>
</ol>
<h4 id="RedLock算法流程"><a href="#RedLock算法流程" class="headerlink" title="RedLock算法流程"></a>RedLock算法流程</h4><blockquote>
<p><strong>Redlock 算法</strong>是在单 Redis 节点基础上引入的<strong>高可用模式</strong>，Redlock 基于 N 个完全独立的 Redis 节点，一般是<strong>大于 3 的奇数个</strong>（通常情况下 N 可以设置为 5），可以基本保证集群内各个节点不会同时宕机。</p>
</blockquote>
<h5 id="加锁过程"><a href="#加锁过程" class="headerlink" title="加锁过程"></a>加锁过程</h5><ul>
<li>1、客户端获取当前时间，以毫秒为单位。</li>
<li>2、客户端尝试获取 N 个节点的锁，（每个节点获取锁的方式和前面说的缓存锁一样），N 个节点以相同的 key 和 value 获取锁。客户端需要设置接口访问超时，接口超时时间需要远远小于锁超时时间，比如锁自动释放的时间是 10s，那么接口超时大概设置 5-50ms。这样可以在有 redis 节点宕机后，访问该节点时能尽快超时，而减小锁的正常使用。</li>
<li>3、客户端计算在获得锁的时候花费了多少时间，方法是用当前时间减去在步骤一获取的时间，只有客户端获得了超过 N&#x2F;2 +1 个节点的锁，而且获取锁的时间小于锁的超时时间，客户端才获得了分布式锁。</li>
<li>4、客户端获取的锁的时间为设置的锁超时时间减去步骤三计算出的获取锁花费时间。</li>
<li>5、如果客户端获取锁失败了，客户端会依次删除所有的锁。 使用 Redlock 算法，可以保证在挂掉最多 2 个节点的时候，分布式锁服务仍然能工作，这相比之前的数据库锁和缓存锁大大提高了可用性，由于 redis 的高效性能，分布式缓存锁性能并不比数据库锁差。</li>
</ul>
<h3 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h3><p>ZooKeeper 有四种节点类型，包括持久节点、持久顺序节点、临时节点和<code>临时顺序节点</code>，利用 ZooKeeper 支持临时顺序节点的特性，可以实现分布式锁<br>当客户端对某个方法加锁时，在 ZooKeeper 中该方法对应的指定节点目录下，生成一个唯一的临时有序节点；<br>判断是否获取锁，只需要判断持有的节点是否是有序节点中序号最小的一个，是则加锁成功，否则watch 序号比本身小的前一个节点 (公平锁)；当释放锁的时候，将这个临时节点删除即可，这种方式可以避免服务宕机导致的锁无法释放而产生的死锁问题。<br><img src="https://i.postimg.cc/xdHdBjjx/Pasted-image-20240201110044.png"></p>
<h4 id="加锁过程-1"><a href="#加锁过程-1" class="headerlink" title="加锁过程"></a>加锁过程</h4><ol>
<li>连接zookeeper，创建顺序临时节点</li>
<li>判断当前节点的值是否是该节点下的最小值，如果是则说明拿到了锁，否则通过watch事件监听节点的变更信息，重复判断过程直到获取到锁</li>
<li>执行完后，删除对应的子节点，释放分布式锁</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>性能没有缓存服务器好</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/categories/">Category</a></li>
        
          <li><a href="/tags/">Tag</a></li>
        
          <li><a href="/search">Search</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/jonasrepo.github.io">Projects</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.</span> <span class="toc-text">数据结构与对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SDS"><span class="toc-number">1.1.</span> <span class="toc-text">SDS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">1.1.1.</span> <span class="toc-text">优点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.</span> <span class="toc-text">链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E5%85%B8"><span class="toc-number">1.3.</span> <span class="toc-text">字典</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">哈希表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E5%85%B8-1"><span class="toc-number">1.3.2.</span> <span class="toc-text">字典</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%90%E8%BF%9B%E5%BC%8Frehash"><span class="toc-number">1.3.3.</span> <span class="toc-text">渐进式rehash</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%B3%E8%A1%A8skiplist"><span class="toc-number">1.4.</span> <span class="toc-text">跳表skiplist</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E9%AB%98%E7%9A%84%E7%A1%AE%E5%AE%9A%E9%80%BB%E8%BE%91"><span class="toc-number">1.4.1.</span> <span class="toc-text">层高的确定逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.2.</span> <span class="toc-text">排序方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%A1%A8%E7%9A%84%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">1.4.3.</span> <span class="toc-text">跳表的查询过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%A1%A8%E7%9A%84%E6%96%B0%E5%A2%9E%E8%BF%87%E7%A8%8B"><span class="toc-number">1.4.4.</span> <span class="toc-text">跳表的新增过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%AE%9E%E7%94%A8%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.4.5.</span> <span class="toc-text">为什么不实用平衡二叉树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88"><span class="toc-number">1.5.</span> <span class="toc-text">整数集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8"><span class="toc-number">1.6.</span> <span class="toc-text">压缩列表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#entry"><span class="toc-number">1.6.1.</span> <span class="toc-text">entry</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#quicklist"><span class="toc-number">1.7.</span> <span class="toc-text">quicklist</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#listpack"><span class="toc-number">1.8.</span> <span class="toc-text">listpack</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.</span> <span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.0.1.</span> <span class="toc-text">字符串对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.0.2.</span> <span class="toc-text">列表对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.0.3.</span> <span class="toc-text">哈希对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.0.4.</span> <span class="toc-text">集合对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.0.5.</span> <span class="toc-text">有序集合对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%85%B1%E4%BA%AB"><span class="toc-number">2.0.6.</span> <span class="toc-text">对象共享</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">3.</span> <span class="toc-text">数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="toc-number">3.0.1.</span> <span class="toc-text">过期删除策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">3.0.2.</span> <span class="toc-text">内存淘汰策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E5%BB%BA%E7%9A%84rdb-%E4%B8%8Eaof"><span class="toc-number">3.0.2.1.</span> <span class="toc-text">过期建的rdb 与aof</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">3.0.3.</span> <span class="toc-text">持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rdb"><span class="toc-number">3.0.3.1.</span> <span class="toc-text">rdb</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.0.3.1.1.</span> <span class="toc-text">文件格式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#aof"><span class="toc-number">3.0.3.2.</span> <span class="toc-text">aof</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6"><span class="toc-number">3.0.4.</span> <span class="toc-text">事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%BA%8B%E4%BB%B6"><span class="toc-number">3.0.4.1.</span> <span class="toc-text">文件事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E4%BA%8B%E4%BB%B6"><span class="toc-number">3.0.4.2.</span> <span class="toc-text">时间事件</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">4.</span> <span class="toc-text">服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#serverCron%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.</span> <span class="toc-text">serverCron函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.</span> <span class="toc-text">多机数据库实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6"><span class="toc-number">5.1.</span> <span class="toc-text">复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5"><span class="toc-number">5.2.</span> <span class="toc-text">同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PSYNC"><span class="toc-number">5.2.1.</span> <span class="toc-text">PSYNC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E4%BC%A0%E6%92%AD"><span class="toc-number">5.3.</span> <span class="toc-text">命令传播</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E"><span class="toc-number">5.4.</span> <span class="toc-text">主从</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B%EF%BC%882-8%E7%89%88%E6%9C%AC%E5%90%8E%E6%96%B0%E5%A2%9E%EF%BC%89"><span class="toc-number">5.4.1.</span> <span class="toc-text">心跳检测（2.8版本后新增）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sentinel"><span class="toc-number">5.5.</span> <span class="toc-text">sentinel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8"><span class="toc-number">5.5.1.</span> <span class="toc-text">启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E9%80%89%E4%B8%BB%E6%B5%81%E7%A8%8B"><span class="toc-number">5.5.2.</span> <span class="toc-text">重新选主流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4"><span class="toc-number">5.6.</span> <span class="toc-text">集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cluster-meet%E5%91%BD%E4%BB%A4%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.6.1.</span> <span class="toc-text">cluster meet命令实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A7%BD%E6%8C%87%E6%B4%BE"><span class="toc-number">5.6.2.</span> <span class="toc-text">槽指派</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E5%88%86%E7%89%87"><span class="toc-number">5.6.3.</span> <span class="toc-text">重新分片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ASK%E9%94%99%E8%AF%AF"><span class="toc-number">5.6.4.</span> <span class="toc-text">ASK错误</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E7%89%A9"><span class="toc-number">5.7.</span> <span class="toc-text">事物</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lua%E8%84%9A%E6%9C%AC"><span class="toc-number">5.8.</span> <span class="toc-text">lua脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E4%BC%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%89%A7%E8%A1%8C"><span class="toc-number">5.8.1.</span> <span class="toc-text">通过伪客户端执行</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3"><span class="toc-number">6.</span> <span class="toc-text">缓存相关</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">7.</span> <span class="toc-text">分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">7.1.</span> <span class="toc-text">常见的解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93-1"><span class="toc-number">7.1.1.</span> <span class="toc-text">数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98"><span class="toc-number">7.1.1.1.</span> <span class="toc-text">存在问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis"><span class="toc-number">7.1.2.</span> <span class="toc-text">redis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">7.1.2.1.</span> <span class="toc-text">存在的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RedLock%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B"><span class="toc-number">7.1.2.2.</span> <span class="toc-text">RedLock算法流程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B"><span class="toc-number">7.1.2.2.1.</span> <span class="toc-text">加锁过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zookeeper"><span class="toc-number">7.1.3.</span> <span class="toc-text">zookeeper</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B-1"><span class="toc-number">7.1.3.1.</span> <span class="toc-text">加锁过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">7.1.3.2.</span> <span class="toc-text">缺点</span></a></li></ol></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://localhost:4000/2023/07/05/read/redis/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://localhost:4000/2023/07/05/read/redis/&text=Redis"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://localhost:4000/2023/07/05/read/redis/&title=Redis"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://localhost:4000/2023/07/05/read/redis/&is_video=false&description=Redis"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Redis&body=Check out this article: http://localhost:4000/2023/07/05/read/redis/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://localhost:4000/2023/07/05/read/redis/&title=Redis"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://localhost:4000/2023/07/05/read/redis/&title=Redis"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://localhost:4000/2023/07/05/read/redis/&title=Redis"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://localhost:4000/2023/07/05/read/redis/&title=Redis"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://localhost:4000/2023/07/05/read/redis/&name=Redis&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://localhost:4000/2023/07/05/read/redis/&t=Redis"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2024
    jonas
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/categories/">Category</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a href="/search">Search</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/jonasrepo.github.io">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
